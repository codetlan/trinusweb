(function() {
    var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = true, enumerablesTest = {
        toString: 1
    }, emptyFn = function() {}, i;
    if (typeof Ext === "undefined") {
        global.Ext = {};
    }
    Ext.global = global;
    for (i in enumerablesTest) {
        enumerables = null;
    }
    if (enumerables) {
        enumerables = [ "hasOwnProperty", "valueOf", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "constructor" ];
    }
    Ext.enumerables = enumerables;
    Ext.apply = function(e, t, i) {
        if (i) {
            Ext.apply(e, i);
        }
        if (e && t && typeof t === "object") {
            var n, r, s;
            for (n in t) {
                e[n] = t[n];
            }
            if (enumerables) {
                for (r = enumerables.length; r--; ) {
                    s = enumerables[r];
                    if (t.hasOwnProperty(s)) {
                        e[s] = t[s];
                    }
                }
            }
        }
        return e;
    };
    Ext.buildSettings = Ext.apply({
        baseCSSPrefix: "x-",
        scopeResetCSS: false
    }, Ext.buildSettings || {});
    Ext.apply(Ext, {
        emptyFn: emptyFn,
        baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,
        applyIf: function(e, t) {
            var i;
            if (e) {
                for (i in t) {
                    if (e[i] === undefined) {
                        e[i] = t[i];
                    }
                }
            }
            return e;
        },
        iterate: function(e, t, i) {
            if (Ext.isEmpty(e)) {
                return;
            }
            if (i === undefined) {
                i = e;
            }
            if (Ext.isIterable(e)) {
                Ext.Array.each.call(Ext.Array, e, t, i);
            } else {
                Ext.Object.each.call(Ext.Object, e, t, i);
            }
        }
    });
    Ext.apply(Ext, {
        extend: function() {
            var e = objectPrototype.constructor, t = function(e) {
                for (var t in e) {
                    if (!e.hasOwnProperty(t)) {
                        continue;
                    }
                    this[t] = e[t];
                }
            };
            return function(i, n, r) {
                if (Ext.isObject(n)) {
                    r = n;
                    n = i;
                    i = r.constructor !== e ? r.constructor : function() {
                        n.apply(this, arguments);
                    };
                }
                if (!n) {
                    Ext.Error.raise({
                        sourceClass: "Ext",
                        sourceMethod: "extend",
                        msg: "Attempting to extend from a class which has not been loaded on the page."
                    });
                }
                var s = function() {}, a, o = n.prototype;
                s.prototype = o;
                a = i.prototype = new s();
                a.constructor = i;
                i.superclass = o;
                if (o.constructor === e) {
                    o.constructor = n;
                }
                i.override = function(e) {
                    Ext.override(i, e);
                };
                a.override = t;
                a.proto = a;
                i.override(r);
                i.extend = function(e) {
                    return Ext.extend(i, e);
                };
                return i;
            };
        }(),
        override: function(e, t) {
            if (e.$isClass) {
                return e.override(t);
            } else {
                Ext.apply(e.prototype, t);
            }
        }
    });
    Ext.apply(Ext, {
        valueFrom: function(e, t, i) {
            return Ext.isEmpty(e, i) ? t : e;
        },
        typeOf: function(e) {
            if (e === null) {
                return "null";
            }
            var t = typeof e;
            if (t === "undefined" || t === "string" || t === "number" || t === "boolean") {
                return t;
            }
            var i = toString.call(e);
            switch (i) {
              case "[object Array]":
                return "array";

              case "[object Date]":
                return "date";

              case "[object Boolean]":
                return "boolean";

              case "[object Number]":
                return "number";

              case "[object RegExp]":
                return "regexp";
            }
            if (t === "function") {
                return "function";
            }
            if (t === "object") {
                if (e.nodeType !== undefined) {
                    if (e.nodeType === 3) {
                        return /\S/.test(e.nodeValue) ? "textnode" : "whitespace";
                    } else {
                        return "element";
                    }
                }
                return "object";
            }
            Ext.Error.raise({
                sourceClass: "Ext",
                sourceMethod: "typeOf",
                msg: 'Failed to determine the type of the specified value "' + e + '". This is most likely a bug.'
            });
        },
        isEmpty: function(e, t) {
            return e === null || e === undefined || (!t ? e === "" : false) || Ext.isArray(e) && e.length === 0;
        },
        isArray: "isArray" in Array ? Array.isArray : function(e) {
            return toString.call(e) === "[object Array]";
        },
        isDate: function(e) {
            return toString.call(e) === "[object Date]";
        },
        isMSDate: function(e) {
            if (!Ext.isString(e)) {
                return false;
            } else {
                return e.match("\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/") !== null;
            }
        },
        isObject: toString.call(null) === "[object Object]" ? function(e) {
            return e !== null && e !== undefined && toString.call(e) === "[object Object]" && e.ownerDocument === undefined;
        } : function(e) {
            return toString.call(e) === "[object Object]";
        },
        isSimpleObject: function(e) {
            return e instanceof Object && e.constructor === Object;
        },
        isPrimitive: function(e) {
            var t = typeof e;
            return t === "string" || t === "number" || t === "boolean";
        },
        isFunction: typeof document !== "undefined" && typeof document.getElementsByTagName("body") === "function" ? function(e) {
            return toString.call(e) === "[object Function]";
        } : function(e) {
            return typeof e === "function";
        },
        isNumber: function(e) {
            return typeof e === "number" && isFinite(e);
        },
        isNumeric: function(e) {
            return !isNaN(parseFloat(e)) && isFinite(e);
        },
        isString: function(e) {
            return typeof e === "string";
        },
        isBoolean: function(e) {
            return typeof e === "boolean";
        },
        isElement: function(e) {
            return e ? e.nodeType === 1 : false;
        },
        isTextNode: function(e) {
            return e ? e.nodeName === "#text" : false;
        },
        isDefined: function(e) {
            return typeof e !== "undefined";
        },
        isIterable: function(e) {
            return e && typeof e !== "string" ? e.length !== undefined : false;
        }
    });
    Ext.apply(Ext, {
        clone: function(e) {
            if (e === null || e === undefined) {
                return e;
            }
            if (e.nodeType && e.cloneNode) {
                return e.cloneNode(true);
            }
            var t = toString.call(e);
            if (t === "[object Date]") {
                return new Date(e.getTime());
            }
            var i, n, r, s, a;
            if (t === "[object Array]") {
                i = e.length;
                s = [];
                while (i--) {
                    s[i] = Ext.clone(e[i]);
                }
            } else if (t === "[object Object]" && e.constructor === Object) {
                s = {};
                for (a in e) {
                    s[a] = Ext.clone(e[a]);
                }
                if (enumerables) {
                    for (n = enumerables.length; n--; ) {
                        r = enumerables[n];
                        s[r] = e[r];
                    }
                }
            }
            return s || e;
        },
        getUniqueGlobalNamespace: function() {
            var e = this.uniqueGlobalNamespace;
            if (e === undefined) {
                var t = 0;
                do {
                    e = "ExtBox" + ++t;
                } while (Ext.global[e] !== undefined);
                Ext.global[e] = Ext;
                this.uniqueGlobalNamespace = e;
            }
            return e;
        },
        functionFactory: function() {
            var e = Array.prototype.slice.call(arguments), t = e.length;
            if (t > 0) {
                e[t - 1] = "var Ext=window." + this.getUniqueGlobalNamespace() + ";" + e[t - 1];
            }
            return Function.prototype.constructor.apply(Function.prototype, e);
        },
        globalEval: "execScript" in global ? function(e) {
            global.execScript(e);
        } : function(code) {
            (function() {
                eval(code);
            })();
        },
        Logger: {
            log: function(e, t) {
                if ("console" in global) {
                    if (!t || !(t in global.console)) {
                        t = "log";
                    }
                    e = "[" + t.toUpperCase() + "] " + e;
                    global.console[t](e);
                }
            },
            verbose: function(e) {
                this.log(e, "verbose");
            },
            info: function(e) {
                this.log(e, "info");
            },
            warn: function(e) {
                this.log(e, "warn");
            },
            error: function(e) {
                throw new Error(e);
            },
            deprecate: function(e) {
                this.log(e, "warn");
            }
        }
    });
    Ext.type = Ext.typeOf;
})();

(function() {
    var e = "4.1.0", t;
    Ext.Version = t = Ext.extend(Object, {
        constructor: function(e) {
            var i = this.toNumber, n, r;
            if (e instanceof t) {
                return e;
            }
            this.version = this.shortVersion = String(e).toLowerCase().replace(/_/g, ".").replace(/[\-+]/g, "");
            r = this.version.search(/([^\d\.])/);
            if (r !== -1) {
                this.release = this.version.substr(r, e.length);
                this.shortVersion = this.version.substr(0, r);
            }
            this.shortVersion = this.shortVersion.replace(/[^\d]/g, "");
            n = this.version.split(".");
            this.major = i(n.shift());
            this.minor = i(n.shift());
            this.patch = i(n.shift());
            this.build = i(n.shift());
            return this;
        },
        toNumber: function(e) {
            e = parseInt(e || 0, 10);
            if (isNaN(e)) {
                e = 0;
            }
            return e;
        },
        toString: function() {
            return this.version;
        },
        valueOf: function() {
            return this.version;
        },
        getMajor: function() {
            return this.major || 0;
        },
        getMinor: function() {
            return this.minor || 0;
        },
        getPatch: function() {
            return this.patch || 0;
        },
        getBuild: function() {
            return this.build || 0;
        },
        getRelease: function() {
            return this.release || "";
        },
        isGreaterThan: function(e) {
            return t.compare(this.version, e) === 1;
        },
        isGreaterThanOrEqual: function(e) {
            return t.compare(this.version, e) >= 0;
        },
        isLessThan: function(e) {
            return t.compare(this.version, e) === -1;
        },
        isLessThanOrEqual: function(e) {
            return t.compare(this.version, e) <= 0;
        },
        equals: function(e) {
            return t.compare(this.version, e) === 0;
        },
        match: function(e) {
            e = String(e);
            return this.version.substr(0, e.length) === e;
        },
        toArray: function() {
            return [ this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease() ];
        },
        getShortVersion: function() {
            return this.shortVersion;
        },
        gt: function() {
            return this.isGreaterThan.apply(this, arguments);
        },
        lt: function() {
            return this.isLessThan.apply(this, arguments);
        },
        gtEq: function() {
            return this.isGreaterThanOrEqual.apply(this, arguments);
        },
        ltEq: function() {
            return this.isLessThanOrEqual.apply(this, arguments);
        }
    });
    Ext.apply(t, {
        releaseValueMap: {
            dev: -6,
            alpha: -5,
            a: -5,
            beta: -4,
            b: -4,
            rc: -3,
            "#": -2,
            p: -1,
            pl: -1
        },
        getComponentValue: function(e) {
            return !e ? 0 : isNaN(e) ? this.releaseValueMap[e] || e : parseInt(e, 10);
        },
        compare: function(e, i) {
            var n, r, s;
            e = new t(e).toArray();
            i = new t(i).toArray();
            for (s = 0; s < Math.max(e.length, i.length); s++) {
                n = this.getComponentValue(e[s]);
                r = this.getComponentValue(i[s]);
                if (n < r) {
                    return -1;
                } else if (n > r) {
                    return 1;
                }
            }
            return 0;
        }
    });
    Ext.apply(Ext, {
        versions: {},
        lastRegisteredVersion: null,
        setVersion: function(e, i) {
            Ext.versions[e] = new t(i);
            Ext.lastRegisteredVersion = Ext.versions[e];
            return this;
        },
        getVersion: function(e) {
            if (e === undefined) {
                return Ext.lastRegisteredVersion;
            }
            return Ext.versions[e];
        },
        deprecate: function(e, i, n, r) {
            if (t.compare(Ext.getVersion(e), i) < 1) {
                n.call(r);
            }
        }
    });
    Ext.setVersion("core", e);
})();

Ext.String = {
    trimRegex: /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
    escapeRe: /('|\\)/g,
    formatRe: /\{(\d+)\}/g,
    escapeRegexRe: /([-.*+?^${}()|[\]\/\\])/g,
    htmlEncode: function() {
        var e = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;"
        }, t = [], i, n;
        for (i in e) {
            t.push(i);
        }
        n = new RegExp("(" + t.join("|") + ")", "g");
        return function(t) {
            return !t ? t : String(t).replace(n, function(t, i) {
                return e[i];
            });
        };
    }(),
    htmlDecode: function() {
        var e = {
            "&amp;": "&",
            "&gt;": ">",
            "&lt;": "<",
            "&quot;": '"'
        }, t = [], i, n;
        for (i in e) {
            t.push(i);
        }
        n = new RegExp("(" + t.join("|") + "|&#[0-9]{1,5};" + ")", "g");
        return function(t) {
            return !t ? t : String(t).replace(n, function(t, i) {
                if (i in e) {
                    return e[i];
                } else {
                    return String.fromCharCode(parseInt(i.substr(2), 10));
                }
            });
        };
    }(),
    urlAppend: function(e, t) {
        if (!Ext.isEmpty(t)) {
            return e + (e.indexOf("?") === -1 ? "?" : "&") + t;
        }
        return e;
    },
    trim: function(e) {
        return e.replace(Ext.String.trimRegex, "");
    },
    capitalize: function(e) {
        return e.charAt(0).toUpperCase() + e.substr(1);
    },
    ellipsis: function(e, t, i) {
        if (e && e.length > t) {
            if (i) {
                var n = e.substr(0, t - 2), r = Math.max(n.lastIndexOf(" "), n.lastIndexOf("."), n.lastIndexOf("!"), n.lastIndexOf("?"));
                if (r !== -1 && r >= t - 15) {
                    return n.substr(0, r) + "...";
                }
            }
            return e.substr(0, t - 3) + "...";
        }
        return e;
    },
    escapeRegex: function(e) {
        return e.replace(Ext.String.escapeRegexRe, "\\$1");
    },
    escape: function(e) {
        return e.replace(Ext.String.escapeRe, "\\$1");
    },
    toggle: function(e, t, i) {
        return e === t ? i : t;
    },
    leftPad: function(e, t, i) {
        var n = String(e);
        i = i || " ";
        while (n.length < t) {
            n = i + n;
        }
        return n;
    },
    format: function(e) {
        var t = Ext.Array.toArray(arguments, 1);
        return e.replace(Ext.String.formatRe, function(e, i) {
            return t[i];
        });
    },
    repeat: function(e, t, i) {
        for (var n = [], r = t; r--; ) {
            n.push(e);
        }
        return n.join(i || "");
    }
};

Ext.htmlEncode = Ext.String.htmlEncode;

Ext.htmlDecode = Ext.String.htmlDecode;

Ext.urlAppend = Ext.String.urlAppend;

(function() {
    var e = Array.prototype, t = e.slice, i = function() {
        var e = [], t, i = 20;
        if (!e.splice) {
            return false;
        }
        while (i--) {
            e.push("A");
        }
        e.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F");
        t = e.length;
        e.splice(13, 0, "XXX");
        if (t + 1 != e.length) {
            return false;
        }
        return true;
    }(), n = "forEach" in e, r = "map" in e, s = "indexOf" in e, a = "every" in e, o = "some" in e, l = "filter" in e, u = function() {
        var e = [ 1, 2, 3, 4, 5 ].sort(function() {
            return 0;
        });
        return e[0] === 1 && e[1] === 2 && e[2] === 3 && e[3] === 4 && e[4] === 5;
    }(), c = true, f;
    try {
        if (typeof document !== "undefined") {
            t.call(document.getElementsByTagName("body"));
        }
    } catch (d) {
        c = false;
    }
    function h(e, t) {
        return t < 0 ? Math.max(0, e.length + t) : Math.min(e.length, t);
    }
    function g(e, t, i, n) {
        var r = n ? n.length : 0, s = e.length, a = h(e, t);
        if (a === s) {
            if (r) {
                e.push.apply(e, n);
            }
        } else {
            var o = Math.min(i, s - a), l = a + o, u = l + r - o, c = s - l, f = s - o, d;
            if (u < l) {
                for (d = 0; d < c; ++d) {
                    e[u + d] = e[l + d];
                }
            } else if (u > l) {
                for (d = c; d--; ) {
                    e[u + d] = e[l + d];
                }
            }
            if (r && a === f) {
                e.length = f;
                e.push.apply(e, n);
            } else {
                e.length = f + r;
                for (d = 0; d < r; ++d) {
                    e[a + d] = n[d];
                }
            }
        }
        return e;
    }
    function p(e, t, i, n) {
        if (n && n.length) {
            if (t < e.length) {
                e.splice.apply(e, [ t, i ].concat(n));
            } else {
                e.push.apply(e, n);
            }
        } else {
            e.splice(t, i);
        }
        return e;
    }
    function m(e, t, i) {
        return g(e, t, i);
    }
    function x(e, t, i) {
        e.splice(t, i);
        return e;
    }
    function E(e, i, n) {
        var r = h(e, i), s = e.slice(i, h(e, r + n));
        if (arguments.length < 4) {
            g(e, r, n);
        } else {
            g(e, r, n, t.call(arguments, 3));
        }
        return s;
    }
    function y(e) {
        return e.splice.apply(e, t.call(arguments, 1));
    }
    var v = i ? x : m, b = i ? p : g, S = i ? y : E;
    f = Ext.Array = {
        each: function(e, t, i, n) {
            e = f.from(e);
            var r, s = e.length;
            if (n !== true) {
                for (r = 0; r < s; r++) {
                    if (t.call(i || e[r], e[r], r, e) === false) {
                        return r;
                    }
                }
            } else {
                for (r = s - 1; r > -1; r--) {
                    if (t.call(i || e[r], e[r], r, e) === false) {
                        return r;
                    }
                }
            }
            return true;
        },
        forEach: n ? function(e, t, i) {
            return e.forEach(t, i);
        } : function(e, t, i) {
            var n = 0, r = e.length;
            for (;n < r; n++) {
                t.call(i, e[n], n, e);
            }
        },
        indexOf: s ? function(e, t, i) {
            return e.indexOf(t, i);
        } : function(e, t, i) {
            var n, r = e.length;
            for (n = i < 0 ? Math.max(0, r + i) : i || 0; n < r; n++) {
                if (e[n] === t) {
                    return n;
                }
            }
            return -1;
        },
        contains: s ? function(e, t) {
            return e.indexOf(t) !== -1;
        } : function(e, t) {
            var i, n;
            for (i = 0, n = e.length; i < n; i++) {
                if (e[i] === t) {
                    return true;
                }
            }
            return false;
        },
        toArray: function(e, i, n) {
            if (!e || !e.length) {
                return [];
            }
            if (typeof e === "string") {
                e = e.split("");
            }
            if (c) {
                return t.call(e, i || 0, n || e.length);
            }
            var r = [], s;
            i = i || 0;
            n = n ? n < 0 ? e.length + n : n : e.length;
            for (s = i; s < n; s++) {
                r.push(e[s]);
            }
            return r;
        },
        pluck: function(e, t) {
            var i = [], n, r, s;
            for (n = 0, r = e.length; n < r; n++) {
                s = e[n];
                i.push(s[t]);
            }
            return i;
        },
        map: r ? function(e, t, i) {
            return e.map(t, i);
        } : function(e, t, i) {
            var n = [], r = 0, s = e.length;
            for (;r < s; r++) {
                n[r] = t.call(i, e[r], r, e);
            }
            return n;
        },
        every: function(e, t, i) {
            if (!t) {
                Ext.Error.raise("Ext.Array.every must have a callback function passed as second argument.");
            }
            if (a) {
                return e.every(t, i);
            }
            var n = 0, r = e.length;
            for (;n < r; ++n) {
                if (!t.call(i, e[n], n, e)) {
                    return false;
                }
            }
            return true;
        },
        some: function(e, t, i) {
            if (!t) {
                Ext.Error.raise("Ext.Array.some must have a callback function passed as second argument.");
            }
            if (o) {
                return e.some(t, i);
            }
            var n = 0, r = e.length;
            for (;n < r; ++n) {
                if (t.call(i, e[n], n, e)) {
                    return true;
                }
            }
            return false;
        },
        clean: function(e) {
            var t = [], i = 0, n = e.length, r;
            for (;i < n; i++) {
                r = e[i];
                if (!Ext.isEmpty(r)) {
                    t.push(r);
                }
            }
            return t;
        },
        unique: function(e) {
            var t = [], i = 0, n = e.length, r;
            for (;i < n; i++) {
                r = e[i];
                if (f.indexOf(t, r) === -1) {
                    t.push(r);
                }
            }
            return t;
        },
        filter: function(e, t, i) {
            if (l) {
                return e.filter(t, i);
            }
            var n = [], r = 0, s = e.length;
            for (;r < s; r++) {
                if (t.call(i, e[r], r, e)) {
                    n.push(e[r]);
                }
            }
            return n;
        },
        from: function(e, i) {
            if (e === undefined || e === null) {
                return [];
            }
            if (Ext.isArray(e)) {
                return i ? t.call(e) : e;
            }
            if (e && e.length !== undefined && typeof e !== "string") {
                return f.toArray(e);
            }
            return [ e ];
        },
        remove: function(e, t) {
            var i = f.indexOf(e, t);
            if (i !== -1) {
                v(e, i, 1);
            }
            return e;
        },
        include: function(e, t) {
            if (!f.contains(e, t)) {
                e.push(t);
            }
        },
        clone: function(e) {
            return t.call(e);
        },
        merge: function() {
            var e = t.call(arguments), i = [], n, r;
            for (n = 0, r = e.length; n < r; n++) {
                i = i.concat(e[n]);
            }
            return f.unique(i);
        },
        intersect: function() {
            var e = [], i = t.call(arguments), n, r, s, a;
            if (!i.length) {
                return e;
            }
            i = i.sort(function(e, t) {
                if (e.length > t.length) {
                    return 1;
                } else if (e.length < t.length) {
                    return -1;
                } else {
                    return 0;
                }
            });
            r = f.unique(i[0]);
            for (s = 0; s < r.length; s++) {
                n = r[s];
                for (a = 1; a < i.length; a++) {
                    if (i[a].indexOf(n) === -1) {
                        break;
                    }
                    if (a == i.length - 1) {
                        e.push(n);
                    }
                }
            }
            return e;
        },
        difference: function(e, i) {
            var n = t.call(e), r = n.length, s, a, o;
            for (s = 0, o = i.length; s < o; s++) {
                for (a = 0; a < r; a++) {
                    if (n[a] === i[s]) {
                        v(n, a, 1);
                        a--;
                        r--;
                    }
                }
            }
            return n;
        },
        slice: function(e, i, n) {
            return t.call(e, i, n);
        },
        sort: function(e, t) {
            if (u) {
                if (t) {
                    return e.sort(t);
                } else {
                    return e.sort();
                }
            }
            var i = e.length, n = 0, r, s, a, o;
            for (;n < i; n++) {
                a = n;
                for (s = n + 1; s < i; s++) {
                    if (t) {
                        r = t(e[s], e[a]);
                        if (r < 0) {
                            a = s;
                        }
                    } else if (e[s] < e[a]) {
                        a = s;
                    }
                }
                if (a !== n) {
                    o = e[n];
                    e[n] = e[a];
                    e[a] = o;
                }
            }
            return e;
        },
        flatten: function(e) {
            var t = [];
            function i(e) {
                var n, r, s;
                for (n = 0, r = e.length; n < r; n++) {
                    s = e[n];
                    if (Ext.isArray(s)) {
                        i(s);
                    } else {
                        t.push(s);
                    }
                }
                return t;
            }
            return i(e);
        },
        min: function(e, t) {
            var i = e[0], n, r, s;
            for (n = 0, r = e.length; n < r; n++) {
                s = e[n];
                if (t) {
                    if (t(i, s) === 1) {
                        i = s;
                    }
                } else {
                    if (s < i) {
                        i = s;
                    }
                }
            }
            return i;
        },
        max: function(e, t) {
            var i = e[0], n, r, s;
            for (n = 0, r = e.length; n < r; n++) {
                s = e[n];
                if (t) {
                    if (t(i, s) === -1) {
                        i = s;
                    }
                } else {
                    if (s > i) {
                        i = s;
                    }
                }
            }
            return i;
        },
        mean: function(e) {
            return e.length > 0 ? f.sum(e) / e.length : undefined;
        },
        sum: function(e) {
            var t = 0, i, n, r;
            for (i = 0, n = e.length; i < n; i++) {
                r = e[i];
                t += r;
            }
            return t;
        },
        _replaceSim: g,
        _spliceSim: E,
        erase: v,
        insert: function(e, t, i) {
            return b(e, t, 0, i);
        },
        replace: b,
        splice: S
    };
    Ext.each = f.each;
    f.union = f.merge;
    Ext.min = f.min;
    Ext.max = f.max;
    Ext.sum = f.sum;
    Ext.mean = f.mean;
    Ext.flatten = f.flatten;
    Ext.clean = f.clean;
    Ext.unique = f.unique;
    Ext.pluck = f.pluck;
    Ext.toArray = function() {
        return f.toArray.apply(f, arguments);
    };
})();

(function() {
    var e = .9.toFixed() !== "1";
    Ext.Number = {
        constrain: function(e, t, i) {
            e = parseFloat(e);
            if (!isNaN(t)) {
                e = Math.max(e, t);
            }
            if (!isNaN(i)) {
                e = Math.min(e, i);
            }
            return e;
        },
        snap: function(e, t, i, n) {
            var r = e, s;
            if (!(t && e)) {
                return e;
            }
            s = e % t;
            if (s !== 0) {
                r -= s;
                if (s * 2 >= t) {
                    r += t;
                } else if (s * 2 < -t) {
                    r -= t;
                }
            }
            return Ext.Number.constrain(r, i, n);
        },
        toFixed: function(t, i) {
            if (e) {
                i = i || 0;
                var n = Math.pow(10, i);
                return (Math.round(t * n) / n).toFixed(i);
            }
            return t.toFixed(i);
        },
        from: function(e, t) {
            if (isFinite(e)) {
                e = parseFloat(e);
            }
            return !isNaN(e) ? e : t;
        }
    };
})();

Ext.num = function() {
    return Ext.Number.from.apply(this, arguments);
};

(function() {
    var e = function() {};
    var t = Ext.Object = {
        chain: "create" in Object ? function(e) {
            return Object.create(e);
        } : function(t) {
            e.prototype = t;
            var i = new e();
            e.prototype = null;
            return i;
        },
        toQueryObjects: function(e, i, n) {
            var r = t.toQueryObjects, s = [], a, o;
            if (Ext.isArray(i)) {
                for (a = 0, o = i.length; a < o; a++) {
                    if (n) {
                        s = s.concat(r(e + "[" + a + "]", i[a], true));
                    } else {
                        s.push({
                            name: e,
                            value: i[a]
                        });
                    }
                }
            } else if (Ext.isObject(i)) {
                for (a in i) {
                    if (i.hasOwnProperty(a)) {
                        if (n) {
                            s = s.concat(r(e + "[" + a + "]", i[a], true));
                        } else {
                            s.push({
                                name: e,
                                value: i[a]
                            });
                        }
                    }
                }
            } else {
                s.push({
                    name: e,
                    value: i
                });
            }
            return s;
        },
        toQueryString: function(e, i) {
            var n = [], r = [], s, a, o, l, u;
            for (s in e) {
                if (e.hasOwnProperty(s)) {
                    n = n.concat(t.toQueryObjects(s, e[s], i));
                }
            }
            for (a = 0, o = n.length; a < o; a++) {
                l = n[a];
                u = l.value;
                if (Ext.isEmpty(u)) {
                    u = "";
                } else if (Ext.isDate(u)) {
                    u = Ext.Date.toString(u);
                }
                r.push(encodeURIComponent(l.name) + "=" + encodeURIComponent(String(u)));
            }
            return r.join("&");
        },
        fromQueryString: function(e, t) {
            var i = e.replace(/^\?/, "").split("&"), n = {}, r, s, a, o, l, u, c, f, d, h, g, p, m, x;
            for (l = 0, u = i.length; l < u; l++) {
                c = i[l];
                if (c.length > 0) {
                    s = c.split("=");
                    a = decodeURIComponent(s[0]);
                    o = s[1] !== undefined ? decodeURIComponent(s[1]) : "";
                    if (!t) {
                        if (n.hasOwnProperty(a)) {
                            if (!Ext.isArray(n[a])) {
                                n[a] = [ n[a] ];
                            }
                            n[a].push(o);
                        } else {
                            n[a] = o;
                        }
                    } else {
                        h = a.match(/(\[):?([^\]]*)\]/g);
                        g = a.match(/^([^\[]+)/);
                        if (!g) {
                            throw new Error('[Ext.Object.fromQueryString] Malformed query string given, failed parsing name from "' + c + '"');
                        }
                        a = g[0];
                        p = [];
                        if (h === null) {
                            n[a] = o;
                            continue;
                        }
                        for (f = 0, d = h.length; f < d; f++) {
                            m = h[f];
                            m = m.length === 2 ? "" : m.substring(1, m.length - 1);
                            p.push(m);
                        }
                        p.unshift(a);
                        r = n;
                        for (f = 0, d = p.length; f < d; f++) {
                            m = p[f];
                            if (f === d - 1) {
                                if (Ext.isArray(r) && m === "") {
                                    r.push(o);
                                } else {
                                    r[m] = o;
                                }
                            } else {
                                if (r[m] === undefined || typeof r[m] === "string") {
                                    x = p[f + 1];
                                    r[m] = Ext.isNumeric(x) || x === "" ? [] : {};
                                }
                                r = r[m];
                            }
                        }
                    }
                }
            }
            return n;
        },
        each: function(e, t, i) {
            for (var n in e) {
                if (e.hasOwnProperty(n)) {
                    if (t.call(i || e, n, e[n], e) === false) {
                        return;
                    }
                }
            }
        },
        merge: function(e) {
            var i = 1, n = arguments.length, r = t.merge, s = Ext.clone, a, o, l, u;
            for (;i < n; i++) {
                a = arguments[i];
                for (o in a) {
                    l = a[o];
                    if (l && l.constructor === Object) {
                        u = e[o];
                        if (u && u.constructor === Object) {
                            r(u, l);
                        } else {
                            e[o] = s(l);
                        }
                    } else {
                        e[o] = l;
                    }
                }
            }
            return e;
        },
        mergeIf: function(e) {
            var t = 1, i = arguments.length, n = Ext.clone, r, s, a;
            for (;t < i; t++) {
                r = arguments[t];
                for (s in r) {
                    if (!(s in e)) {
                        a = r[s];
                        if (a && a.constructor === Object) {
                            e[s] = n(a);
                        } else {
                            e[s] = a;
                        }
                    }
                }
            }
            return e;
        },
        getKey: function(e, t) {
            for (var i in e) {
                if (e.hasOwnProperty(i) && e[i] === t) {
                    return i;
                }
            }
            return null;
        },
        getValues: function(e) {
            var t = [], i;
            for (i in e) {
                if (e.hasOwnProperty(i)) {
                    t.push(e[i]);
                }
            }
            return t;
        },
        getKeys: "keys" in Object ? Object.keys : function(e) {
            var t = [], i;
            for (i in e) {
                if (e.hasOwnProperty(i)) {
                    t.push(i);
                }
            }
            return t;
        },
        getSize: function(e) {
            var t = 0, i;
            for (i in e) {
                if (e.hasOwnProperty(i)) {
                    t++;
                }
            }
            return t;
        },
        classify: function(e) {
            var i = [], n = [], r = {}, s = function() {
                var t = 0, s = i.length, a;
                for (;t < s; t++) {
                    a = i[t];
                    this[a] = new r[a]();
                }
                s = n.length;
                for (t = 0; t < s; t++) {
                    a = n[t];
                    this[a] = e[a].slice();
                }
            }, a, o, l;
            for (a in e) {
                if (e.hasOwnProperty(a)) {
                    o = e[a];
                    if (o) {
                        l = o.constructor;
                        if (l === Object) {
                            i.push(a);
                            r[a] = t.classify(o);
                        } else if (l === Array) {
                            n.push(a);
                        }
                    }
                }
            }
            s.prototype = e;
            return s;
        },
        defineProperty: "defineProperty" in Object ? Object.defineProperty : function(e, t, i) {
            if (i.get) {
                e.__defineGetter__(t, i.get);
            }
            if (i.set) {
                e.__defineSetter__(t, i.set);
            }
        }
    };
    Ext.merge = Ext.Object.merge;
    Ext.mergeIf = Ext.Object.mergeIf;
    Ext.urlEncode = function() {
        var e = Ext.Array.from(arguments), i = "";
        if (typeof e[1] === "string") {
            i = e[1] + "&";
            e[1] = false;
        }
        return i + t.toQueryString.apply(t, e);
    };
    Ext.urlDecode = function() {
        return t.fromQueryString.apply(t, arguments);
    };
})();

Ext.Function = {
    flexSetter: function(e) {
        return function(t, i) {
            var n, r;
            if (t === null) {
                return this;
            }
            if (typeof t !== "string") {
                for (n in t) {
                    if (t.hasOwnProperty(n)) {
                        e.call(this, n, t[n]);
                    }
                }
                if (Ext.enumerables) {
                    for (r = Ext.enumerables.length; r--; ) {
                        n = Ext.enumerables[r];
                        if (t.hasOwnProperty(n)) {
                            e.call(this, n, t[n]);
                        }
                    }
                }
            } else {
                e.call(this, t, i);
            }
            return this;
        };
    },
    bind: function(e, t, i, n) {
        if (arguments.length === 2) {
            return function() {
                return e.apply(t, arguments);
            };
        }
        var r = e, s = Array.prototype.slice;
        return function() {
            var e = i || arguments;
            if (n === true) {
                e = s.call(arguments, 0);
                e = e.concat(i);
            } else if (typeof n == "number") {
                e = s.call(arguments, 0);
                Ext.Array.insert(e, n, i);
            }
            return r.apply(t || window, e);
        };
    },
    pass: function(e, t, i) {
        if (!Ext.isArray(t)) {
            t = Ext.Array.clone(t);
        }
        return function() {
            t.push.apply(t, arguments);
            return e.apply(i || this, t);
        };
    },
    alias: function(e, t) {
        return function() {
            return e[t].apply(e, arguments);
        };
    },
    clone: function(e) {
        return function() {
            return e.apply(this, arguments);
        };
    },
    createInterceptor: function(e, t, i, n) {
        var r = e;
        if (!Ext.isFunction(t)) {
            return e;
        } else {
            return function() {
                var r = this, s = arguments;
                t.target = r;
                t.method = e;
                return t.apply(i || r || window, s) !== false ? e.apply(r || window, s) : n || null;
            };
        }
    },
    createDelayed: function(e, t, i, n, r) {
        if (i || n) {
            e = Ext.Function.bind(e, i, n, r);
        }
        return function() {
            var i = this, n = Array.prototype.slice.call(arguments);
            setTimeout(function() {
                e.apply(i, n);
            }, t);
        };
    },
    defer: function(e, t, i, n, r) {
        e = Ext.Function.bind(e, i, n, r);
        if (t > 0) {
            return setTimeout(e, t);
        }
        e();
        return 0;
    },
    createSequence: function(e, t, i) {
        if (!t) {
            return e;
        } else {
            return function() {
                var n = e.apply(this, arguments);
                t.apply(i || this, arguments);
                return n;
            };
        }
    },
    createBuffered: function(e, t, i, n) {
        var r;
        return function() {
            var s = n || Array.prototype.slice.call(arguments, 0), a = i || this;
            if (r) {
                clearTimeout(r);
            }
            r = setTimeout(function() {
                e.apply(a, s);
            }, t);
        };
    },
    createThrottled: function(e, t, i) {
        var n, r, s, a, o = function() {
            e.apply(i || this, s);
            n = new Date().getTime();
        };
        return function() {
            r = new Date().getTime() - n;
            s = arguments;
            clearTimeout(a);
            if (!n || r >= t) {
                o();
            } else {
                a = setTimeout(o, t - r);
            }
        };
    },
    interceptBefore: function(e, t, i) {
        var n = e[t] || Ext.emptyFn;
        return e[t] = function() {
            var e = i.apply(this, arguments);
            n.apply(this, arguments);
            return e;
        };
    },
    interceptAfter: function(e, t, i) {
        var n = e[t] || Ext.emptyFn;
        return e[t] = function() {
            n.apply(this, arguments);
            return i.apply(this, arguments);
        };
    }
};

Ext.defer = Ext.Function.alias(Ext.Function, "defer");

Ext.pass = Ext.Function.alias(Ext.Function, "pass");

Ext.bind = Ext.Function.alias(Ext.Function, "bind");

Ext.JSON = new function() {
    var useHasOwn = !!{}.hasOwnProperty, isNative = function() {
        var e = null;
        return function() {
            if (e === null) {
                e = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == "[object JSON]";
            }
            return e;
        };
    }(), pad = function(e) {
        return e < 10 ? "0" + e : e;
    }, doDecode = function(json) {
        return eval("(" + json + ")");
    }, doEncode = function(e) {
        if (!Ext.isDefined(e) || e === null) {
            return "null";
        } else if (Ext.isArray(e)) {
            return encodeArray(e);
        } else if (Ext.isDate(e)) {
            return Ext.JSON.encodeDate(e);
        } else if (Ext.isString(e)) {
            if (Ext.isMSDate(e)) {
                return encodeMSDate(e);
            } else {
                return encodeString(e);
            }
        } else if (typeof e == "number") {
            return isFinite(e) ? String(e) : "null";
        } else if (Ext.isBoolean(e)) {
            return String(e);
        } else if (Ext.isObject(e)) {
            return encodeObject(e);
        } else if (typeof e === "function") {
            return "null";
        }
        return "undefined";
    }, m = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\",
        "": "\\u000b"
    }, charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(e) {
        return '"' + e.replace(charToReplace, function(e) {
            var t = m[e];
            return typeof t === "string" ? t : "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4);
        }) + '"';
    }, encodeArray = function(e) {
        var t = [ "[", "" ], i = e.length, n;
        for (n = 0; n < i; n += 1) {
            t.push(doEncode(e[n]), ",");
        }
        t[t.length - 1] = "]";
        return t.join("");
    }, encodeObject = function(e) {
        var t = [ "{", "" ], i;
        for (i in e) {
            if (!useHasOwn || e.hasOwnProperty(i)) {
                t.push(doEncode(i), ":", doEncode(e[i]), ",");
            }
        }
        t[t.length - 1] = "}";
        return t.join("");
    }, encodeMSDate = function(e) {
        return '"' + e + '"';
    };
    this.encodeDate = function(e) {
        return '"' + e.getFullYear() + "-" + pad(e.getMonth() + 1) + "-" + pad(e.getDate()) + "T" + pad(e.getHours()) + ":" + pad(e.getMinutes()) + ":" + pad(e.getSeconds()) + '"';
    };
    this.encode = function() {
        var e;
        return function(t) {
            if (!e) {
                e = isNative() ? JSON.stringify : doEncode;
            }
            return e(t);
        };
    }();
    this.decode = function() {
        var e;
        return function(t, i) {
            if (!e) {
                e = isNative() ? JSON.parse : doDecode;
            }
            try {
                return e(t);
            } catch (n) {
                if (i === true) {
                    return null;
                }
                Ext.Error.raise({
                    sourceClass: "Ext.JSON",
                    sourceMethod: "decode",
                    msg: "You're trying to decode an invalid JSON String: " + t
                });
            }
        };
    }();
}();

Ext.encode = Ext.JSON.encode;

Ext.decode = Ext.JSON.decode;

Ext.Error = {
    raise: function(e) {
        throw new Error(e.msg);
    }
};

Ext.Date = {
    now: Date.now,
    toString: function(e) {
        if (!e) {
            e = new Date();
        }
        var t = Ext.String.leftPad;
        return e.getFullYear() + "-" + t(e.getMonth() + 1, 2, "0") + "-" + t(e.getDate(), 2, "0") + "T" + t(e.getHours(), 2, "0") + ":" + t(e.getMinutes(), 2, "0") + ":" + t(e.getSeconds(), 2, "0");
    }
};

(function(e) {
    var t = [], i = function() {};
    Ext.apply(i, {
        $className: "Ext.Base",
        $isClass: true,
        create: function() {
            return Ext.create.apply(Ext, [ this ].concat(Array.prototype.slice.call(arguments, 0)));
        },
        extend: function(e) {
            var t = e.prototype, i, n, r, s, a;
            i = this.prototype = Ext.Object.chain(t);
            i.self = this;
            this.superclass = i.superclass = t;
            if (!e.$isClass) {
                Ext.apply(i, Ext.Base.prototype);
                i.constructor = function() {
                    t.constructor.apply(this, arguments);
                };
            }
            a = t.$inheritableStatics;
            if (a) {
                for (n = 0, r = a.length; n < r; n++) {
                    s = a[n];
                    if (!this.hasOwnProperty(s)) {
                        this[s] = e[s];
                    }
                }
            }
            if (e.$onExtended) {
                this.$onExtended = e.$onExtended.slice();
            }
            i.config = i.defaultConfig = new i.configClass();
            i.initConfigList = i.initConfigList.slice();
            i.initConfigMap = Ext.Object.chain(i.initConfigMap);
        },
        $onExtended: [],
        triggerExtended: function() {
            var e = this.$onExtended, t = e.length, i, n;
            if (t > 0) {
                for (i = 0; i < t; i++) {
                    n = e[i];
                    n.fn.apply(n.scope || this, arguments);
                }
            }
        },
        onExtended: function(e, t) {
            this.$onExtended.push({
                fn: e,
                scope: t
            });
            return this;
        },
        addConfig: function(e, t) {
            var i = this.prototype, n = i.initConfigList, r = i.initConfigMap, s = i.defaultConfig, a, o, l;
            t = Boolean(t);
            for (o in e) {
                if (e.hasOwnProperty(o) && (t || !(o in s))) {
                    l = e[o];
                    a = r[o];
                    if (l !== null) {
                        if (!a) {
                            r[o] = true;
                            n.push(o);
                        }
                    } else if (a) {
                        r[o] = false;
                        Ext.Array.remove(n, o);
                    }
                }
            }
            if (t) {
                Ext.merge(s, e);
            } else {
                Ext.mergeIf(s, e);
            }
            i.configClass = Ext.Object.classify(s);
        },
        addStatics: function(e) {
            var t, i;
            var n = Ext.getClassName(this);
            for (i in e) {
                if (e.hasOwnProperty(i)) {
                    t = e[i];
                    if (typeof t == "function") {
                        t.displayName = n + "." + i;
                    }
                    this[i] = t;
                }
            }
            return this;
        },
        addInheritableStatics: function(e) {
            var t, i, n = this.prototype, r, s;
            t = n.$inheritableStatics;
            i = n.$hasInheritableStatics;
            if (!t) {
                t = n.$inheritableStatics = [];
                i = n.$hasInheritableStatics = {};
            }
            var a = Ext.getClassName(this);
            for (r in e) {
                if (e.hasOwnProperty(r)) {
                    s = e[r];
                    if (typeof s == "function") {
                        s.displayName = a + "." + r;
                    }
                    this[r] = s;
                    if (!i[r]) {
                        i[r] = true;
                        t.push(r);
                    }
                }
            }
            return this;
        },
        addMembers: function(e) {
            var t = this.prototype, i = [], n, r;
            var s = this.$className || "";
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    r = e[n];
                    if (typeof r == "function" && !r.$isClass && r !== Ext.emptyFn) {
                        r.$owner = this;
                        r.$name = n;
                        r.displayName = s + "#" + n;
                    }
                    t[n] = r;
                }
            }
            return this;
        },
        addMember: function(e, t) {
            if (typeof t == "function" && !t.$isClass && t !== Ext.emptyFn) {
                t.$owner = this;
                t.$name = e;
                t.displayName = (this.$className || "") + "#" + e;
            }
            this.prototype[e] = t;
            return this;
        },
        implement: function() {
            this.addMembers.apply(this, arguments);
        },
        borrow: function(e, t) {
            var i = this.prototype, n = e.prototype, r = Ext.getClassName(this), s, a, o, l, u;
            t = Ext.Array.from(t);
            for (s = 0, a = t.length; s < a; s++) {
                o = t[s];
                u = n[o];
                if (typeof u == "function") {
                    l = function() {
                        return u.apply(this, arguments);
                    };
                    if (r) {
                        l.displayName = r + "#" + o;
                    }
                    l.$owner = this;
                    l.$name = o;
                    i[o] = l;
                } else {
                    i[o] = u;
                }
            }
            return this;
        },
        override: function(e) {
            var t = this, i = Ext.enumerables, n = t.prototype, r = Ext.Function.clone, s, a, o, l, u, c;
            if (arguments.length === 2) {
                s = e;
                e = {};
                e[s] = arguments[1];
                i = null;
            }
            do {
                u = [];
                l = null;
                for (s in e) {
                    if (s == "statics") {
                        l = e[s];
                    } else if (s == "config") {
                        t.addConfig(e[s], true);
                    } else {
                        u.push(s);
                    }
                }
                if (i) {
                    u.push.apply(u, i);
                }
                for (a = u.length; a--; ) {
                    s = u[a];
                    if (e.hasOwnProperty(s)) {
                        o = e[s];
                        if (typeof o == "function" && !o.$className && o !== Ext.emptyFn) {
                            if (typeof o.$owner != "undefined") {
                                o = r(o);
                            }
                            var f = t.$className;
                            if (f) {
                                o.displayName = f + "#" + s;
                            }
                            o.$owner = t;
                            o.$name = s;
                            c = n[s];
                            if (c) {
                                o.$previous = c;
                            }
                        }
                        n[s] = o;
                    }
                }
                n = t;
                e = l;
            } while (e);
            return this;
        },
        callParent: function(e) {
            var i;
            return (i = this.callParent.caller) && (i.$previous || (i = i.$owner ? i : i.caller) && i.$owner.superclass.$class[i.$name]).apply(this, e || t);
        },
        mixin: function(e, t) {
            var i = t.prototype, n = this.prototype, r;
            if (typeof i.onClassMixedIn != "undefined") {
                i.onClassMixedIn.call(t, this);
            }
            if (!n.hasOwnProperty("mixins")) {
                if ("mixins" in n) {
                    n.mixins = Ext.Object.chain(n.mixins);
                } else {
                    n.mixins = {};
                }
            }
            for (r in i) {
                if (r === "mixins") {
                    Ext.merge(n.mixins, i[r]);
                } else if (typeof n[r] == "undefined" && r != "mixinId" && r != "config") {
                    n[r] = i[r];
                }
            }
            if ("config" in i) {
                this.addConfig(i.config, false);
            }
            n.mixins[e] = i;
        },
        getName: function() {
            return Ext.getClassName(this);
        },
        createAlias: e(function(e, t) {
            this.override(e, function() {
                return this[t].apply(this, arguments);
            });
        }),
        addXtype: function(e) {
            var t = this.prototype, i = t.xtypesMap, n = t.xtypes, r = t.xtypesChain;
            if (!t.hasOwnProperty("xtypesMap")) {
                i = t.xtypesMap = Ext.merge({}, t.xtypesMap || {});
                n = t.xtypes = t.xtypes ? [].concat(t.xtypes) : [];
                r = t.xtypesChain = t.xtypesChain ? [].concat(t.xtypesChain) : [];
                t.xtype = e;
            }
            if (!i[e]) {
                i[e] = true;
                n.push(e);
                r.push(e);
                Ext.ClassManager.setAlias(this, "widget." + e);
            }
            return this;
        }
    });
    i.implement({
        isInstance: true,
        $className: "Ext.Base",
        configClass: Ext.emptyFn,
        initConfigList: [],
        initConfigMap: {},
        statics: function() {
            var e = this.statics.caller, t = this.self;
            if (!e) {
                return t;
            }
            return e.$owner;
        },
        callParent: function(e) {
            var i, n = (i = this.callParent.caller) && (i.$previous || (i = i.$owner ? i : i.caller) && i.$owner.superclass[i.$name]);
            if (!n) {
                i = this.callParent.caller;
                var r, s;
                if (!i.$owner) {
                    if (!i.caller) {
                        throw new Error("Attempting to call a protected method from the public scope, which is not allowed");
                    }
                    i = i.caller;
                }
                r = i.$owner.superclass;
                s = i.$name;
                if (!(s in r)) {
                    throw new Error("this.callParent() was called but there's no such method (" + s + ") found in the parent class (" + (Ext.getClassName(r) || "Object") + ")");
                }
            }
            return n.apply(this, e || t);
        },
        callSuper: function(e) {
            var i, n = (i = this.callSuper.caller) && (i = i.$owner ? i : i.caller) && i.$owner.superclass[i.$name];
            if (!n) {
                i = this.callSuper.caller;
                var r, s;
                if (!i.$owner) {
                    if (!i.caller) {
                        throw new Error("Attempting to call a protected method from the public scope, which is not allowed");
                    }
                    i = i.caller;
                }
                r = i.$owner.superclass;
                s = i.$name;
                if (!(s in r)) {
                    throw new Error("this.callSuper() was called but there's no such method (" + s + ") found in the parent class (" + (Ext.getClassName(r) || "Object") + ")");
                }
            }
            return n.apply(this, e || t);
        },
        callOverridden: function(e) {
            var i;
            return (i = this.callOverridden.caller) && i.$previous.apply(this, e || t);
        },
        self: i,
        constructor: function() {
            return this;
        },
        wasInstantiated: false,
        initConfig: function(e) {
            var t = Ext.Class.configNameCache, i = this.self.prototype, n = this.initConfigList, r = this.initConfigMap, s = new this.configClass(), a = this.defaultConfig, o, l, u, c, f, d;
            this.initConfig = Ext.emptyFn;
            this.initialConfig = e || {};
            if (e) {
                Ext.merge(s, e);
            }
            this.config = s;
            if (!i.hasOwnProperty("wasInstantiated")) {
                i.wasInstantiated = true;
                for (o = 0, l = n.length; o < l; o++) {
                    u = n[o];
                    f = t[u];
                    c = a[u];
                    if (!(f.apply in i) && !(f.update in i) && i[f.set].$isDefault && typeof c != "object") {
                        i[f.internal] = a[u];
                        r[u] = false;
                        Ext.Array.remove(n, u);
                        o--;
                        l--;
                    }
                }
            }
            if (e) {
                n = n.slice();
                for (u in e) {
                    if (u in a && !r[u]) {
                        n.push(u);
                    }
                }
            }
            for (o = 0, l = n.length; o < l; o++) {
                u = n[o];
                f = t[u];
                this[f.get] = this[f.initGet];
            }
            this.beforeInitConfig(s);
            for (o = 0, l = n.length; o < l; o++) {
                u = n[o];
                f = t[u];
                d = f.get;
                if (this.hasOwnProperty(d)) {
                    this[f.set].call(this, s[u]);
                    delete this[d];
                }
            }
            return this;
        },
        beforeInitConfig: Ext.emptyFn,
        getCurrentConfig: function() {
            var e = this.defaultConfig, t = Ext.Class.configNameCache, i = {}, n, r;
            for (n in e) {
                r = t[n];
                i[n] = this[r.get].call(this);
            }
            return i;
        },
        setConfig: function(e, t) {
            if (!e) {
                return this;
            }
            var i = Ext.Class.configNameCache, n = this.config, r = this.defaultConfig, s = this.initialConfig, a = [], o, l, u, c;
            t = Boolean(t);
            for (o in e) {
                if (t && o in s) {
                    continue;
                }
                n[o] = e[o];
                if (o in r) {
                    a.push(o);
                    c = i[o];
                    this[c.get] = this[c.initGet];
                }
            }
            for (l = 0, u = a.length; l < u; l++) {
                o = a[l];
                c = i[o];
                this[c.set].call(this, e[o]);
                delete this[c.get];
            }
            return this;
        },
        set: function(e, t) {
            return this[Ext.Class.configNameCache[e].set].call(this, t);
        },
        get: function(e) {
            return this[Ext.Class.configNameCache[e].get].call(this);
        },
        getConfig: function(e) {
            return this[Ext.Class.configNameCache[e].get].call(this);
        },
        hasConfig: function(e) {
            return e in this.defaultConfig;
        },
        getInitialConfig: function(e) {
            var t = this.config;
            if (!e) {
                return t;
            } else {
                return t[e];
            }
        },
        onConfigUpdate: function(e, t, i) {
            var n = this.self, r = n.$className, s, a, o, l, u, c;
            e = Ext.Array.from(e);
            i = i || this;
            for (s = 0, a = e.length; s < a; s++) {
                o = e[s];
                l = "update" + Ext.String.capitalize(o);
                u = this[l] || Ext.emptyFn;
                c = function() {
                    u.apply(this, arguments);
                    i[t].apply(i, arguments);
                };
                c.$name = l;
                c.$owner = n;
                c.displayName = r + "#" + l;
                this[l] = c;
            }
        },
        link: function(e, t) {
            this.$links = {};
            this.link = this.doLink;
            return this.link.apply(this, arguments);
        },
        doLink: function(e, t) {
            this.$links[e] = true;
            this[e] = t;
            return t;
        },
        unlink: function() {
            var e, t, i, n;
            for (e = 0, t = arguments.length; e < t; e++) {
                i = arguments[e];
                if (this.hasOwnProperty(i)) {
                    n = this[i];
                    if (n) {
                        if (n.isInstance && !n.isDestroyed) {
                            n.destroy();
                        } else if (n.parentNode && "nodeType" in n) {
                            n.parentNode.removeChild(n);
                        }
                    }
                    delete this[i];
                }
            }
            return this;
        },
        destroy: function() {
            this.destroy = Ext.emptyFn;
            this.isDestroyed = true;
            if (this.hasOwnProperty("$links")) {
                this.unlink.apply(this, Ext.Object.getKeys(this.$links));
                delete this.$links;
            }
        }
    });
    Ext.Base = i;
})(Ext.Function.flexSetter);

(function() {
    var e, t = Ext.Base, i = [], n, r;
    for (n in t) {
        if (t.hasOwnProperty(n)) {
            i.push(n);
        }
    }
    r = i.length;
    Ext.Class = e = function(t, i, n) {
        if (typeof t != "function") {
            n = i;
            i = t;
            t = null;
        }
        if (!i) {
            i = {};
        }
        t = e.create(t);
        e.process(t, i, n);
        return t;
    };
    Ext.apply(e, {
        onBeforeCreated: function(e, t, i) {
            e.addMembers(t);
            i.onCreated.call(e, e);
        },
        create: function(e) {
            var n, s;
            if (!e) {
                e = function() {
                    return this.constructor.apply(this, arguments);
                };
            }
            for (s = 0; s < r; s++) {
                n = i[s];
                e[n] = t[n];
            }
            return e;
        },
        process: function(t, i, n) {
            var r = i.preprocessors || e.defaultPreprocessors, s = this.preprocessors, a = {
                onBeforeCreated: this.onBeforeCreated,
                onCreated: n || Ext.emptyFn
            }, o = 0, l, u, c, f, d, h, g, p;
            delete i.preprocessors;
            p = function(e, t, i) {
                h = null;
                while (h === null) {
                    l = r[o++];
                    if (l) {
                        u = s[l];
                        c = u.properties;
                        if (c === true) {
                            h = u.fn;
                        } else {
                            for (f = 0, d = c.length; f < d; f++) {
                                g = c[f];
                                if (t.hasOwnProperty(g)) {
                                    h = u.fn;
                                    break;
                                }
                            }
                        }
                    } else {
                        i.onBeforeCreated.apply(this, arguments);
                        return;
                    }
                }
                if (h.call(this, e, t, i, p) !== false) {
                    p.apply(this, arguments);
                }
            };
            p.call(this, t, i, a);
        },
        preprocessors: {},
        registerPreprocessor: function(e, t, i, n, r) {
            if (!n) {
                n = "last";
            }
            if (!i) {
                i = [ e ];
            }
            this.preprocessors[e] = {
                name: e,
                properties: i || false,
                fn: t
            };
            this.setDefaultPreprocessorPosition(e, n, r);
            return this;
        },
        getPreprocessor: function(e) {
            return this.preprocessors[e];
        },
        getPreprocessors: function() {
            return this.preprocessors;
        },
        defaultPreprocessors: [],
        getDefaultPreprocessors: function() {
            return this.defaultPreprocessors;
        },
        setDefaultPreprocessors: function(e) {
            this.defaultPreprocessors = Ext.Array.from(e);
            return this;
        },
        setDefaultPreprocessorPosition: function(e, t, i) {
            var n = this.defaultPreprocessors, r;
            if (typeof t == "string") {
                if (t === "first") {
                    n.unshift(e);
                    return this;
                } else if (t === "last") {
                    n.push(e);
                    return this;
                }
                t = t === "after" ? 1 : -1;
            }
            r = Ext.Array.indexOf(n, i);
            if (r !== -1) {
                Ext.Array.splice(n, Math.max(0, r + t), 0, e);
            }
            return this;
        },
        configNameCache: {},
        getConfigNameMap: function(e) {
            var t = this.configNameCache, i = t[e], n;
            if (!i) {
                n = e.charAt(0).toUpperCase() + e.substr(1);
                i = t[e] = {
                    name: e,
                    internal: "_" + e,
                    initializing: "is" + n + "Initializing",
                    apply: "apply" + n,
                    update: "update" + n,
                    set: "set" + n,
                    get: "get" + n,
                    initGet: "initGet" + n,
                    doSet: "doSet" + n,
                    changeEvent: e.toLowerCase() + "change"
                };
            }
            return i;
        },
        generateSetter: function(e) {
            var t = e.internal, i = e.get, n = e.apply, r = e.update, s;
            s = function(e) {
                var s = this[t], a = this[n], o = this[r];
                delete this[i];
                if (a) {
                    e = a.call(this, e, s);
                }
                if (typeof e != "undefined") {
                    this[t] = e;
                    if (o && e !== s) {
                        o.call(this, e, s);
                    }
                }
                return this;
            };
            s.$isDefault = true;
            return s;
        },
        generateInitGetter: function(e) {
            var t = e.name, i = e.set, n = e.get, r = e.initializing;
            return function() {
                this[r] = true;
                delete this[n];
                this[i].call(this, this.config[t]);
                delete this[r];
                return this[n].apply(this, arguments);
            };
        },
        generateGetter: function(e) {
            var t = e.internal;
            return function() {
                return this[t];
            };
        }
    });
    e.registerPreprocessor("extend", function(e, t) {
        var i = Ext.Base, n = t.extend, r;
        delete t.extend;
        if (n && n !== Object) {
            r = n;
        } else {
            r = i;
        }
        e.extend(r);
        e.triggerExtended.apply(e, arguments);
        if (t.onClassExtended) {
            e.onExtended(t.onClassExtended, e);
            delete t.onClassExtended;
        }
    }, true);
    e.registerPreprocessor("statics", function(e, t) {
        e.addStatics(t.statics);
        delete t.statics;
    });
    e.registerPreprocessor("inheritableStatics", function(e, t) {
        e.addInheritableStatics(t.inheritableStatics);
        delete t.inheritableStatics;
    });
    e.registerPreprocessor("config", function(e, t) {
        var i = t.config, n = e.prototype, r = n.config, s, a, o, l, u, c, f;
        delete t.config;
        for (a in i) {
            if (i.hasOwnProperty(a) && !(a in r)) {
                f = i[a];
                s = this.getConfigNameMap(a);
                o = s.set;
                l = s.get;
                u = s.initGet;
                c = s.internal;
                t[u] = this.generateInitGetter(s);
                if (f === null && !t.hasOwnProperty(c)) {
                    t[c] = null;
                }
                if (!t.hasOwnProperty(l)) {
                    t[l] = this.generateGetter(s);
                }
                if (!t.hasOwnProperty(o)) {
                    t[o] = this.generateSetter(s);
                }
            }
        }
        e.addConfig(i, true);
    });
    e.registerPreprocessor("mixins", function(e, t, i) {
        var n = t.mixins, r, s, a, o;
        delete t.mixins;
        Ext.Function.interceptBefore(i, "onCreated", function() {
            if (n instanceof Array) {
                for (a = 0, o = n.length; a < o; a++) {
                    s = n[a];
                    r = s.prototype.mixinId || s.$className;
                    e.mixin(r, s);
                }
            } else {
                for (r in n) {
                    if (n.hasOwnProperty(r)) {
                        e.mixin(r, n[r]);
                    }
                }
            }
        });
    });
    Ext.extend = function(t, i, n) {
        if (arguments.length === 2 && Ext.isObject(i)) {
            n = i;
            i = t;
            t = null;
        }
        var r;
        if (!i) {
            throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.");
        }
        n.extend = i;
        n.preprocessors = [ "extend", "statics", "inheritableStatics", "mixins", "config" ];
        if (t) {
            r = new e(t, n);
        } else {
            r = new e(n);
        }
        r.prototype.override = function(e) {
            for (var t in e) {
                if (e.hasOwnProperty(t)) {
                    this[t] = e[t];
                }
            }
        };
        return r;
    };
})();

(function(e, t, i, n, r) {
    var s = Ext.ClassManager = {
        classes: {},
        existCache: {},
        namespaceRewrites: [ {
            from: "Ext.",
            to: Ext
        } ],
        maps: {
            alternateToName: {},
            aliasToName: {},
            nameToAliases: {},
            nameToAlternates: {}
        },
        enableNamespaceParseCache: true,
        namespaceParseCache: {},
        instantiators: [],
        isCreated: function(e) {
            var t = this.existCache, i, n, s, a, o;
            if (typeof e != "string" || e.length < 1) {
                throw new Error("[Ext.ClassManager] Invalid classname, must be a string and must not be empty");
            }
            if (this.classes[e] || t[e]) {
                return true;
            }
            a = r;
            o = this.parseNamespace(e);
            for (i = 0, n = o.length; i < n; i++) {
                s = o[i];
                if (typeof s != "string") {
                    a = s;
                } else {
                    if (!a || !a[s]) {
                        return false;
                    }
                    a = a[s];
                }
            }
            t[e] = true;
            this.triggerCreated(e);
            return true;
        },
        createdListeners: [],
        nameCreatedListeners: {},
        triggerCreated: function(e) {
            var t = this.createdListeners, i = this.nameCreatedListeners, n = this.maps.nameToAlternates[e], r = [ e ], s, a, o, l, u, c;
            for (s = 0, a = t.length; s < a; s++) {
                u = t[s];
                u.fn.call(u.scope, e);
            }
            if (n) {
                r.push.apply(r, n);
            }
            for (s = 0, a = r.length; s < a; s++) {
                c = r[s];
                t = i[c];
                if (t) {
                    for (o = 0, l = t.length; o < l; o++) {
                        u = t[o];
                        u.fn.call(u.scope, c);
                    }
                    delete i[c];
                }
            }
        },
        onCreated: function(e, t, i) {
            var n = this.createdListeners, r = this.nameCreatedListeners, s = {
                fn: e,
                scope: t
            };
            if (i) {
                if (this.isCreated(i)) {
                    e.call(t, i);
                    return;
                }
                if (!r[i]) {
                    r[i] = [];
                }
                r[i].push(s);
            } else {
                n.push(s);
            }
        },
        parseNamespace: function(e) {
            if (typeof e != "string") {
                throw new Error("[Ext.ClassManager] Invalid namespace, must be a string");
            }
            var t = this.namespaceParseCache;
            if (this.enableNamespaceParseCache) {
                if (t.hasOwnProperty(e)) {
                    return t[e];
                }
            }
            var i = [], n = this.namespaceRewrites, s = r, a = e, o, l, u, c, f;
            for (c = 0, f = n.length; c < f; c++) {
                o = n[c];
                l = o.from;
                u = o.to;
                if (a === l || a.substring(0, l.length) === l) {
                    a = a.substring(l.length);
                    if (typeof u != "string") {
                        s = u;
                    } else {
                        i = i.concat(u.split("."));
                    }
                    break;
                }
            }
            i.push(s);
            i = i.concat(a.split("."));
            if (this.enableNamespaceParseCache) {
                t[e] = i;
            }
            return i;
        },
        setNamespace: function(e, t) {
            var i = r, n = this.parseNamespace(e), s = n.length - 1, a = n[s], o, l;
            for (o = 0; o < s; o++) {
                l = n[o];
                if (typeof l != "string") {
                    i = l;
                } else {
                    if (!i[l]) {
                        i[l] = {};
                    }
                    i = i[l];
                }
            }
            i[a] = t;
            return i[a];
        },
        createNamespaces: function() {
            var e = r, t, i, n, s, a, o;
            for (n = 0, a = arguments.length; n < a; n++) {
                t = this.parseNamespace(arguments[n]);
                for (s = 0, o = t.length; s < o; s++) {
                    i = t[s];
                    if (typeof i != "string") {
                        e = i;
                    } else {
                        if (!e[i]) {
                            e[i] = {};
                        }
                        e = e[i];
                    }
                }
            }
            return e;
        },
        set: function(e, t) {
            var i = this, n = i.maps, r = n.nameToAlternates, s = i.getName(t), a;
            i.classes[e] = i.setNamespace(e, t);
            if (s && s !== e) {
                n.alternateToName[e] = s;
                a = r[s] || (r[s] = []);
                a.push(e);
            }
            return this;
        },
        get: function(e) {
            var t = this.classes;
            if (t[e]) {
                return t[e];
            }
            var i = r, n = this.parseNamespace(e), s, a, o;
            for (a = 0, o = n.length; a < o; a++) {
                s = n[a];
                if (typeof s != "string") {
                    i = s;
                } else {
                    if (!i || !i[s]) {
                        return null;
                    }
                    i = i[s];
                }
            }
            return i;
        },
        setAlias: function(e, t) {
            var i = this.maps.aliasToName, n = this.maps.nameToAliases, r;
            if (typeof e == "string") {
                r = e;
            } else {
                r = this.getName(e);
            }
            if (t && i[t] !== r) {
                if (i[t]) {
                    Ext.Logger.info("[Ext.ClassManager] Overriding existing alias: '" + t + "' " + "of: '" + i[t] + "' with: '" + r + "'. Be sure it's intentional.");
                }
                i[t] = r;
            }
            if (!n[r]) {
                n[r] = [];
            }
            if (t) {
                Ext.Array.include(n[r], t);
            }
            return this;
        },
        addNameAliasMappings: function(e) {
            var t = this.maps.aliasToName, i = this.maps.nameToAliases, n, r, s, a;
            for (n in e) {
                r = i[n] || (i[n] = []);
                for (a = 0; a < e[n].length; a++) {
                    s = e[n][a];
                    if (!t[s]) {
                        t[s] = n;
                        r.push(s);
                    }
                }
            }
            return this;
        },
        addNameAlternateMappings: function(e) {
            var t = this.maps.alternateToName, i = this.maps.nameToAlternates, n, r, s, a;
            for (n in e) {
                r = i[n] || (i[n] = []);
                for (a = 0; a < e[n].length; a++) {
                    s = e[n];
                    if (!t[s]) {
                        t[s] = n;
                        r.push(s);
                    }
                }
            }
            return this;
        },
        getByAlias: function(e) {
            return this.get(this.getNameByAlias(e));
        },
        getNameByAlias: function(e) {
            return this.maps.aliasToName[e] || "";
        },
        getNameByAlternate: function(e) {
            return this.maps.alternateToName[e] || "";
        },
        getAliasesByName: function(e) {
            return this.maps.nameToAliases[e] || [];
        },
        getName: function(e) {
            return e && e.$className || "";
        },
        getClass: function(e) {
            return e && e.self || null;
        },
        create: function(t, i, n) {
            if (typeof t != "string") {
                throw new Error("[Ext.define] Invalid class name '" + t + "' specified, must be a non-empty string");
            }
            i.$className = t;
            return new e(i, function() {
                var e = i.postprocessors || s.defaultPostprocessors, r = s.postprocessors, a = 0, o = [], l, u, c, f, d, h, g, p;
                delete i.postprocessors;
                for (c = 0, f = e.length; c < f; c++) {
                    l = e[c];
                    if (typeof l == "string") {
                        l = r[l];
                        g = l.properties;
                        if (g === true) {
                            o.push(l.fn);
                        } else if (g) {
                            for (d = 0, h = g.length; d < h; d++) {
                                p = g[d];
                                if (i.hasOwnProperty(p)) {
                                    o.push(l.fn);
                                    break;
                                }
                            }
                        }
                    } else {
                        o.push(l);
                    }
                }
                u = function(e, i, r) {
                    l = o[a++];
                    if (!l) {
                        s.set(t, i);
                        if (n) {
                            n.call(i, i);
                        }
                        s.triggerCreated(t);
                        return;
                    }
                    if (l.call(this, e, i, r, u) !== false) {
                        u.apply(this, arguments);
                    }
                };
                u.call(s, t, this, i);
            });
        },
        createOverride: function(e, t) {
            var i = t.override, n = Ext.Array.from(t.requires);
            delete t.override;
            delete t.requires;
            this.existCache[e] = true;
            Ext.require(n, function() {
                this.onCreated(function() {
                    this.get(i).override(t);
                    this.triggerCreated(e);
                }, this, i);
            }, this);
            return this;
        },
        instantiateByAlias: function() {
            var e = arguments[0], t = i.call(arguments), n = this.getNameByAlias(e);
            if (!n) {
                n = this.maps.aliasToName[e];
                if (!n) {
                    throw new Error("[Ext.createByAlias] Cannot create an instance of unrecognized alias: " + e);
                }
                Ext.Logger.warn("[Ext.Loader] Synchronously loading '" + n + "'; consider adding " + "Ext.require('" + e + "') above Ext.onReady");
                Ext.syncRequire(n);
            }
            t[0] = n;
            return this.instantiate.apply(this, t);
        },
        instantiate: function() {
            var e = arguments[0], t = i.call(arguments, 1), n = e, r, s;
            if (typeof e != "function") {
                if (typeof e != "string" || e.length < 1) {
                    throw new Error("[Ext.create] Invalid class name or alias '" + e + "' specified, must be a non-empty string");
                }
                s = this.get(e);
            } else {
                s = e;
            }
            if (!s) {
                r = this.getNameByAlias(e);
                if (r) {
                    e = r;
                    s = this.get(e);
                }
            }
            if (!s) {
                r = this.getNameByAlternate(e);
                if (r) {
                    e = r;
                    s = this.get(e);
                }
            }
            if (!s) {
                Ext.Logger.warn("[Ext.Loader] Synchronously loading '" + e + "'; consider adding '" + (r ? n : e) + "' explicitly as a require of the corresponding class");
                Ext.syncRequire(e);
                s = this.get(e);
            }
            if (!s) {
                throw new Error("[Ext.create] Cannot create an instance of unrecognized class name / alias: " + n);
            }
            if (typeof s != "function") {
                throw new Error("[Ext.create] '" + e + "' is a singleton and cannot be instantiated");
            }
            return this.getInstantiator(t.length)(s, t);
        },
        dynInstantiate: function(e, t) {
            t = n(t, true);
            t.unshift(e);
            return this.instantiate.apply(this, t);
        },
        getInstantiator: function(e) {
            var t = this.instantiators, i;
            i = t[e];
            if (!i) {
                var n = e, r = [];
                for (n = 0; n < e; n++) {
                    r.push("a[" + n + "]");
                }
                i = t[e] = new Function("c", "a", "return new c(" + r.join(",") + ")");
                i.displayName = "Ext.ClassManager.instantiate" + e;
            }
            return i;
        },
        postprocessors: {},
        defaultPostprocessors: [],
        registerPostprocessor: function(e, t, i, n, r) {
            if (!n) {
                n = "last";
            }
            if (!i) {
                i = [ e ];
            }
            this.postprocessors[e] = {
                name: e,
                properties: i || false,
                fn: t
            };
            this.setDefaultPostprocessorPosition(e, n, r);
            return this;
        },
        setDefaultPostprocessors: function(e) {
            this.defaultPostprocessors = n(e);
            return this;
        },
        setDefaultPostprocessorPosition: function(e, t, i) {
            var n = this.defaultPostprocessors, r;
            if (typeof t == "string") {
                if (t === "first") {
                    n.unshift(e);
                    return this;
                } else if (t === "last") {
                    n.push(e);
                    return this;
                }
                t = t === "after" ? 1 : -1;
            }
            r = Ext.Array.indexOf(n, i);
            if (r !== -1) {
                Ext.Array.splice(n, Math.max(0, r + t), 0, e);
            }
            return this;
        },
        getNamesByExpression: function(e) {
            var t = this.maps.nameToAliases, i = [], n, r, s, a, o, l, u;
            if (typeof e != "string" || e.length < 1) {
                throw new Error("[Ext.ClassManager.getNamesByExpression] Expression " + e + " is invalid, must be a non-empty string");
            }
            if (e.indexOf("*") !== -1) {
                e = e.replace(/\*/g, "(.*?)");
                o = new RegExp("^" + e + "$");
                for (n in t) {
                    if (t.hasOwnProperty(n)) {
                        s = t[n];
                        if (n.search(o) !== -1) {
                            i.push(n);
                        } else {
                            for (l = 0, u = s.length; l < u; l++) {
                                r = s[l];
                                if (r.search(o) !== -1) {
                                    i.push(n);
                                    break;
                                }
                            }
                        }
                    }
                }
            } else {
                a = this.getNameByAlias(e);
                if (a) {
                    i.push(a);
                } else {
                    a = this.getNameByAlternate(e);
                    if (a) {
                        i.push(a);
                    } else {
                        i.push(e);
                    }
                }
            }
            return i;
        }
    };
    s.registerPostprocessor("alias", function(e, i, n) {
        var r = n.alias, s, a;
        for (s = 0, a = r.length; s < a; s++) {
            t = r[s];
            this.setAlias(i, t);
        }
    }, [ "xtype", "alias" ]);
    s.registerPostprocessor("singleton", function(e, t, i, n) {
        n.call(this, e, new t(), i);
        return false;
    });
    s.registerPostprocessor("alternateClassName", function(e, t, i) {
        var n = i.alternateClassName, r, s, a;
        if (!(n instanceof Array)) {
            n = [ n ];
        }
        for (r = 0, s = n.length; r < s; r++) {
            a = n[r];
            if (typeof a != "string") {
                throw new Error("[Ext.define] Invalid alternate of: '" + a + "' for class: '" + e + "'; must be a valid string");
            }
            this.set(a, t);
        }
    });
    Ext.apply(Ext, {
        create: t(s, "instantiate"),
        widget: function(e) {
            var t = i.call(arguments);
            t[0] = "widget." + e;
            return s.instantiateByAlias.apply(s, t);
        },
        createByAlias: t(s, "instantiateByAlias"),
        define: function(e, t, i) {
            if ("override" in t) {
                return s.createOverride.apply(s, arguments);
            }
            return s.create.apply(s, arguments);
        },
        getClassName: t(s, "getName"),
        getDisplayName: function(e) {
            if (e) {
                if (e.displayName) {
                    return e.displayName;
                }
                if (e.$name && e.$class) {
                    return Ext.getClassName(e.$class) + "#" + e.$name;
                }
                if (e.$className) {
                    return e.$className;
                }
            }
            return "Anonymous";
        },
        getClass: t(s, "getClass"),
        namespace: t(s, "createNamespaces")
    });
    Ext.createWidget = Ext.widget;
    Ext.ns = Ext.namespace;
    e.registerPreprocessor("className", function(e, t) {
        if (t.$className) {
            e.$className = t.$className;
            e.displayName = e.$className;
        }
    }, true, "first");
    e.registerPreprocessor("alias", function(e, t) {
        var i = e.prototype, r = n(t.xtype), s = n(t.alias), a = "widget.", o = a.length, l = Array.prototype.slice.call(i.xtypesChain || []), u = Ext.merge({}, i.xtypesMap || {}), c, f, d, h;
        for (c = 0, f = s.length; c < f; c++) {
            d = s[c];
            if (typeof d != "string" || d.length < 1) {
                throw new Error("[Ext.define] Invalid alias of: '" + d + "' for class: '" + name + "'; must be a valid string");
            }
            if (d.substring(0, o) === a) {
                h = d.substring(o);
                Ext.Array.include(r, h);
            }
        }
        e.xtype = t.xtype = r[0];
        t.xtypes = r;
        for (c = 0, f = r.length; c < f; c++) {
            h = r[c];
            if (!u[h]) {
                u[h] = true;
                l.push(h);
            }
        }
        t.xtypesChain = l;
        t.xtypesMap = u;
        Ext.Function.interceptAfter(t, "onClassCreated", function() {
            var e = i.mixins, t, n;
            for (t in e) {
                if (e.hasOwnProperty(t)) {
                    n = e[t];
                    r = n.xtypes;
                    if (r) {
                        for (c = 0, f = r.length; c < f; c++) {
                            h = r[c];
                            if (!u[h]) {
                                u[h] = true;
                                l.push(h);
                            }
                        }
                    }
                }
            }
        });
        for (c = 0, f = r.length; c < f; c++) {
            h = r[c];
            if (typeof h != "string" || h.length < 1) {
                throw new Error("[Ext.define] Invalid xtype of: '" + h + "' for class: '" + name + "'; must be a valid non-empty string");
            }
            Ext.Array.include(s, a + h);
        }
        t.alias = s;
    }, [ "xtype", "alias" ]);
})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);

(function(e, t, i, n, r, s, a, o) {
    var l = [ "extend", "mixins", "requires" ], u, c = 0;
    u = Ext.Loader = {
        isInHistory: {},
        history: [],
        config: {
            enabled: true,
            disableCaching: true,
            disableCachingParam: "_dc",
            paths: {
                Ext: "."
            }
        },
        setConfig: function(e, t) {
            if (Ext.isObject(e) && arguments.length === 1) {
                Ext.merge(this.config, e);
            } else {
                this.config[e] = Ext.isObject(t) ? Ext.merge(this.config[e], t) : t;
            }
            c += 1;
            return this;
        },
        getConfig: function(e) {
            if (e) {
                return this.config[e];
            }
            return this.config;
        },
        setPath: i(function(e, t) {
            this.config.paths[e] = t;
            c += 1;
            return this;
        }),
        addClassPathMappings: function(e) {
            var t;
            if (c == 0) {
                u.config.paths = e;
            } else {
                for (t in e) {
                    u.config.paths[t] = e[t];
                }
            }
            c++;
            return u;
        },
        getPath: function(e) {
            var t = "", i = this.config.paths, n = this.getPrefix(e);
            if (n.length > 0) {
                if (n === e) {
                    return i[n];
                }
                t = i[n];
                e = e.substring(n.length + 1);
            }
            if (t.length > 0) {
                t += "/";
            }
            return t.replace(/\/\.\//g, "/") + e.replace(/\./g, "/") + ".js";
        },
        getPrefix: function(e) {
            var t = this.config.paths, i, n = "";
            if (t.hasOwnProperty(e)) {
                return e;
            }
            for (i in t) {
                if (t.hasOwnProperty(i) && i + "." === e.substring(0, i.length + 1)) {
                    if (i.length > n.length) {
                        n = i;
                    }
                }
            }
            return n;
        },
        require: function(e, t, i, n) {
            if (t) {
                t.call(i);
            }
        },
        syncRequire: function() {},
        exclude: function(e) {
            var t = this;
            return {
                require: function(i, n, r) {
                    return t.require(i, n, r, e);
                },
                syncRequire: function(i, n, r) {
                    return t.syncRequire(i, n, r, e);
                }
            };
        },
        onReady: function(e, t, i, n) {
            var r;
            if (i !== false && Ext.onDocumentReady) {
                r = e;
                e = function() {
                    Ext.onDocumentReady(r, t, n);
                };
            }
            e.call(t);
        }
    };
    Ext.apply(u, {
        documentHead: typeof document != "undefined" && (document.head || document.getElementsByTagName("head")[0]),
        isLoading: false,
        queue: [],
        isClassFileLoaded: {},
        isFileLoaded: {},
        readyListeners: [],
        optionalRequires: [],
        requiresMap: {},
        numPendingFiles: 0,
        numLoadedFiles: 0,
        hasFileLoadError: false,
        classNameToFilePathMap: {},
        syncModeEnabled: false,
        scriptElements: {},
        refreshQueue: function() {
            var t = this.queue, i = t.length, n, r, s, o, l;
            if (i === 0) {
                this.triggerReady();
                return;
            }
            for (n = 0; n < i; n++) {
                r = t[n];
                if (r) {
                    o = r.requires;
                    l = r.references;
                    if (o.length > this.numLoadedFiles) {
                        continue;
                    }
                    s = 0;
                    do {
                        if (e.isCreated(o[s])) {
                            a(o, s, 1);
                        } else {
                            s++;
                        }
                    } while (s < o.length);
                    if (r.requires.length === 0) {
                        a(t, n, 1);
                        r.callback.call(r.scope);
                        this.refreshQueue();
                        break;
                    }
                }
            }
            return this;
        },
        injectScriptElement: function(e, t, i, n) {
            var r = document.createElement("script"), s = this, a = function() {
                s.cleanupScriptElement(r);
                t.call(n);
            }, o = function() {
                s.cleanupScriptElement(r);
                i.call(n);
            };
            r.type = "text/javascript";
            r.src = e;
            r.onload = a;
            r.onerror = o;
            r.onreadystatechange = function() {
                if (this.readyState === "loaded" || this.readyState === "complete") {
                    a();
                }
            };
            this.documentHead.appendChild(r);
            return r;
        },
        removeScriptElement: function(e) {
            var t = this.scriptElements;
            if (t[e]) {
                this.cleanupScriptElement(t[e], true);
                delete t[e];
            }
            return this;
        },
        cleanupScriptElement: function(e, t) {
            e.onload = null;
            e.onreadystatechange = null;
            e.onerror = null;
            if (t) {
                this.documentHead.removeChild(e);
            }
            return this;
        },
        loadScriptFile: function(e, t, i, n, r) {
            var s = this, a = this.isFileLoaded, o = this.scriptElements, l = e + (this.getConfig("disableCaching") ? "?" + this.getConfig("disableCachingParam") + "=" + Ext.Date.now() : ""), u, c, f, d;
            if (a[e]) {
                return this;
            }
            n = n || this;
            this.isLoading = true;
            if (!r) {
                d = function() {
                    i.call(n, "Failed loading '" + e + "', please verify that the file exists", r);
                };
                if (!Ext.isReady && Ext.onDocumentReady) {
                    Ext.onDocumentReady(function() {
                        if (!a[e]) {
                            o[e] = s.injectScriptElement(l, t, d, n);
                        }
                    });
                } else {
                    o[e] = this.injectScriptElement(l, t, d, n);
                }
            } else {
                if (typeof XMLHttpRequest != "undefined") {
                    u = new XMLHttpRequest();
                } else {
                    u = new ActiveXObject("Microsoft.XMLHTTP");
                }
                try {
                    u.open("GET", l, false);
                    u.send(null);
                } catch (h) {
                    i.call(this, "Failed loading synchronously via XHR: '" + e + "'; It's likely that the file is either " + "being loaded from a different domain or from the local file system whereby cross origin " + "requests are not allowed due to security reasons. Use asynchronous loading with " + "Ext.require instead.", r);
                }
                c = u.status == 1223 ? 204 : u.status;
                f = u.responseText;
                if (c >= 200 && c < 300 || c == 304 || c == 0 && f.length > 0) {
                    Ext.globalEval(f + "\n//@ sourceURL=" + e);
                    t.call(n);
                } else {
                    i.call(this, "Failed loading synchronously via XHR: '" + e + "'; please " + "verify that the file exists. " + "XHR status code: " + c, r);
                }
                u = null;
            }
        },
        syncRequire: function() {
            var e = this.syncModeEnabled;
            if (!e) {
                this.syncModeEnabled = true;
            }
            this.require.apply(this, arguments);
            if (!e) {
                this.syncModeEnabled = false;
            }
            this.refreshQueue();
        },
        require: function(t, i, n, a) {
            var o = {}, l = {}, u = this.queue, c = this.classNameToFilePathMap, f = this.isClassFileLoaded, d = [], h = [], g = [], p = [], m, x, E, y, v, b, S, C, w, T, I;
            if (a) {
                a = s(a);
                for (C = 0, T = a.length; C < T; C++) {
                    v = a[C];
                    if (typeof v == "string" && v.length > 0) {
                        d = e.getNamesByExpression(v);
                        for (w = 0, I = d.length; w < I; w++) {
                            o[d[w]] = true;
                        }
                    }
                }
            }
            t = s(t);
            if (i) {
                if (i.length > 0) {
                    m = function() {
                        var t = [], n, r, s;
                        for (n = 0, r = p.length; n < r; n++) {
                            s = p[n];
                            t.push(e.get(s));
                        }
                        return i.apply(this, t);
                    };
                } else {
                    m = i;
                }
            } else {
                m = Ext.emptyFn;
            }
            n = n || Ext.global;
            for (C = 0, T = t.length; C < T; C++) {
                y = t[C];
                if (typeof y == "string" && y.length > 0) {
                    h = e.getNamesByExpression(y);
                    I = h.length;
                    for (w = 0; w < I; w++) {
                        S = h[w];
                        if (o[S] !== true) {
                            p.push(S);
                            if (!e.isCreated(S) && !l[S]) {
                                l[S] = true;
                                g.push(S);
                            }
                        }
                    }
                }
            }
            if (g.length > 0) {
                if (!this.config.enabled) {
                    throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. " + "Missing required class" + (g.length > 1 ? "es" : "") + ": " + g.join(", "));
                }
            } else {
                m.call(n);
                return this;
            }
            x = this.syncModeEnabled;
            if (!x) {
                u.push({
                    requires: g.slice(),
                    callback: m,
                    scope: n
                });
            }
            T = g.length;
            for (C = 0; C < T; C++) {
                b = g[C];
                E = this.getPath(b);
                if (x && f.hasOwnProperty(b)) {
                    this.numPendingFiles--;
                    this.removeScriptElement(E);
                    delete f[b];
                }
                if (!f.hasOwnProperty(b)) {
                    f[b] = false;
                    c[b] = E;
                    this.numPendingFiles++;
                    this.loadScriptFile(E, r(this.onFileLoaded, [ b, E ], this), r(this.onFileLoadError, [ b, E ]), this, x);
                }
            }
            if (x) {
                m.call(n);
                if (T === 1) {
                    return e.get(b);
                }
            }
            return this;
        },
        onFileLoaded: function(e, t) {
            this.numLoadedFiles++;
            this.isClassFileLoaded[e] = true;
            this.isFileLoaded[t] = true;
            this.numPendingFiles--;
            if (this.numPendingFiles === 0) {
                this.refreshQueue();
            }
            if (!this.syncModeEnabled && this.numPendingFiles === 0 && this.isLoading && !this.hasFileLoadError) {
                var i = this.queue, n = [], r = [], s, a, o, l, u;
                for (a = 0, o = i.length; a < o; a++) {
                    s = i[a].requires;
                    for (l = 0, u = s.length; l < u; l++) {
                        if (this.isClassFileLoaded[s[l]]) {
                            n.push(s[l]);
                        }
                    }
                }
                if (n.length < 1) {
                    return;
                }
                n = Ext.Array.filter(Ext.Array.unique(n), function(e) {
                    return !this.requiresMap.hasOwnProperty(e);
                }, this);
                for (a = 0, o = n.length; a < o; a++) {
                    r.push(this.classNameToFilePathMap[n[a]]);
                }
                throw new Error("The following classes are not declared even if their files have been " + "loaded: '" + n.join("', '") + "'. Please check the source code of their " + "corresponding files for possible typos: '" + r.join("', '"));
            }
        },
        onFileLoadError: function(e, t, i, n) {
            this.numPendingFiles--;
            this.hasFileLoadError = true;
            throw new Error("[Ext.Loader] " + i);
        },
        addOptionalRequires: function(e) {
            var t = this.optionalRequires, i, n, r;
            e = s(e);
            for (i = 0, n = e.length; i < n; i++) {
                r = e[i];
                o(t, r);
            }
            return this;
        },
        triggerReady: function(e) {
            var t = this.readyListeners, i = this.optionalRequires, n;
            if (this.isLoading || e) {
                this.isLoading = false;
                if (i.length !== 0) {
                    i = i.slice();
                    this.optionalRequires.length = 0;
                    this.require(i, r(this.triggerReady, [ true ], this), this);
                    return this;
                }
                while (t.length) {
                    n = t.shift();
                    n.fn.call(n.scope);
                    if (this.isLoading) {
                        return this;
                    }
                }
            }
            return this;
        },
        onReady: function(e, t, i, n) {
            var r;
            if (i !== false && Ext.onDocumentReady) {
                r = e;
                e = function() {
                    Ext.onDocumentReady(r, t, n);
                };
            }
            if (!this.isLoading) {
                e.call(t);
            } else {
                this.readyListeners.push({
                    fn: e,
                    scope: t
                });
            }
        },
        historyPush: function(e) {
            var t = this.isInHistory;
            if (e && this.isClassFileLoaded.hasOwnProperty(e) && !t[e]) {
                t[e] = true;
                this.history.push(e);
            }
            return this;
        }
    });
    Ext.require = n(u, "require");
    Ext.syncRequire = n(u, "syncRequire");
    Ext.exclude = n(u, "exclude");
    Ext.onReady = function(e, t, i) {
        u.onReady(e, t, true, i);
    };
    t.registerPreprocessor("loader", function(t, i, n, r) {
        var s = this, a = [], o = e.getName(t), c, f, d, h, g, p, m;
        for (c = 0, d = l.length; c < d; c++) {
            p = l[c];
            if (i.hasOwnProperty(p)) {
                m = i[p];
                if (typeof m == "string") {
                    a.push(m);
                } else if (m instanceof Array) {
                    for (f = 0, h = m.length; f < h; f++) {
                        g = m[f];
                        if (typeof g == "string") {
                            a.push(g);
                        }
                    }
                } else if (typeof m != "function") {
                    for (f in m) {
                        if (m.hasOwnProperty(f)) {
                            g = m[f];
                            if (typeof g == "string") {
                                a.push(g);
                            }
                        }
                    }
                }
            }
        }
        if (a.length === 0) {
            return;
        }
        var x = [], E = u.requiresMap, y;
        if (o) {
            E[o] = a;
            if (!u.requiredByMap) u.requiredByMap = {};
            Ext.Array.each(a, function(e) {
                if (!u.requiredByMap[e]) u.requiredByMap[e] = [];
                u.requiredByMap[e].push(o);
            });
            y = function(e) {
                x.push(e);
                if (E[e]) {
                    if (Ext.Array.contains(E[e], o)) {
                        throw new Error("Deadlock detected while loading dependencies! '" + o + "' and '" + x[1] + "' " + "mutually require each other. Path: " + x.join(" -> ") + " -> " + x[0]);
                    }
                    for (c = 0, d = E[e].length; c < d; c++) {
                        y(E[e][c]);
                    }
                }
            };
            y(o);
        }
        u.require(a, function() {
            for (c = 0, d = l.length; c < d; c++) {
                p = l[c];
                if (i.hasOwnProperty(p)) {
                    m = i[p];
                    if (typeof m == "string") {
                        i[p] = e.get(m);
                    } else if (m instanceof Array) {
                        for (f = 0, h = m.length; f < h; f++) {
                            g = m[f];
                            if (typeof g == "string") {
                                i[p][f] = e.get(g);
                            }
                        }
                    } else if (typeof m != "function") {
                        for (var a in m) {
                            if (m.hasOwnProperty(a)) {
                                g = m[a];
                                if (typeof g == "string") {
                                    i[p][a] = e.get(g);
                                }
                            }
                        }
                    }
                }
            }
            r.call(s, t, i, n);
        });
        return false;
    }, true, "after", "className");
    e.registerPostprocessor("uses", function(e, t, i) {
        var n = s(i.uses), r = [], a, o, l;
        for (a = 0, o = n.length; a < o; a++) {
            l = n[a];
            if (typeof l == "string") {
                r.push(l);
            }
        }
        u.addOptionalRequires(r);
    });
    e.onCreated(function(e) {
        this.historyPush(e);
    }, u);
})(Ext.ClassManager, Ext.Class, Ext.Function.flexSetter, Ext.Function.alias, Ext.Function.pass, Ext.Array.from, Ext.Array.erase, Ext.Array.include);

(function() {
    var e = document.getElementsByTagName("script"), t = e[e.length - 1], i = t.src, n = i.substring(0, i.lastIndexOf("/") + 1), r = Ext.Loader;
    if (i.indexOf("src/core/class/") != -1) {
        n = n + "../../../";
    }
    r.setConfig({
        enabled: true,
        disableCaching: !/[?&](cache|breakpoint)/i.test(location.search),
        paths: {
            Ext: n + "src"
        }
    });
})();

Ext.setVersion("touch", "2.1.1");

Ext.apply(Ext, {
    version: Ext.getVersion("touch"),
    idSeed: 0,
    repaint: function() {
        var e = Ext.getBody().createChild({
            cls: Ext.baseCSSPrefix + "mask " + Ext.baseCSSPrefix + "mask-transparent"
        });
        setTimeout(function() {
            e.destroy();
        }, 0);
    },
    id: function(e, t) {
        if (e && e.id) {
            return e.id;
        }
        e = Ext.getDom(e) || {};
        if (e === document || e === document.documentElement) {
            e.id = "ext-application";
        } else if (e === document.body) {
            e.id = "ext-viewport";
        } else if (e === window) {
            e.id = "ext-window";
        }
        e.id = e.id || (t || "ext-element-") + ++Ext.idSeed;
        return e.id;
    },
    getBody: function() {
        if (!Ext.documentBodyElement) {
            if (!document.body) {
                throw new Error("[Ext.getBody] document.body does not exist at this point");
            }
            Ext.documentBodyElement = Ext.get(document.body);
        }
        return Ext.documentBodyElement;
    },
    getHead: function() {
        if (!Ext.documentHeadElement) {
            Ext.documentHeadElement = Ext.get(document.head || document.getElementsByTagName("head")[0]);
        }
        return Ext.documentHeadElement;
    },
    getDoc: function() {
        if (!Ext.documentElement) {
            Ext.documentElement = Ext.get(document);
        }
        return Ext.documentElement;
    },
    getCmp: function(e) {
        return Ext.ComponentMgr.get(e);
    },
    copyTo: function(e, t, i, n) {
        if (typeof i == "string") {
            i = i.split(/[,;\s]/);
        }
        Ext.each(i, function(i) {
            if (n || t.hasOwnProperty(i)) {
                e[i] = t[i];
            }
        }, this);
        return e;
    },
    destroy: function() {
        var e = arguments, t = e.length, i, n;
        for (i = 0; i < t; i++) {
            n = e[i];
            if (n) {
                if (Ext.isArray(n)) {
                    this.destroy.apply(this, n);
                } else if (Ext.isFunction(n.destroy)) {
                    n.destroy();
                }
            }
        }
    },
    getDom: function(e) {
        if (!e || !document) {
            return null;
        }
        return e.dom ? e.dom : typeof e == "string" ? document.getElementById(e) : e;
    },
    removeNode: function(e) {
        if (e && e.parentNode && e.tagName != "BODY") {
            Ext.get(e).clearListeners();
            e.parentNode.removeChild(e);
            delete Ext.cache[e.id];
        }
    },
    defaultSetupConfig: {
        eventPublishers: {
            dom: {
                xclass: "Ext.event.publisher.Dom"
            },
            touchGesture: {
                xclass: "Ext.event.publisher.TouchGesture",
                recognizers: {
                    drag: {
                        xclass: "Ext.event.recognizer.Drag"
                    },
                    tap: {
                        xclass: "Ext.event.recognizer.Tap"
                    },
                    doubleTap: {
                        xclass: "Ext.event.recognizer.DoubleTap"
                    },
                    longPress: {
                        xclass: "Ext.event.recognizer.LongPress"
                    },
                    swipe: {
                        xclass: "Ext.event.recognizer.HorizontalSwipe"
                    },
                    pinch: {
                        xclass: "Ext.event.recognizer.Pinch"
                    },
                    rotate: {
                        xclass: "Ext.event.recognizer.Rotate"
                    }
                }
            },
            componentDelegation: {
                xclass: "Ext.event.publisher.ComponentDelegation"
            },
            componentPaint: {
                xclass: "Ext.event.publisher.ComponentPaint"
            },
            elementPaint: {
                xclass: "Ext.event.publisher.ElementPaint"
            },
            elementSize: {
                xclass: "Ext.event.publisher.ElementSize"
            },
            seriesItemEvents: {
                xclass: "Ext.chart.series.ItemPublisher"
            }
        },
        logger: {
            enabled: true,
            xclass: "Ext.log.Logger",
            minPriority: "deprecate",
            writers: {
                console: {
                    xclass: "Ext.log.writer.Console",
                    throwOnErrors: true,
                    formatter: {
                        xclass: "Ext.log.formatter.Default"
                    }
                }
            }
        },
        animator: {
            xclass: "Ext.fx.Runner"
        },
        viewport: {
            xclass: "Ext.viewport.Viewport"
        }
    },
    isSetup: false,
    frameStartTime: +new Date(),
    setupListeners: [],
    onSetup: function(e, t) {
        if (Ext.isSetup) {
            e.call(t);
        } else {
            Ext.setupListeners.push({
                fn: e,
                scope: t
            });
        }
    },
    setup: function(e) {
        var t = Ext.defaultSetupConfig, i = Ext.emptyFn, n = e.onReady || i, r = e.onUpdated || i, s = e.scope, a = Ext.Array.from(e.requires), o = Ext.onReady, l = Ext.getHead(), u, c, f;
        Ext.setup = function() {
            throw new Error("Ext.setup has already been called before");
        };
        delete e.requires;
        delete e.onReady;
        delete e.onUpdated;
        delete e.scope;
        Ext.require([ "Ext.event.Dispatcher" ]);
        u = function() {
            var e = Ext.setupListeners, t = e.length, i, r;
            delete Ext.setupListeners;
            Ext.isSetup = true;
            for (i = 0; i < t; i++) {
                r = e[i];
                r.fn.call(r.scope);
            }
            Ext.onReady = o;
            Ext.onReady(n, s);
        };
        Ext.onUpdated = r;
        Ext.onReady = function(e, t) {
            var i = n;
            n = function() {
                i();
                Ext.onReady(e, t);
            };
        };
        e = Ext.merge({}, t, e);
        Ext.onDocumentReady(function() {
            Ext.factoryConfig(e, function(e) {
                Ext.event.Dispatcher.getInstance().setPublishers(e.eventPublishers);
                if (e.logger) {
                    Ext.Logger = e.logger;
                }
                if (e.animator) {
                    Ext.Animator = e.animator;
                }
                if (e.viewport) {
                    Ext.Viewport = c = e.viewport;
                    if (!s) {
                        s = c;
                    }
                    Ext.require(a, function() {
                        Ext.Viewport.on("ready", u, null, {
                            single: true
                        });
                    });
                } else {
                    Ext.require(a, u);
                }
            });
        });
        function d(e, t) {
            var i = document.createElement("meta");
            i.setAttribute("name", e);
            i.setAttribute("content", t);
            l.append(i);
        }
        function h(e, t, i) {
            var n = document.createElement("link");
            n.setAttribute("rel", "apple-touch-icon" + (i ? "-precomposed" : ""));
            n.setAttribute("href", e);
            if (t) {
                n.setAttribute("sizes", t);
            }
            l.append(n);
        }
        function g(e, t) {
            var i = document.createElement("link");
            i.setAttribute("rel", "apple-touch-startup-image");
            i.setAttribute("href", e);
            if (t) {
                i.setAttribute("media", t);
            }
            l.append(i);
        }
        var p = e.icon, m = Boolean(e.isIconPrecomposed), x = e.startupImage || {}, E = e.statusBarStyle, y = window.devicePixelRatio || 1;
        if (navigator.standalone) {
            d("viewport", "width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0");
        } else {
            d("viewport", "initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0");
        }
        d("apple-mobile-web-app-capable", "yes");
        d("apple-touch-fullscreen", "yes");
        if (E) {
            d("apple-mobile-web-app-status-bar-style", E);
        }
        if (Ext.isString(p)) {
            p = {
                57: p,
                72: p,
                114: p,
                144: p
            };
        } else if (!p) {
            p = {};
        }
        if (Ext.os.is.iPad) {
            if (y >= 2) {
                if ("1496x2048" in x) {
                    g(x["1496x2048"], "(orientation: landscape)");
                }
                if ("1536x2008" in x) {
                    g(x["1536x2008"], "(orientation: portrait)");
                }
                if ("144" in p) {
                    h(p["144"], "144x144", m);
                }
            } else {
                if ("748x1024" in x) {
                    g(x["748x1024"], "(orientation: landscape)");
                }
                if ("768x1004" in x) {
                    g(x["768x1004"], "(orientation: portrait)");
                }
                if ("72" in p) {
                    h(p["72"], "72x72", m);
                }
            }
        } else {
            if (y >= 2 && Ext.os.version.gtEq("4.3")) {
                if (Ext.os.is.iPhone5) {
                    g(x["640x1096"]);
                } else {
                    g(x["640x920"]);
                }
                if ("114" in p) {
                    h(p["114"], "114x114", m);
                }
            } else {
                g(x["320x460"]);
                if ("57" in p) {
                    h(p["57"], null, m);
                }
            }
        }
    },
    application: function(e) {
        var t = e.name, i, n, r;
        if (!e) {
            e = {};
        }
        if (!Ext.Loader.config.paths[t]) {
            Ext.Loader.setPath(t, e.appFolder || "app");
        }
        r = Ext.Array.from(e.requires);
        e.requires = [ "Ext.app.Application" ];
        i = e.onReady;
        n = e.scope;
        e.onReady = function() {
            e.requires = r;
            new Ext.app.Application(e);
            if (i) {
                i.call(n);
            }
        };
        Ext.setup(e);
    },
    factoryConfig: function(e, t) {
        var i = Ext.isSimpleObject(e);
        if (i && e.xclass) {
            var n = e.xclass;
            delete e.xclass;
            Ext.require(n, function() {
                Ext.factoryConfig(e, function(e) {
                    t(Ext.create(n, e));
                });
            });
            return;
        }
        var r = Ext.isArray(e), s = [], a, o, l, u;
        if (i || r) {
            if (i) {
                for (a in e) {
                    if (e.hasOwnProperty(a)) {
                        o = e[a];
                        if (Ext.isSimpleObject(o) || Ext.isArray(o)) {
                            s.push(a);
                        }
                    }
                }
            } else {
                for (l = 0, u = e.length; l < u; l++) {
                    o = e[l];
                    if (Ext.isSimpleObject(o) || Ext.isArray(o)) {
                        s.push(l);
                    }
                }
            }
            l = 0;
            u = s.length;
            if (u === 0) {
                t(e);
                return;
            }
            function c(t) {
                e[a] = t;
                l++;
                f();
            }
            function f() {
                if (l >= u) {
                    t(e);
                    return;
                }
                a = s[l];
                o = e[a];
                Ext.factoryConfig(o, c);
            }
            f();
            return;
        }
        t(e);
    },
    factory: function(e, t, i, n) {
        var r = Ext.ClassManager, s;
        if (!e || e.isInstance) {
            if (i && i !== e) {
                i.destroy();
            }
            return e;
        }
        if (n) {
            if (typeof e == "string") {
                return r.instantiateByAlias(n + "." + e);
            } else if (Ext.isObject(e) && "type" in e) {
                return r.instantiateByAlias(n + "." + e.type, e);
            }
        }
        if (e === true) {
            return i || r.instantiate(t);
        }
        if (!Ext.isObject(e)) {
            Ext.Logger.error("Invalid config, must be a valid config object");
        }
        if ("xtype" in e) {
            s = r.instantiateByAlias("widget." + e.xtype, e);
        } else if ("xclass" in e) {
            s = r.instantiate(e.xclass, e);
        }
        if (s) {
            if (i) {
                i.destroy();
            }
            return s;
        }
        if (i) {
            return i.setConfig(e);
        }
        return r.instantiate(t, e);
    },
    deprecateClassMember: function(e, t, i, n) {
        return this.deprecateProperty(e.prototype, t, i, n);
    },
    deprecateClassMembers: function(e, t) {
        var i = e.prototype, n, r;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                r = t[n];
                this.deprecateProperty(i, n, r);
            }
        }
    },
    deprecateProperty: function(e, t, i, n) {
        if (!n) {
            n = "'" + t + "' is deprecated";
        }
        if (i) {
            n += ", please use '" + i + "' instead";
        }
        if (i) {
            Ext.Object.defineProperty(e, t, {
                get: function() {
                    Ext.Logger.deprecate(n, 1);
                    return this[i];
                },
                set: function(e) {
                    Ext.Logger.deprecate(n, 1);
                    this[i] = e;
                },
                configurable: true
            });
        }
    },
    deprecatePropertyValue: function(e, t, i, n) {
        Ext.Object.defineProperty(e, t, {
            get: function() {
                Ext.Logger.deprecate(n, 1);
                return i;
            },
            configurable: true
        });
    },
    deprecateMethod: function(e, t, i, n) {
        e[t] = function() {
            Ext.Logger.deprecate(n, 2);
            if (i) {
                return i.apply(this, arguments);
            }
        };
    },
    deprecateClassMethod: function(e, t, i, n) {
        if (typeof t != "string") {
            var r, s;
            for (r in t) {
                if (t.hasOwnProperty(r)) {
                    s = t[r];
                    Ext.deprecateClassMethod(e, r, s);
                }
            }
            return;
        }
        var a = typeof i == "string", o;
        if (!n) {
            n = "'" + t + "()' is deprecated, please use '" + (a ? i : i.name) + "()' instead";
        }
        if (a) {
            o = function() {
                Ext.Logger.deprecate(n, this);
                return this[i].apply(this, arguments);
            };
        } else {
            o = function() {
                Ext.Logger.deprecate(n, this);
                return i.apply(this, arguments);
            };
        }
        if (t in e.prototype) {
            Ext.Object.defineProperty(e.prototype, t, {
                value: null,
                writable: true,
                configurable: true
            });
        }
        e.addMember(t, o);
    },
    showLeaks: function() {
        var e = Ext.ComponentManager.all.map, t = [], i;
        Ext.Object.each(e, function(n, r) {
            while ((i = r.getParent()) && e.hasOwnProperty(i.getId())) {
                r = i;
            }
            if (t.indexOf(r) === -1) {
                t.push(r);
            }
        });
        console.log(t);
    },
    isReady: false,
    readyListeners: [],
    triggerReady: function() {
        var e = Ext.readyListeners, t, i, n;
        if (!Ext.isReady) {
            Ext.isReady = true;
            for (t = 0, i = e.length; t < i; t++) {
                n = e[t];
                n.fn.call(n.scope);
            }
            delete Ext.readyListeners;
        }
    },
    onDocumentReady: function(e, t) {
        if (Ext.isReady) {
            e.call(t);
        } else {
            var i = Ext.triggerReady;
            Ext.readyListeners.push({
                fn: e,
                scope: t
            });
            if (Ext.browser.is.PhoneGap && !Ext.os.is.Desktop) {
                if (!Ext.readyListenerAttached) {
                    Ext.readyListenerAttached = true;
                    document.addEventListener("deviceready", i, false);
                }
            } else {
                if (document.readyState.match(/interactive|complete|loaded/) !== null) {
                    i();
                } else if (!Ext.readyListenerAttached) {
                    Ext.readyListenerAttached = true;
                    window.addEventListener("DOMContentLoaded", i, false);
                }
            }
        }
    },
    callback: function(e, t, i, n) {
        if (Ext.isFunction(e)) {
            i = i || [];
            t = t || window;
            if (n) {
                Ext.defer(e, n, t, i);
            } else {
                e.apply(t, i);
            }
        }
    }
});

Ext.Object.defineProperty(Ext, "Msg", {
    get: function() {
        Ext.Logger.error("Using Ext.Msg without requiring Ext.MessageBox");
        return null;
    },
    set: function(e) {
        Ext.Object.defineProperty(Ext, "Msg", {
            value: e
        });
        return e;
    },
    configurable: true
});

Ext.define("Ext.env.Browser", {
    requires: [ "Ext.Version" ],
    statics: {
        browserNames: {
            ie: "IE",
            firefox: "Firefox",
            safari: "Safari",
            chrome: "Chrome",
            opera: "Opera",
            dolfin: "Dolfin",
            webosbrowser: "webOSBrowser",
            chromeMobile: "ChromeMobile",
            silk: "Silk",
            other: "Other"
        },
        engineNames: {
            webkit: "WebKit",
            gecko: "Gecko",
            presto: "Presto",
            trident: "Trident",
            other: "Other"
        },
        enginePrefixes: {
            webkit: "AppleWebKit/",
            gecko: "Gecko/",
            presto: "Presto/",
            trident: "Trident/"
        },
        browserPrefixes: {
            ie: "MSIE ",
            firefox: "Firefox/",
            chrome: "Chrome/",
            safari: "Version/",
            opera: "Opera/",
            dolfin: "Dolfin/",
            webosbrowser: "wOSBrowser/",
            chromeMobile: "CrMo/",
            silk: "Silk/"
        }
    },
    styleDashPrefixes: {
        WebKit: "-webkit-",
        Gecko: "-moz-",
        Trident: "-ms-",
        Presto: "-o-",
        Other: ""
    },
    stylePrefixes: {
        WebKit: "Webkit",
        Gecko: "Moz",
        Trident: "ms",
        Presto: "O",
        Other: ""
    },
    propertyPrefixes: {
        WebKit: "webkit",
        Gecko: "moz",
        Trident: "ms",
        Presto: "o",
        Other: ""
    },
    is: Ext.emptyFn,
    name: null,
    version: null,
    engineName: null,
    engineVersion: null,
    setFlag: function(e, t) {
        if (typeof t == "undefined") {
            t = true;
        }
        this.is[e] = t;
        this.is[e.toLowerCase()] = t;
        return this;
    },
    constructor: function(e) {
        this.userAgent = e;
        f = this.is = function(e) {
            return f[e] === true;
        };
        var t = this.statics(), i = e.match(new RegExp("((?:" + Ext.Object.getValues(t.browserPrefixes).join(")|(?:") + "))([\\w\\._]+)")), n = e.match(new RegExp("((?:" + Ext.Object.getValues(t.enginePrefixes).join(")|(?:") + "))([\\w\\._]+)")), r = t.browserNames, s = r.other, a = t.engineNames, o = a.other, l = "", u = "", c = false, f, d, h;
        if (i) {
            s = r[Ext.Object.getKey(t.browserPrefixes, i[1])];
            l = new Ext.Version(i[2]);
        }
        if (n) {
            o = a[Ext.Object.getKey(t.enginePrefixes, n[1])];
            u = new Ext.Version(n[2]);
        }
        if (e.match(/FB/) && s == "Other") {
            s = r.safari;
            o = a.webkit;
        }
        if (e.match(/Android.*Chrome/g)) {
            s = "ChromeMobile";
        }
        Ext.apply(this, {
            engineName: o,
            engineVersion: u,
            name: s,
            version: l
        });
        this.setFlag(s);
        if (l) {
            this.setFlag(s + (l.getMajor() || ""));
            this.setFlag(s + l.getShortVersion());
        }
        for (d in r) {
            if (r.hasOwnProperty(d)) {
                h = r[d];
                this.setFlag(h, s === h);
            }
        }
        this.setFlag(h);
        if (u) {
            this.setFlag(o + (u.getMajor() || ""));
            this.setFlag(o + u.getShortVersion());
        }
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                h = a[d];
                this.setFlag(h, o === h);
            }
        }
        this.setFlag("Standalone", !!navigator.standalone);
        if (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined") {
            c = true;
            this.setFlag("PhoneGap");
        } else if (!!window.isNK) {
            c = true;
            this.setFlag("Sencha");
        }
        if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(e)) {
            c = true;
        }
        this.setFlag("WebView", c);
        this.isStrict = document.compatMode == "CSS1Compat";
        this.isSecure = /^https/i.test(window.location.protocol);
        return this;
    },
    getStyleDashPrefix: function() {
        return this.styleDashPrefixes[this.engineName];
    },
    getStylePrefix: function() {
        return this.stylePrefixes[this.engineName];
    },
    getVendorProperyName: function(e) {
        var t = this.propertyPrefixes[this.engineName];
        if (t.length > 0) {
            return t + Ext.String.capitalize(e);
        }
        return e;
    }
}, function() {
    var e = Ext.browser = new this(Ext.global.navigator.userAgent);
});

Ext.define("Ext.env.OS", {
    requires: [ "Ext.Version" ],
    statics: {
        names: {
            ios: "iOS",
            android: "Android",
            webos: "webOS",
            blackberry: "BlackBerry",
            rimTablet: "RIMTablet",
            mac: "MacOS",
            win: "Windows",
            linux: "Linux",
            bada: "Bada",
            other: "Other"
        },
        prefixes: {
            ios: "i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ",
            android: "(Android |HTC_|Silk/)",
            blackberry: "(?:BlackBerry|BB)(?:.*)Version/",
            rimTablet: "RIM Tablet OS ",
            webos: "(?:webOS|hpwOS)/",
            bada: "Bada/"
        }
    },
    is: Ext.emptyFn,
    name: null,
    version: null,
    setFlag: function(e, t) {
        if (typeof t == "undefined") {
            t = true;
        }
        this.is[e] = t;
        this.is[e.toLowerCase()] = t;
        return this;
    },
    constructor: function(e, t) {
        var i = this.statics(), n = i.names, r = i.prefixes, s, a = "", o, l, u, c, f;
        f = this.is = function(e) {
            return this.is[e] === true;
        };
        for (o in r) {
            if (r.hasOwnProperty(o)) {
                l = r[o];
                u = e.match(new RegExp("(?:" + l + ")([^\\s;]+)"));
                if (u) {
                    s = n[o];
                    if (u[1] && (u[1] == "HTC_" || u[1] == "Silk/")) {
                        a = new Ext.Version("2.3");
                    } else {
                        a = new Ext.Version(u[u.length - 1]);
                    }
                    break;
                }
            }
        }
        if (!s) {
            s = n[(e.toLowerCase().match(/mac|win|linux/) || [ "other" ])[0]];
            a = new Ext.Version("");
        }
        this.name = s;
        this.version = a;
        if (t) {
            this.setFlag(t.replace(/ simulator$/i, ""));
        }
        this.setFlag(s);
        if (a) {
            this.setFlag(s + (a.getMajor() || ""));
            this.setFlag(s + a.getShortVersion());
        }
        for (o in n) {
            if (n.hasOwnProperty(o)) {
                c = n[o];
                if (!f.hasOwnProperty(s)) {
                    this.setFlag(c, s === c);
                }
            }
        }
        if (this.name == "iOS" && window.screen.height == 568) {
            this.setFlag("iPhone5");
        }
        return this;
    }
}, function() {
    var e = Ext.global.navigator, t = e.userAgent, i, n, r;
    Ext.os = i = new this(t, e.platform);
    n = i.name;
    var s = window.location.search.match(/deviceType=(Tablet|Phone)/), a = window.deviceType;
    if (s && s[1]) {
        r = s[1];
    } else if (a === "iPhone") {
        r = "Phone";
    } else if (a === "iPad") {
        r = "Tablet";
    } else {
        if (!i.is.Android && !i.is.iOS && /Windows|Linux|MacOS/.test(n)) {
            r = "Desktop";
            Ext.browser.is.WebView = false;
        } else if (i.is.iPad || i.is.RIMTablet || i.is.Android3 || i.is.Android4 && t.search(/mobile/i) == -1) {
            r = "Tablet";
        } else {
            r = "Phone";
        }
    }
    i.setFlag(r, true);
    i.deviceType = r;
});

Ext.define("Ext.env.Feature", {
    requires: [ "Ext.env.Browser", "Ext.env.OS" ],
    constructor: function() {
        this.testElements = {};
        this.has = function(e) {
            return !!this.has[e];
        };
        return this;
    },
    getTestElement: function(e, t) {
        if (e === undefined) {
            e = "div";
        } else if (typeof e !== "string") {
            return e;
        }
        if (t) {
            return document.createElement(e);
        }
        if (!this.testElements[e]) {
            this.testElements[e] = document.createElement(e);
        }
        return this.testElements[e];
    },
    isStyleSupported: function(e, t) {
        var i = this.getTestElement(t).style, n = Ext.String.capitalize(e);
        if (typeof i[e] !== "undefined" || typeof i[Ext.browser.getStylePrefix(e) + n] !== "undefined") {
            return true;
        }
        return false;
    },
    isEventSupported: function(e, t) {
        if (t === undefined) {
            t = window;
        }
        var i = this.getTestElement(t), n = "on" + e.toLowerCase(), r = n in i;
        if (!r) {
            if (i.setAttribute && i.removeAttribute) {
                i.setAttribute(n, "");
                r = typeof i[n] === "function";
                if (typeof i[n] !== "undefined") {
                    i[n] = undefined;
                }
                i.removeAttribute(n);
            }
        }
        return r;
    },
    getSupportedPropertyName: function(e, t) {
        var i = Ext.browser.getVendorProperyName(t);
        if (i in e) {
            return i;
        } else if (t in e) {
            return t;
        }
        return null;
    },
    registerTest: Ext.Function.flexSetter(function(e, t) {
        this.has[e] = t.call(this);
        return this;
    })
}, function() {
    Ext.feature = new this();
    var e = Ext.feature.has;
    Ext.feature.registerTest({
        Canvas: function() {
            var e = this.getTestElement("canvas");
            return !!(e && e.getContext && e.getContext("2d"));
        },
        Svg: function() {
            var e = document;
            return !!(e.createElementNS && !!e.createElementNS("http:/" + "/www.w3.org/2000/svg", "svg").createSVGRect);
        },
        Vml: function() {
            var e = this.getTestElement(), t = false;
            e.innerHTML = "<!--[if vml]><br><![endif]-->";
            t = e.childNodes.length === 1;
            e.innerHTML = "";
            return t;
        },
        Touch: function() {
            return this.isEventSupported("touchstart") && !(Ext.os && Ext.os.name.match(/Windows|MacOS|Linux/) && !Ext.os.is.BlackBerry6);
        },
        Orientation: function() {
            return "orientation" in window && this.isEventSupported("orientationchange");
        },
        OrientationChange: function() {
            return this.isEventSupported("orientationchange");
        },
        DeviceMotion: function() {
            return this.isEventSupported("devicemotion");
        },
        Geolocation: function() {
            return "geolocation" in window.navigator;
        },
        SqlDatabase: function() {
            return "openDatabase" in window;
        },
        WebSockets: function() {
            return "WebSocket" in window;
        },
        Range: function() {
            return !!document.createRange;
        },
        CreateContextualFragment: function() {
            var e = !!document.createRange ? document.createRange() : false;
            return e && !!e.createContextualFragment;
        },
        History: function() {
            return "history" in window && "pushState" in window.history;
        },
        CssTransforms: function() {
            return this.isStyleSupported("transform");
        },
        Css3dTransforms: function() {
            return this.has("CssTransforms") && this.isStyleSupported("perspective") && !Ext.os.is.Android2;
        },
        CssAnimations: function() {
            return this.isStyleSupported("animationName");
        },
        CssTransitions: function() {
            return this.isStyleSupported("transitionProperty");
        },
        Audio: function() {
            return !!this.getTestElement("audio").canPlayType;
        },
        Video: function() {
            return !!this.getTestElement("video").canPlayType;
        },
        ClassList: function() {
            return "classList" in this.getTestElement();
        },
        LocalStorage: function() {
            var e = false;
            try {
                if ("localStorage" in window && window["localStorage"] !== null) {
                    localStorage.setItem("sencha-localstorage-test", "test success");
                    localStorage.removeItem("sencha-localstorage-test");
                    e = true;
                }
            } catch (t) {}
            return e;
        }
    });
});

Ext.define("Ext.dom.Query", {
    select: function(e, t) {
        var i = [], n, r, s, a, o;
        t = t || document;
        if (typeof t == "string") {
            t = document.getElementById(t);
        }
        e = e.split(",");
        for (r = 0, a = e.length; r < a; r++) {
            if (typeof e[r] == "string") {
                if (e[r][0] == "@") {
                    n = t.getAttributeNode(e[r].substring(1));
                    i.push(n);
                } else {
                    n = t.querySelectorAll(e[r]);
                    for (s = 0, o = n.length; s < o; s++) {
                        i.push(n[s]);
                    }
                }
            }
        }
        return i;
    },
    selectNode: function(e, t) {
        return this.select(e, t)[0];
    },
    is: function(e, t) {
        if (typeof e == "string") {
            e = document.getElementById(e);
        }
        return this.select(t).indexOf(e) !== -1;
    },
    isXml: function(e) {
        var t = (e ? e.ownerDocument || e : 0).documentElement;
        return t ? t.nodeName !== "HTML" : false;
    }
}, function() {
    Ext.ns("Ext.core");
    Ext.core.DomQuery = Ext.DomQuery = new this();
    Ext.query = Ext.Function.alias(Ext.DomQuery, "select");
});

Ext.define("Ext.dom.Helper", {
    emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
    confRe: /tag|children|cn|html|tpl|tplData$/i,
    endRe: /end/i,
    attribXlat: {
        cls: "class",
        htmlFor: "for"
    },
    closeTags: {},
    decamelizeName: function() {
        var e = /([a-z])([A-Z])/g, t = {};
        function i(e, t, i) {
            return t + "-" + i.toLowerCase();
        }
        return function(n) {
            return t[n] || (t[n] = n.replace(e, i));
        };
    }(),
    generateMarkup: function(e, t) {
        var i = this, n, r, s, a, o;
        if (typeof e == "string") {
            t.push(e);
        } else if (Ext.isArray(e)) {
            for (a = 0; a < e.length; a++) {
                if (e[a]) {
                    i.generateMarkup(e[a], t);
                }
            }
        } else {
            s = e.tag || "div";
            t.push("<", s);
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    r = e[n];
                    if (!i.confRe.test(n)) {
                        if (typeof r == "object") {
                            t.push(" ", n, '="');
                            i.generateStyles(r, t).push('"');
                        } else {
                            t.push(" ", i.attribXlat[n] || n, '="', r, '"');
                        }
                    }
                }
            }
            if (i.emptyTags.test(s)) {
                t.push("/>");
            } else {
                t.push(">");
                if (r = e.tpl) {
                    r.applyOut(e.tplData, t);
                }
                if (r = e.html) {
                    t.push(r);
                }
                if (r = e.cn || e.children) {
                    i.generateMarkup(r, t);
                }
                o = i.closeTags;
                t.push(o[s] || (o[s] = "</" + s + ">"));
            }
        }
        return t;
    },
    generateStyles: function(e, t) {
        var i = t || [], n;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                i.push(this.decamelizeName(n), ":", e[n], ";");
            }
        }
        return t || i.join("");
    },
    markup: function(e) {
        if (typeof e == "string") {
            return e;
        }
        var t = this.generateMarkup(e, []);
        return t.join("");
    },
    applyStyles: function(e, t) {
        Ext.fly(e).applyStyles(t);
    },
    createContextualFragment: function(e) {
        var t = document.createElement("div"), i = document.createDocumentFragment(), n = 0, r, s;
        t.innerHTML = e;
        s = t.childNodes;
        r = s.length;
        for (;n < r; n++) {
            i.appendChild(s[n].cloneNode(true));
        }
        return i;
    },
    insertHtml: function(e, t, i) {
        var n, r, s, a, o, l;
        e = e.toLowerCase();
        if (Ext.isTextNode(t)) {
            if (e == "afterbegin") {
                e = "beforebegin";
            } else if (e == "beforeend") {
                e = "afterend";
            }
        }
        o = e == "beforebegin";
        l = e == "afterbegin";
        r = Ext.feature.has.CreateContextualFragment ? t.ownerDocument.createRange() : undefined;
        n = "setStart" + (this.endRe.test(e) ? "After" : "Before");
        if (o || e == "afterend") {
            if (r) {
                r[n](t);
                s = r.createContextualFragment(i);
            } else {
                s = this.createContextualFragment(i);
            }
            t.parentNode.insertBefore(s, o ? t : t.nextSibling);
            return t[(o ? "previous" : "next") + "Sibling"];
        } else {
            a = (l ? "first" : "last") + "Child";
            if (t.firstChild) {
                if (r) {
                    r[n](t[a]);
                    s = r.createContextualFragment(i);
                } else {
                    s = this.createContextualFragment(i);
                }
                if (l) {
                    t.insertBefore(s, t.firstChild);
                } else {
                    t.appendChild(s);
                }
            } else {
                t.innerHTML = i;
            }
            return t[a];
        }
    },
    insertBefore: function(e, t, i) {
        return this.doInsert(e, t, i, "beforebegin");
    },
    insertAfter: function(e, t, i) {
        return this.doInsert(e, t, i, "afterend");
    },
    insertFirst: function(e, t, i) {
        return this.doInsert(e, t, i, "afterbegin");
    },
    append: function(e, t, i) {
        return this.doInsert(e, t, i, "beforeend");
    },
    overwrite: function(e, t, i) {
        e = Ext.getDom(e);
        e.innerHTML = this.markup(t);
        return i ? Ext.get(e.firstChild) : e.firstChild;
    },
    doInsert: function(e, t, i, n) {
        var r = this.insertHtml(n, Ext.getDom(e), this.markup(t));
        return i ? Ext.get(r, true) : r;
    },
    createTemplate: function(e) {
        var t = this.markup(e);
        return new Ext.Template(t);
    }
}, function() {
    Ext.ns("Ext.core");
    Ext.core.DomHelper = Ext.DomHelper = new this();
});

Ext.define("Ext.mixin.Identifiable", {
    statics: {
        uniqueIds: {}
    },
    isIdentifiable: true,
    mixinId: "identifiable",
    idCleanRegex: /\.|[^\w\-]/g,
    defaultIdPrefix: "ext-",
    defaultIdSeparator: "-",
    getOptimizedId: function() {
        return this.id;
    },
    getUniqueId: function() {
        var e = this.id, t, i, n, r, s;
        if (!e) {
            t = this.self.prototype;
            i = this.defaultIdSeparator;
            r = Ext.mixin.Identifiable.uniqueIds;
            if (!t.hasOwnProperty("identifiablePrefix")) {
                n = this.xtype;
                if (n) {
                    s = this.defaultIdPrefix + n + i;
                } else {
                    s = t.$className.replace(this.idCleanRegex, i).toLowerCase() + i;
                }
                t.identifiablePrefix = s;
            }
            s = this.identifiablePrefix;
            if (!r.hasOwnProperty(s)) {
                r[s] = 0;
            }
            e = this.id = s + ++r[s];
        }
        this.getUniqueId = this.getOptimizedId;
        return e;
    },
    setId: function(e) {
        this.id = e;
    },
    getId: function() {
        var e = this.id;
        if (!e) {
            e = this.getUniqueId();
        }
        this.getId = this.getOptimizedId;
        return e;
    }
});

Ext.define("Ext.dom.Element", {
    alternateClassName: "Ext.Element",
    mixins: [ "Ext.mixin.Identifiable" ],
    requires: [ "Ext.dom.Query", "Ext.dom.Helper" ],
    observableType: "element",
    xtype: "element",
    statics: {
        CREATE_ATTRIBUTES: {
            style: "style",
            className: "className",
            cls: "cls",
            classList: "classList",
            text: "text",
            hidden: "hidden",
            html: "html",
            children: "children"
        },
        create: function(e, t) {
            var i = this.CREATE_ATTRIBUTES, n, r, s, a, o, l, u;
            if (!e) {
                e = {};
            }
            if (e.isElement) {
                return e.dom;
            } else if ("nodeType" in e) {
                return e;
            }
            if (typeof e == "string") {
                return document.createTextNode(e);
            }
            s = e.tag;
            if (!s) {
                s = "div";
            }
            if (e.namespace) {
                n = document.createElementNS(e.namespace, s);
            } else {
                n = document.createElement(s);
            }
            r = n.style;
            for (o in e) {
                if (o != "tag") {
                    a = e[o];
                    switch (o) {
                      case i.style:
                        if (typeof a == "string") {
                            n.setAttribute(o, a);
                        } else {
                            for (l in a) {
                                if (a.hasOwnProperty(l)) {
                                    r[l] = a[l];
                                }
                            }
                        }
                        break;

                      case i.className:
                      case i.cls:
                        n.className = a;
                        break;

                      case i.classList:
                        n.className = a.join(" ");
                        break;

                      case i.text:
                        n.textContent = a;
                        break;

                      case i.hidden:
                        if (a) {
                            n.style.display = "none";
                        }
                        break;

                      case i.html:
                        n.innerHTML = a;
                        break;

                      case i.children:
                        for (l = 0, u = a.length; l < u; l++) {
                            n.appendChild(this.create(a[l], true));
                        }
                        break;

                      default:
                        n.setAttribute(o, a);
                    }
                }
            }
            if (t) {
                return n;
            } else {
                return this.get(n);
            }
        },
        documentElement: null,
        cache: {},
        get: function(e) {
            var t = this.cache, i, n, r;
            if (!e) {
                return null;
            }
            if (typeof e == "string") {
                if (t.hasOwnProperty(e)) {
                    return t[e];
                }
                if (!(n = document.getElementById(e))) {
                    return null;
                }
                t[e] = i = new this(n);
                return i;
            }
            if ("tagName" in e) {
                r = e.id;
                if (t.hasOwnProperty(r)) {
                    return t[r];
                }
                i = new this(e);
                t[i.getId()] = i;
                return i;
            }
            if (e.isElement) {
                return e;
            }
            if (e.isComposite) {
                return e;
            }
            if (Ext.isArray(e)) {
                return this.select(e);
            }
            if (e === document) {
                if (!this.documentElement) {
                    this.documentElement = new this(document.documentElement);
                    this.documentElement.setId("ext-application");
                }
                return this.documentElement;
            }
            return null;
        },
        data: function(e, t, i) {
            var n = Ext.cache, r, s;
            e = this.get(e);
            if (!e) {
                return null;
            }
            r = e.id;
            s = n[r].data;
            if (!s) {
                n[r].data = s = {};
            }
            if (arguments.length == 2) {
                return s[t];
            } else {
                return s[t] = i;
            }
        }
    },
    isElement: true,
    constructor: function(e) {
        if (typeof e == "string") {
            e = document.getElementById(e);
        }
        if (!e) {
            throw new Error("Invalid domNode reference or an id of an existing domNode: " + e);
        }
        this.dom = e;
        this.getUniqueId();
    },
    attach: function(e) {
        this.dom = e;
        this.id = e.id;
        return this;
    },
    getUniqueId: function() {
        var e = this.id, t;
        if (!e) {
            t = this.dom;
            if (t.id.length > 0) {
                this.id = e = t.id;
            } else {
                t.id = e = this.mixins.identifiable.getUniqueId.call(this);
            }
            this.self.cache[e] = this;
        }
        return e;
    },
    setId: function(e) {
        var t = this.id, i = this.self.cache;
        if (t) {
            delete i[t];
        }
        this.dom.id = e;
        this.id = e;
        i[e] = this;
        return this;
    },
    setHtml: function(e) {
        this.dom.innerHTML = e;
    },
    getHtml: function() {
        return this.dom.innerHTML;
    },
    setText: function(e) {
        this.dom.textContent = e;
    },
    redraw: function() {
        var e = this.dom, t = e.style;
        t.display = "none";
        e.offsetHeight;
        t.display = "";
    },
    isPainted: function() {
        var e = this.dom;
        return Boolean(e && e.offsetParent);
    },
    set: function(e, t) {
        var i = this.dom, n, r;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                r = e[n];
                if (n == "style") {
                    this.applyStyles(r);
                } else if (n == "cls") {
                    i.className = r;
                } else if (t !== false) {
                    if (r === undefined) {
                        i.removeAttribute(n);
                    } else {
                        i.setAttribute(n, r);
                    }
                } else {
                    i[n] = r;
                }
            }
        }
        return this;
    },
    is: function(e) {
        return Ext.DomQuery.is(this.dom, e);
    },
    getValue: function(e) {
        var t = this.dom.value;
        return e ? parseInt(t, 10) : t;
    },
    getAttribute: function(e, t) {
        var i = this.dom;
        return i.getAttributeNS(t, e) || i.getAttribute(t + ":" + e) || i.getAttribute(e) || i[e];
    },
    setSizeState: function(e) {
        var t = [ "x-sized", "x-unsized", "x-stretched" ], i = [ true, false, null ], n = i.indexOf(e), r;
        if (n !== -1) {
            r = t[n];
            t.splice(n, 1);
            this.addCls(r);
        }
        this.removeCls(t);
        return this;
    },
    destroy: function() {
        this.isDestroyed = true;
        var e = Ext.Element.cache, t = this.dom;
        if (t && t.parentNode && t.tagName != "BODY") {
            t.parentNode.removeChild(t);
        }
        delete e[this.id];
        delete this.dom;
    }
}, function(e) {
    Ext.elements = Ext.cache = e.cache;
    this.addStatics({
        Fly: new Ext.Class({
            extend: e,
            constructor: function(e) {
                this.dom = e;
            }
        }),
        _flyweights: {},
        fly: function(t, i) {
            var n = null, r = e._flyweights, s;
            i = i || "_global";
            t = Ext.getDom(t);
            if (t) {
                n = r[i] || (r[i] = new e.Fly());
                n.dom = t;
                n.isSynchronized = false;
                s = Ext.cache[t.id];
                if (s && s.isElement) {
                    s.isSynchronized = false;
                }
            }
            return n;
        }
    });
    Ext.get = function(t) {
        return e.get.call(e, t);
    };
    Ext.fly = function() {
        return e.fly.apply(e, arguments);
    };
    Ext.ClassManager.onCreated(function() {
        e.mixin("observable", Ext.mixin.Observable);
    }, null, "Ext.mixin.Observable");
});

Ext.dom.Element.addStatics({
    numberRe: /\d+$/,
    unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
    camelRe: /(-[a-z])/gi,
    cssRe: /([a-z0-9-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi,
    opacityRe: /alpha\(opacity=(.*)\)/i,
    propertyCache: {},
    defaultUnit: "px",
    borders: {
        l: "border-left-width",
        r: "border-right-width",
        t: "border-top-width",
        b: "border-bottom-width"
    },
    paddings: {
        l: "padding-left",
        r: "padding-right",
        t: "padding-top",
        b: "padding-bottom"
    },
    margins: {
        l: "margin-left",
        r: "margin-right",
        t: "margin-top",
        b: "margin-bottom"
    },
    addUnits: function(e, t) {
        if (e === "" || e == "auto" || e === undefined || e === null) {
            return e || "";
        }
        if (Ext.isNumber(e) || this.numberRe.test(e)) {
            return e + (t || this.defaultUnit || "px");
        } else if (!this.unitRe.test(e)) {
            Ext.Logger.warn("Warning, size detected (" + e + ") not a valid property value on Element.addUnits.");
            return e || "";
        }
        return e;
    },
    isAncestor: function(e, t) {
        var i = false;
        e = Ext.getDom(e);
        t = Ext.getDom(t);
        if (e && t) {
            if (e.contains) {
                return e.contains(t);
            } else if (e.compareDocumentPosition) {
                return !!(e.compareDocumentPosition(t) & 16);
            } else {
                while (t = t.parentNode) {
                    i = t == e || i;
                }
            }
        }
        return i;
    },
    parseBox: function(e) {
        if (typeof e != "string") {
            e = e.toString();
        }
        var t = e.split(" "), i = t.length;
        if (i == 1) {
            t[1] = t[2] = t[3] = t[0];
        } else if (i == 2) {
            t[2] = t[0];
            t[3] = t[1];
        } else if (i == 3) {
            t[3] = t[1];
        }
        return {
            top: t[0] || 0,
            right: t[1] || 0,
            bottom: t[2] || 0,
            left: t[3] || 0
        };
    },
    unitizeBox: function(e, t) {
        var i = this;
        e = i.parseBox(e);
        return i.addUnits(e.top, t) + " " + i.addUnits(e.right, t) + " " + i.addUnits(e.bottom, t) + " " + i.addUnits(e.left, t);
    },
    camelReplaceFn: function(e, t) {
        return t.charAt(1).toUpperCase();
    },
    normalize: function(e) {
        return this.propertyCache[e] || (this.propertyCache[e] = e.replace(this.camelRe, this.camelReplaceFn));
    },
    fromPoint: function(e, t) {
        return Ext.get(document.elementFromPoint(e, t));
    },
    parseStyles: function(e) {
        var t = {}, i = this.cssRe, n;
        if (e) {
            i.lastIndex = 0;
            while (n = i.exec(e)) {
                t[n[1]] = n[2];
            }
        }
        return t;
    }
});

Ext.dom.Element.addMembers({
    appendChild: function(e) {
        this.dom.appendChild(Ext.getDom(e));
        return this;
    },
    removeChild: function(e) {
        this.dom.removeChild(Ext.getDom(e));
        return this;
    },
    append: function() {
        this.appendChild.apply(this, arguments);
    },
    appendTo: function(e) {
        Ext.getDom(e).appendChild(this.dom);
        return this;
    },
    insertBefore: function(e) {
        e = Ext.getDom(e);
        e.parentNode.insertBefore(this.dom, e);
        return this;
    },
    insertAfter: function(e) {
        e = Ext.getDom(e);
        e.parentNode.insertBefore(this.dom, e.nextSibling);
        return this;
    },
    insertFirst: function(e) {
        var t = Ext.getDom(e), i = this.dom, n = i.firstChild;
        if (!n) {
            i.appendChild(t);
        } else {
            i.insertBefore(t, n);
        }
        return this;
    },
    insertSibling: function(e, t, i) {
        var n = this, r, s = (t || "before").toLowerCase() == "after", a;
        if (Ext.isArray(e)) {
            a = n;
            Ext.each(e, function(e) {
                r = Ext.fly(a, "_internal").insertSibling(e, t, i);
                if (s) {
                    a = r;
                }
            });
            return r;
        }
        e = e || {};
        if (e.nodeType || e.dom) {
            r = n.dom.parentNode.insertBefore(Ext.getDom(e), s ? n.dom.nextSibling : n.dom);
            if (!i) {
                r = Ext.get(r);
            }
        } else {
            if (s && !n.dom.nextSibling) {
                r = Ext.core.DomHelper.append(n.dom.parentNode, e, !i);
            } else {
                r = Ext.core.DomHelper[s ? "insertAfter" : "insertBefore"](n.dom, e, !i);
            }
        }
        return r;
    },
    replace: function(e) {
        e = Ext.getDom(e);
        e.parentNode.replaceChild(this.dom, e);
        return this;
    },
    replaceWith: function(e) {
        var t = this;
        if (e.nodeType || e.dom || typeof e == "string") {
            e = Ext.get(e);
            t.dom.parentNode.insertBefore(e, t.dom);
        } else {
            e = Ext.core.DomHelper.insertBefore(t.dom, e);
        }
        delete Ext.cache[t.id];
        Ext.removeNode(t.dom);
        t.id = Ext.id(t.dom = e);
        Ext.dom.Element.addToCache(t.isFlyweight ? new Ext.dom.Element(t.dom) : t);
        return t;
    },
    doReplaceWith: function(e) {
        var t = this.dom;
        t.parentNode.replaceChild(Ext.getDom(e), t);
    },
    createChild: function(e, t, i) {
        e = e || {
            tag: "div"
        };
        if (t) {
            return Ext.core.DomHelper.insertBefore(t, e, i !== true);
        } else {
            return Ext.core.DomHelper[!this.dom.firstChild ? "insertFirst" : "append"](this.dom, e, i !== true);
        }
    },
    wrap: function(e, t) {
        var i = this.dom, n = this.self.create(e, t), r = t ? n : n.dom, s = i.parentNode;
        if (s) {
            s.insertBefore(r, i);
        }
        r.appendChild(i);
        return n;
    },
    wrapAllChildren: function(e) {
        var t = this.dom, i = t.childNodes, n = this.self.create(e), r = n.dom;
        while (i.length > 0) {
            r.appendChild(t.firstChild);
        }
        t.appendChild(r);
        return n;
    },
    unwrapAllChildren: function() {
        var e = this.dom, t = e.childNodes, i = e.parentNode;
        if (i) {
            while (t.length > 0) {
                i.insertBefore(e, e.firstChild);
            }
            this.destroy();
        }
    },
    unwrap: function() {
        var e = this.dom, t = e.parentNode, i;
        if (t) {
            i = t.parentNode;
            i.insertBefore(e, t);
            i.removeChild(t);
        } else {
            i = document.createDocumentFragment();
            i.appendChild(e);
        }
        return this;
    },
    detach: function() {
        var e = this.dom;
        if (e && e.parentNode && e.tagName !== "BODY") {
            e.parentNode.removeChild(e);
        }
        return this;
    },
    insertHtml: function(e, t, i) {
        var n = Ext.core.DomHelper.insertHtml(e, this.dom, t);
        return i ? Ext.get(n) : n;
    }
});

Ext.dom.Element.override({
    getX: function(e) {
        return this.getXY(e)[0];
    },
    getY: function(e) {
        return this.getXY(e)[1];
    },
    getXY: function() {
        var e = this.dom.getBoundingClientRect(), t = Math.round;
        return [ t(e.left + window.pageXOffset), t(e.top + window.pageYOffset) ];
    },
    getOffsetsTo: function(e) {
        var t = this.getXY(), i = Ext.fly(e, "_internal").getXY();
        return [ t[0] - i[0], t[1] - i[1] ];
    },
    setX: function(e) {
        return this.setXY([ e, this.getY() ]);
    },
    setY: function(e) {
        return this.setXY([ this.getX(), e ]);
    },
    setXY: function(e) {
        var t = this;
        if (arguments.length > 1) {
            e = [ e, arguments[1] ];
        }
        var i = t.translatePoints(e), n = t.dom.style;
        for (e in i) {
            if (!i.hasOwnProperty(e)) {
                continue;
            }
            if (!isNaN(i[e])) n[e] = i[e] + "px";
        }
        return t;
    },
    getLeft: function() {
        return parseInt(this.getStyle("left"), 10) || 0;
    },
    getRight: function() {
        return parseInt(this.getStyle("right"), 10) || 0;
    },
    getTop: function() {
        return parseInt(this.getStyle("top"), 10) || 0;
    },
    getBottom: function() {
        return parseInt(this.getStyle("bottom"), 10) || 0;
    },
    translatePoints: function(e, t) {
        t = isNaN(e[1]) ? t : e[1];
        e = isNaN(e[0]) ? e : e[0];
        var i = this, n = i.isStyle("position", "relative"), r = i.getXY(), s = parseInt(i.getStyle("left"), 10), a = parseInt(i.getStyle("top"), 10);
        s = !isNaN(s) ? s : n ? 0 : i.dom.offsetLeft;
        a = !isNaN(a) ? a : n ? 0 : i.dom.offsetTop;
        return {
            left: e - r[0] + s,
            top: t - r[1] + a
        };
    },
    setBox: function(e) {
        var t = this, i = e.width, n = e.height, r = e.top, s = e.left;
        if (s !== undefined) {
            t.setLeft(s);
        }
        if (r !== undefined) {
            t.setTop(r);
        }
        if (i !== undefined) {
            t.setWidth(i);
        }
        if (n !== undefined) {
            t.setHeight(n);
        }
        return this;
    },
    getBox: function(e, t) {
        var i = this, n = i.dom, r = n.offsetWidth, s = n.offsetHeight, a, o, l, u, c, f;
        if (!t) {
            a = i.getXY();
        } else if (e) {
            a = [ 0, 0 ];
        } else {
            a = [ parseInt(i.getStyle("left"), 10) || 0, parseInt(i.getStyle("top"), 10) || 0 ];
        }
        if (!e) {
            o = {
                x: a[0],
                y: a[1],
                0: a[0],
                1: a[1],
                width: r,
                height: s
            };
        } else {
            l = i.getBorderWidth.call(i, "l") + i.getPadding.call(i, "l");
            u = i.getBorderWidth.call(i, "r") + i.getPadding.call(i, "r");
            c = i.getBorderWidth.call(i, "t") + i.getPadding.call(i, "t");
            f = i.getBorderWidth.call(i, "b") + i.getPadding.call(i, "b");
            o = {
                x: a[0] + l,
                y: a[1] + c,
                0: a[0] + l,
                1: a[1] + c,
                width: r - (l + u),
                height: s - (c + f)
            };
        }
        o.left = o.x;
        o.top = o.y;
        o.right = o.x + o.width;
        o.bottom = o.y + o.height;
        return o;
    },
    getPageBox: function(e) {
        var t = this, i = t.dom, n = i.offsetWidth, r = i.offsetHeight, s = t.getXY(), a = s[1], o = s[0] + n, l = s[1] + r, u = s[0];
        if (!i) {
            return new Ext.util.Region();
        }
        if (e) {
            return new Ext.util.Region(a, o, l, u);
        } else {
            return {
                left: u,
                top: a,
                width: n,
                height: r,
                right: o,
                bottom: l
            };
        }
    }
});

Ext.dom.Element.addMembers({
    WIDTH: "width",
    HEIGHT: "height",
    MIN_WIDTH: "min-width",
    MIN_HEIGHT: "min-height",
    MAX_WIDTH: "max-width",
    MAX_HEIGHT: "max-height",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left",
    VISIBILITY: 1,
    DISPLAY: 2,
    OFFSETS: 3,
    SEPARATOR: "-",
    trimRe: /^\s+|\s+$/g,
    wordsRe: /\w/g,
    spacesRe: /\s+/,
    styleSplitRe: /\s*(?::|;)\s*/,
    transparentRe: /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
    classNameSplitRegex: /[\s]+/,
    borders: {
        t: "border-top-width",
        r: "border-right-width",
        b: "border-bottom-width",
        l: "border-left-width"
    },
    paddings: {
        t: "padding-top",
        r: "padding-right",
        b: "padding-bottom",
        l: "padding-left"
    },
    margins: {
        t: "margin-top",
        r: "margin-right",
        b: "margin-bottom",
        l: "margin-left"
    },
    defaultUnit: "px",
    isSynchronized: false,
    synchronize: function() {
        var e = this.dom, t = {}, i = e.className, n, r, s, a;
        if (i.length > 0) {
            n = e.className.split(this.classNameSplitRegex);
            for (r = 0, s = n.length; r < s; r++) {
                a = n[r];
                t[a] = true;
            }
        } else {
            n = [];
        }
        this.classList = n;
        this.hasClassMap = t;
        this.isSynchronized = true;
        return this;
    },
    addCls: function(e, t, i) {
        if (!e) {
            return this;
        }
        if (!this.isSynchronized) {
            this.synchronize();
        }
        var n = this.dom, r = this.hasClassMap, s = this.classList, a = this.SEPARATOR, o, l, u;
        t = t ? t + a : "";
        i = i ? a + i : "";
        if (typeof e == "string") {
            e = e.split(this.spacesRe);
        }
        for (o = 0, l = e.length; o < l; o++) {
            u = t + e[o] + i;
            if (!r[u]) {
                r[u] = true;
                s.push(u);
            }
        }
        n.className = s.join(" ");
        return this;
    },
    removeCls: function(e, t, i) {
        if (!e) {
            return this;
        }
        if (!this.isSynchronized) {
            this.synchronize();
        }
        if (!i) {
            i = "";
        }
        var n = this.dom, r = this.hasClassMap, s = this.classList, a = this.SEPARATOR, o, l, u;
        t = t ? t + a : "";
        i = i ? a + i : "";
        if (typeof e == "string") {
            e = e.split(this.spacesRe);
        }
        for (o = 0, l = e.length; o < l; o++) {
            u = t + e[o] + i;
            if (r[u]) {
                delete r[u];
                Ext.Array.remove(s, u);
            }
        }
        n.className = s.join(" ");
        return this;
    },
    replaceCls: function(e, t, i, n) {
        return this.removeCls(e, i, n).addCls(t, i, n);
    },
    hasCls: function(e) {
        if (!this.isSynchronized) {
            this.synchronize();
        }
        return this.hasClassMap.hasOwnProperty(e);
    },
    toggleCls: function(e, t) {
        if (typeof t !== "boolean") {
            t = !this.hasCls(e);
        }
        return t ? this.addCls(e) : this.removeCls(e);
    },
    swapCls: function(e, t, i, n) {
        if (i === undefined) {
            i = true;
        }
        var r = i ? e : t, s = i ? t : e;
        if (s) {
            this.removeCls(n ? n + "-" + s : s);
        }
        if (r) {
            this.addCls(n ? n + "-" + r : r);
        }
        return this;
    },
    setWidth: function(e) {
        return this.setLengthValue(this.WIDTH, e);
    },
    setHeight: function(e) {
        return this.setLengthValue(this.HEIGHT, e);
    },
    setSize: function(e, t) {
        if (Ext.isObject(e)) {
            t = e.height;
            e = e.width;
        }
        this.setWidth(e);
        this.setHeight(t);
        return this;
    },
    setMinWidth: function(e) {
        return this.setLengthValue(this.MIN_WIDTH, e);
    },
    setMinHeight: function(e) {
        return this.setLengthValue(this.MIN_HEIGHT, e);
    },
    setMaxWidth: function(e) {
        return this.setLengthValue(this.MAX_WIDTH, e);
    },
    setMaxHeight: function(e) {
        return this.setLengthValue(this.MAX_HEIGHT, e);
    },
    setTop: function(e) {
        return this.setLengthValue(this.TOP, e);
    },
    setRight: function(e) {
        return this.setLengthValue(this.RIGHT, e);
    },
    setBottom: function(e) {
        return this.setLengthValue(this.BOTTOM, e);
    },
    setLeft: function(e) {
        return this.setLengthValue(this.LEFT, e);
    },
    setMargin: function(e) {
        var t = this.dom.style;
        if (e || e === 0) {
            e = this.self.unitizeBox(e === true ? 5 : e);
            t.setProperty("margin", e, "important");
        } else {
            t.removeProperty("margin-top");
            t.removeProperty("margin-right");
            t.removeProperty("margin-bottom");
            t.removeProperty("margin-left");
        }
    },
    setPadding: function(e) {
        var t = this.dom.style;
        if (e || e === 0) {
            e = this.self.unitizeBox(e === true ? 5 : e);
            t.setProperty("padding", e, "important");
        } else {
            t.removeProperty("padding-top");
            t.removeProperty("padding-right");
            t.removeProperty("padding-bottom");
            t.removeProperty("padding-left");
        }
    },
    setBorder: function(e) {
        var t = this.dom.style;
        if (e || e === 0) {
            e = this.self.unitizeBox(e === true ? 1 : e);
            t.setProperty("border-width", e, "important");
        } else {
            t.removeProperty("border-top-width");
            t.removeProperty("border-right-width");
            t.removeProperty("border-bottom-width");
            t.removeProperty("border-left-width");
        }
    },
    setLengthValue: function(e, t) {
        var i = this.dom.style;
        if (t === null) {
            i.removeProperty(e);
            return this;
        }
        if (typeof t == "number") {
            t = t + "px";
        }
        i.setProperty(e, t, "important");
        return this;
    },
    setVisible: function(e) {
        var t = this.getVisibilityMode(), i = e ? "removeCls" : "addCls";
        switch (t) {
          case this.VISIBILITY:
            this.removeCls([ "x-hidden-display", "x-hidden-offsets" ]);
            this[i]("x-hidden-visibility");
            break;

          case this.DISPLAY:
            this.removeCls([ "x-hidden-visibility", "x-hidden-offsets" ]);
            this[i]("x-hidden-display");
            break;

          case this.OFFSETS:
            this.removeCls([ "x-hidden-visibility", "x-hidden-display" ]);
            this[i]("x-hidden-offsets");
            break;
        }
        return this;
    },
    getVisibilityMode: function() {
        var e = this.dom, t = Ext.dom.Element.data(e, "visibilityMode");
        if (t === undefined) {
            Ext.dom.Element.data(e, "visibilityMode", t = this.DISPLAY);
        }
        return t;
    },
    setVisibilityMode: function(e) {
        this.self.data(this.dom, "visibilityMode", e);
        return this;
    },
    show: function() {
        var e = this.dom;
        if (e) {
            e.style.removeProperty("display");
        }
    },
    hide: function() {
        this.dom.style.setProperty("display", "none", "important");
    },
    setVisibility: function(e) {
        var t = this.dom.style;
        if (e) {
            t.removeProperty("visibility");
        } else {
            t.setProperty("visibility", "hidden", "important");
        }
    },
    styleHooks: {},
    addStyles: function(e, t) {
        var i = 0, n = e.match(this.wordsRe), r = 0, s = n.length, a, o;
        for (;r < s; r++) {
            a = n[r];
            o = a && parseInt(this.getStyle(t[a]), 10);
            if (o) {
                i += Math.abs(o);
            }
        }
        return i;
    },
    isStyle: function(e, t) {
        return this.getStyle(e) == t;
    },
    getStyleValue: function(e) {
        return this.dom.style.getPropertyValue(e);
    },
    getStyle: function(e) {
        var t = this, i = t.dom, n = t.styleHooks[e], r, s;
        if (i == document) {
            return null;
        }
        if (!n) {
            t.styleHooks[e] = n = {
                name: Ext.dom.Element.normalize(e)
            };
        }
        if (n.get) {
            return n.get(i, t);
        }
        r = window.getComputedStyle(i, "");
        s = r && r[n.name];
        return s;
    },
    setStyle: function(e, t) {
        var i = this, n = i.dom, r = i.styleHooks, s = n.style, a = Ext.valueFrom, o, l;
        if (typeof e == "string") {
            l = r[e];
            if (!l) {
                r[e] = l = {
                    name: Ext.dom.Element.normalize(e)
                };
            }
            t = a(t, "");
            if (l.set) {
                l.set(n, t, i);
            } else {
                s[l.name] = t;
            }
        } else {
            for (o in e) {
                if (e.hasOwnProperty(o)) {
                    l = r[o];
                    if (!l) {
                        r[o] = l = {
                            name: Ext.dom.Element.normalize(o)
                        };
                    }
                    t = a(e[o], "");
                    if (l.set) {
                        l.set(n, t, i);
                    } else {
                        s[l.name] = t;
                    }
                }
            }
        }
        return i;
    },
    getHeight: function(e) {
        var t = this.dom, i = e ? t.clientHeight - this.getPadding("tb") : t.offsetHeight;
        return i > 0 ? i : 0;
    },
    getWidth: function(e) {
        var t = this.dom, i = e ? t.clientWidth - this.getPadding("lr") : t.offsetWidth;
        return i > 0 ? i : 0;
    },
    getBorderWidth: function(e) {
        return this.addStyles(e, this.borders);
    },
    getPadding: function(e) {
        return this.addStyles(e, this.paddings);
    },
    applyStyles: function(e) {
        if (e) {
            var t = this.dom, i, n, r;
            if (typeof e == "function") {
                e = e.call();
            }
            i = typeof e;
            if (i == "string") {
                e = Ext.util.Format.trim(e).split(this.styleSplitRe);
                for (n = 0, r = e.length; n < r; ) {
                    t.style[Ext.dom.Element.normalize(e[n++])] = e[n++];
                }
            } else if (i == "object") {
                this.setStyle(e);
            }
        }
    },
    getSize: function(e) {
        var t = this.dom;
        return {
            width: Math.max(0, e ? t.clientWidth - this.getPadding("lr") : t.offsetWidth),
            height: Math.max(0, e ? t.clientHeight - this.getPadding("tb") : t.offsetHeight)
        };
    },
    repaint: function() {
        var e = this.dom;
        this.addCls(Ext.baseCSSPrefix + "repaint");
        setTimeout(function() {
            Ext.fly(e).removeCls(Ext.baseCSSPrefix + "repaint");
        }, 1);
        return this;
    },
    getMargin: function(e) {
        var t = this, i = {
            t: "top",
            l: "left",
            r: "right",
            b: "bottom"
        }, n = {}, r;
        if (!e) {
            for (r in t.margins) {
                n[i[r]] = parseFloat(t.getStyle(t.margins[r])) || 0;
            }
            return n;
        } else {
            return t.addStyles.call(t, e, t.margins);
        }
    }
});

Ext.dom.Element.addMembers({
    getParent: function() {
        return Ext.get(this.dom.parentNode);
    },
    getFirstChild: function() {
        return Ext.get(this.dom.firstElementChild);
    },
    contains: function(e) {
        if (!e) {
            return false;
        }
        var t = Ext.getDom(e);
        return t === this.dom || this.self.isAncestor(this.dom, t);
    },
    findParent: function(e, t, i) {
        var n = this.dom, r = document.body, s = 0, a;
        t = t || 50;
        if (isNaN(t)) {
            a = Ext.getDom(t);
            t = Number.MAX_VALUE;
        }
        while (n && n.nodeType == 1 && s < t && n != r && n != a) {
            if (Ext.DomQuery.is(n, e)) {
                return i ? Ext.get(n) : n;
            }
            s++;
            n = n.parentNode;
        }
        return null;
    },
    findParentNode: function(e, t, i) {
        var n = Ext.fly(this.dom.parentNode, "_internal");
        return n ? n.findParent(e, t, i) : null;
    },
    up: function(e, t) {
        return this.findParentNode(e, t, true);
    },
    select: function(e, t) {
        return Ext.dom.Element.select(e, this.dom, t);
    },
    query: function(e) {
        return Ext.DomQuery.select(e, this.dom);
    },
    down: function(e, t) {
        var i = Ext.DomQuery.selectNode(e, this.dom);
        return t ? i : Ext.get(i);
    },
    child: function(e, t) {
        var i, n = this, r;
        r = Ext.get(n).id;
        r = r.replace(/[\.:]/g, "\\$0");
        i = Ext.DomQuery.selectNode("#" + r + " > " + e, n.dom);
        return t ? i : Ext.get(i);
    },
    parent: function(e, t) {
        return this.matchNode("parentNode", "parentNode", e, t);
    },
    next: function(e, t) {
        return this.matchNode("nextSibling", "nextSibling", e, t);
    },
    prev: function(e, t) {
        return this.matchNode("previousSibling", "previousSibling", e, t);
    },
    first: function(e, t) {
        return this.matchNode("nextSibling", "firstChild", e, t);
    },
    last: function(e, t) {
        return this.matchNode("previousSibling", "lastChild", e, t);
    },
    matchNode: function(e, t, i, n) {
        if (!this.dom) {
            return null;
        }
        var r = this.dom[t];
        while (r) {
            if (r.nodeType == 1 && (!i || Ext.DomQuery.is(r, i))) {
                return !n ? Ext.get(r) : r;
            }
            r = r[e];
        }
        return null;
    },
    isAncestor: function(e) {
        return this.self.isAncestor.call(this.self, this.dom, e);
    }
});

Ext.define("Ext.dom.CompositeElementLite", {
    alternateClassName: [ "Ext.CompositeElementLite", "Ext.CompositeElement" ],
    requires: [ "Ext.dom.Element" ],
    statics: {
        importElementMethods: function() {}
    },
    constructor: function(e, t) {
        this.elements = [];
        this.add(e, t);
        this.el = new Ext.dom.Element.Fly();
    },
    isComposite: true,
    getElement: function(e) {
        return this.el.attach(e).synchronize();
    },
    transformElement: function(e) {
        return Ext.getDom(e);
    },
    getCount: function() {
        return this.elements.length;
    },
    add: function(e, t) {
        var i = this.elements, n, r;
        if (!e) {
            return this;
        }
        if (typeof e == "string") {
            e = Ext.dom.Element.selectorFunction(e, t);
        } else if (e.isComposite) {
            e = e.elements;
        } else if (!Ext.isIterable(e)) {
            e = [ e ];
        }
        for (n = 0, r = e.length; n < r; ++n) {
            i.push(this.transformElement(e[n]));
        }
        return this;
    },
    invoke: function(e, t) {
        var i = this.elements, n = i.length, r, s;
        for (s = 0; s < n; s++) {
            r = i[s];
            if (r) {
                Ext.dom.Element.prototype[e].apply(this.getElement(r), t);
            }
        }
        return this;
    },
    item: function(e) {
        var t = this.elements[e], i = null;
        if (t) {
            i = this.getElement(t);
        }
        return i;
    },
    addListener: function(e, t, i, n) {
        var r = this.elements, s = r.length, a, o;
        for (a = 0; a < s; a++) {
            o = r[a];
            if (o) {
                o.on(e, t, i || o, n);
            }
        }
        return this;
    },
    each: function(e, t) {
        var i = this, n = i.elements, r = n.length, s, a;
        for (s = 0; s < r; s++) {
            a = n[s];
            if (a) {
                a = this.getElement(a);
                if (e.call(t || a, a, i, s) === false) {
                    break;
                }
            }
        }
        return i;
    },
    fill: function(e) {
        var t = this;
        t.elements = [];
        t.add(e);
        return t;
    },
    filter: function(e) {
        var t = [], i = this, n = Ext.isFunction(e) ? e : function(t) {
            return t.is(e);
        };
        i.each(function(e, r, s) {
            if (n(e, s) !== false) {
                t[t.length] = i.transformElement(e);
            }
        });
        i.elements = t;
        return i;
    },
    indexOf: function(e) {
        return Ext.Array.indexOf(this.elements, this.transformElement(e));
    },
    replaceElement: function(e, t, i) {
        var n = !isNaN(e) ? e : this.indexOf(e), r;
        if (n > -1) {
            t = Ext.getDom(t);
            if (i) {
                r = this.elements[n];
                r.parentNode.insertBefore(t, r);
                Ext.removeNode(r);
            }
            Ext.Array.splice(this.elements, n, 1, t);
        }
        return this;
    },
    clear: function() {
        this.elements = [];
    },
    addElements: function(e, t) {
        if (!e) {
            return this;
        }
        if (typeof e == "string") {
            e = Ext.dom.Element.selectorFunction(e, t);
        }
        var i = this.elements;
        Ext.each(e, function(e) {
            i.push(Ext.get(e));
        });
        return this;
    },
    first: function() {
        return this.item(0);
    },
    last: function() {
        return this.item(this.getCount() - 1);
    },
    contains: function(e) {
        return this.indexOf(e) != -1;
    },
    removeElement: function(e, t) {
        var i = this, n = this.elements, r;
        Ext.each(e, function(e) {
            if (r = n[e] || n[e = i.indexOf(e)]) {
                if (t) {
                    if (r.dom) {
                        r.remove();
                    } else {
                        Ext.removeNode(r);
                    }
                }
                Ext.Array.erase(n, e, 1);
            }
        });
        return this;
    }
}, function() {
    var e = Ext.dom.Element, t = e.prototype, i = this.prototype, n;
    for (n in t) {
        if (typeof t[n] == "function") {
            (function(e) {
                i[e] = i[e] || function() {
                    return this.invoke(e, arguments);
                };
            }).call(i, n);
        }
    }
    i.on = i.addListener;
    if (Ext.DomQuery) {
        e.selectorFunction = Ext.DomQuery.select;
    }
    e.select = function(t, i) {
        var n;
        if (typeof t == "string") {
            n = e.selectorFunction(t, i);
        } else if (t.length !== undefined) {
            n = t;
        } else {
            throw new Error("[Ext.select] Invalid selector specified: " + t);
        }
        return new Ext.CompositeElementLite(n);
    };
    Ext.select = function() {
        return e.select.apply(e, arguments);
    };
});

Ext.ClassManager.addNameAlternateMappings({
    "Ext.app.Profile": [],
    "Ext.event.recognizer.MultiTouch": [],
    "Ext.fx.Runner": [],
    "Ext.chart.grid.CircularGrid": [],
    "Ext.mixin.Templatable": [],
    "Ext.event.recognizer.Pinch": [],
    "Ext.util.Format": [],
    "Ext.direct.JsonProvider": [],
    "Ext.data.identifier.Simple": [],
    "Ext.dataview.DataView": [ "Ext.DataView" ],
    "Ext.field.Hidden": [ "Ext.form.Hidden" ],
    "Ext.field.Number": [ "Ext.form.Number" ],
    "Ext.chart.series.CandleStick": [],
    "Ext.device.Connection": [],
    "Ext.data.Model": [ "Ext.data.Record" ],
    "Ext.data.reader.Reader": [ "Ext.data.Reader", "Ext.data.DataReader" ],
    "Ext.Sheet": [],
    "Ext.tab.Tab": [ "Ext.Tab" ],
    "Ext.chart.series.sprite.StackedCartesian": [],
    "Ext.util.Grouper": [],
    "Ext.util.translatable.CssPosition": [],
    "Ext.util.paintmonitor.Abstract": [],
    "Ext.direct.RemotingProvider": [],
    "Ext.data.NodeInterface": [ "Ext.data.Node" ],
    "Ext.chart.interactions.PanZoom": [],
    "Ext.util.PositionMap": [],
    "Ext.chart.series.ItemPublisher": [],
    "Ext.util.Sortable": [],
    "Ext.chart.series.sprite.AbstractRadial": [],
    "Ext.fx.runner.Css": [],
    "Ext.fx.runner.CssTransition": [],
    "Ext.draw.Group": [],
    "Ext.XTemplateCompiler": [],
    "Ext.util.Wrapper": [],
    "Ext.app.Router": [],
    "Ext.direct.Transaction": [ "Ext.Direct.Transaction" ],
    "Ext.util.Offset": [],
    "Ext.device.device.Abstract": [],
    "Ext.mixin.Mixin": [],
    "Ext.fx.animation.FadeOut": [],
    "Ext.util.Geolocation": [ "Ext.util.GeoLocation" ],
    "Ext.ComponentManager": [ "Ext.ComponentMgr" ],
    "Ext.util.sizemonitor.OverflowChange": [],
    "Ext.event.publisher.ElementSize": [],
    "Ext.tab.Bar": [ "Ext.TabBar" ],
    "Ext.event.Dom": [],
    "Ext.app.Application": [],
    "Ext.dataview.List": [ "Ext.List" ],
    "Ext.util.translatable.Dom": [],
    "Ext.fx.layout.card.Scroll": [],
    "Ext.draw.LimitedCache": [],
    "Ext.device.geolocation.Sencha": [],
    "Ext.dataview.ListItemHeader": [],
    "Ext.event.publisher.TouchGesture": [],
    "Ext.data.SortTypes": [],
    "Ext.device.contacts.Abstract": [],
    "Ext.device.push.Sencha": [],
    "Ext.fx.animation.WipeOut": [],
    "Ext.slider.Slider": [],
    "Ext.Component": [ "Ext.lib.Component" ],
    "Ext.device.communicator.Default": [],
    "Ext.fx.runner.CssAnimation": [],
    "Ext.chart.axis.Axis": [],
    "Ext.fx.animation.Cube": [],
    "Ext.chart.Markers": [],
    "Ext.chart.series.sprite.Radar": [],
    "Ext.device.device.Simulator": [],
    "Ext.Ajax": [],
    "Ext.dataview.component.ListItem": [],
    "Ext.util.Filter": [],
    "Ext.layout.wrapper.Inner": [],
    "Ext.draw.Animator": [],
    "Ext.device.geolocation.Simulator": [],
    "Ext.data.association.BelongsTo": [ "Ext.data.BelongsToAssociation" ],
    "Ext.draw.Surface": [],
    "Ext.scroll.indicator.ScrollPosition": [],
    "Ext.field.Email": [ "Ext.form.Email" ],
    "Ext.fx.layout.card.Abstract": [],
    "Ext.event.Controller": [],
    "Ext.dataview.component.Container": [],
    "Ext.log.writer.Remote": [],
    "Ext.fx.layout.card.Style": [],
    "Ext.device.purchases.Sencha": [],
    "Ext.chart.axis.segmenter.Segmenter": [],
    "Ext.viewport.Android": [],
    "Ext.log.formatter.Identity": [],
    "Ext.chart.interactions.ItemHighlight": [],
    "Ext.picker.Picker": [ "Ext.Picker" ],
    "Ext.data.Batch": [],
    "Ext.draw.modifier.Animation": [],
    "Ext.chart.AbstractChart": [],
    "Ext.field.File": [],
    "Ext.tab.Panel": [ "Ext.TabPanel" ],
    "Ext.draw.Path": [],
    "Ext.scroll.indicator.Throttled": [],
    "Ext.fx.animation.SlideOut": [],
    "Ext.device.connection.Sencha": [],
    "Ext.fx.layout.card.Pop": [],
    "Ext.chart.axis.layout.Discrete": [],
    "Ext.data.Field": [],
    "Ext.chart.series.Gauge": [],
    "Ext.data.StoreManager": [ "Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager" ],
    "Ext.fx.animation.PopOut": [],
    "Ext.chart.label.Callout": [],
    "Ext.device.push.Abstract": [],
    "Ext.util.DelayedTask": [],
    "Ext.fx.easing.Momentum": [],
    "Ext.fx.easing.Abstract": [],
    "Ext.Title": [],
    "Ext.event.recognizer.Drag": [],
    "Ext.field.TextArea": [ "Ext.form.TextArea" ],
    "Ext.fx.Easing": [],
    "Ext.chart.series.sprite.Scatter": [],
    "Ext.data.reader.Array": [ "Ext.data.ArrayReader" ],
    "Ext.picker.Date": [ "Ext.DatePicker" ],
    "Ext.data.proxy.JsonP": [ "Ext.data.ScriptTagProxy" ],
    "Ext.device.communicator.Android": [],
    "Ext.chart.series.Area": [],
    "Ext.device.device.PhoneGap": [],
    "Ext.field.Checkbox": [ "Ext.form.Checkbox" ],
    "Ext.chart.Legend": [],
    "Ext.Media": [],
    "Ext.TitleBar": [],
    "Ext.chart.interactions.RotatePie3D": [],
    "Ext.draw.gradient.Linear": [],
    "Ext.util.TapRepeater": [],
    "Ext.event.Touch": [],
    "Ext.mixin.Bindable": [],
    "Ext.data.proxy.Server": [ "Ext.data.ServerProxy" ],
    "Ext.chart.series.Cartesian": [],
    "Ext.util.sizemonitor.Scroll": [],
    "Ext.data.ResultSet": [],
    "Ext.data.association.HasMany": [ "Ext.data.HasManyAssociation" ],
    "Ext.draw.TimingFunctions": [],
    "Ext.draw.engine.Canvas": [],
    "Ext.data.proxy.Ajax": [ "Ext.data.HttpProxy", "Ext.data.AjaxProxy" ],
    "Ext.fx.animation.Fade": [ "Ext.fx.animation.FadeIn" ],
    "Ext.layout.Default": [],
    "Ext.util.paintmonitor.CssAnimation": [],
    "Ext.data.writer.Writer": [ "Ext.data.DataWriter", "Ext.data.Writer" ],
    "Ext.event.recognizer.Recognizer": [],
    "Ext.form.FieldSet": [],
    "Ext.scroll.Indicator": [ "Ext.util.Indicator" ],
    "Ext.XTemplateParser": [],
    "Ext.behavior.Scrollable": [],
    "Ext.chart.series.sprite.CandleStick": [],
    "Ext.data.JsonP": [ "Ext.util.JSONP" ],
    "Ext.device.connection.PhoneGap": [],
    "Ext.event.publisher.Dom": [],
    "Ext.fx.layout.card.Fade": [],
    "Ext.app.Controller": [],
    "Ext.fx.State": [],
    "Ext.layout.wrapper.BoxDock": [],
    "Ext.chart.series.sprite.Pie3DPart": [],
    "Ext.viewport.Default": [],
    "Ext.layout.HBox": [],
    "Ext.scroll.indicator.Default": [],
    "Ext.data.ModelManager": [ "Ext.ModelMgr", "Ext.ModelManager" ],
    "Ext.data.Validations": [ "Ext.data.validations" ],
    "Ext.util.translatable.Abstract": [],
    "Ext.scroll.indicator.Abstract": [],
    "Ext.Button": [],
    "Ext.field.Radio": [ "Ext.form.Radio" ],
    "Ext.util.HashMap": [],
    "Ext.field.Input": [],
    "Ext.device.Camera": [],
    "Ext.mixin.Filterable": [],
    "Ext.draw.TextMeasurer": [],
    "Ext.dataview.element.Container": [],
    "Ext.chart.series.sprite.PieSlice": [],
    "Ext.data.Connection": [],
    "Ext.direct.ExceptionEvent": [],
    "Ext.Panel": [ "Ext.lib.Panel" ],
    "Ext.data.association.HasOne": [ "Ext.data.HasOneAssociation" ],
    "Ext.device.geolocation.Abstract": [],
    "Ext.ActionSheet": [],
    "Ext.layout.Box": [],
    "Ext.bb.CrossCut": [],
    "Ext.Video": [],
    "Ext.chart.series.Line": [],
    "Ext.fx.layout.card.Cube": [],
    "Ext.event.recognizer.HorizontalSwipe": [],
    "Ext.data.writer.Json": [ "Ext.data.JsonWriter" ],
    "Ext.layout.Fit": [],
    "Ext.fx.animation.Slide": [ "Ext.fx.animation.SlideIn" ],
    "Ext.device.Purchases.Purchase": [],
    "Ext.table.Row": [],
    "Ext.log.formatter.Formatter": [],
    "Ext.Container": [ "Ext.lib.Container" ],
    "Ext.fx.animation.Pop": [ "Ext.fx.animation.PopIn" ],
    "Ext.draw.sprite.Circle": [],
    "Ext.fx.layout.card.Reveal": [],
    "Ext.fx.layout.card.Cover": [],
    "Ext.log.Base": [],
    "Ext.data.reader.Xml": [ "Ext.data.XmlReader" ],
    "Ext.event.publisher.ElementPaint": [],
    "Ext.chart.axis.Category": [],
    "Ext.data.reader.Json": [ "Ext.data.JsonReader" ],
    "Ext.Decorator": [],
    "Ext.data.TreeStore": [],
    "Ext.device.Purchases": [],
    "Ext.device.orientation.HTML5": [],
    "Ext.draw.gradient.Gradient": [],
    "Ext.event.recognizer.DoubleTap": [],
    "Ext.log.Logger": [],
    "Ext.picker.Slot": [ "Ext.Picker.Slot" ],
    "Ext.device.notification.Simulator": [],
    "Ext.field.Field": [ "Ext.form.Field" ],
    "Ext.log.filter.Priority": [],
    "Ext.util.sizemonitor.Abstract": [],
    "Ext.chart.series.sprite.Polar": [],
    "Ext.util.paintmonitor.OverflowChange": [],
    "Ext.util.LineSegment": [],
    "Ext.SegmentedButton": [],
    "Ext.Sortable": [],
    "Ext.fx.easing.Linear": [],
    "Ext.chart.series.sprite.Aggregative": [],
    "Ext.dom.CompositeElement": [ "Ext.CompositeElement" ],
    "Ext.data.identifier.Uuid": [],
    "Ext.data.proxy.Client": [ "Ext.proxy.ClientProxy" ],
    "Ext.fx.easing.Bounce": [],
    "Ext.data.Types": [],
    "Ext.chart.series.sprite.Cartesian": [],
    "Ext.app.Action": [],
    "Ext.util.Translatable": [],
    "Ext.device.camera.PhoneGap": [],
    "Ext.draw.sprite.Path": [],
    "Ext.LoadMask": [],
    "Ext.data.association.Association": [ "Ext.data.Association" ],
    "Ext.chart.axis.sprite.Axis": [],
    "Ext.behavior.Draggable": [],
    "Ext.chart.grid.RadialGrid": [],
    "Ext.util.TranslatableGroup": [],
    "Ext.fx.Animation": [],
    "Ext.draw.sprite.Ellipse": [],
    "Ext.util.Inflector": [],
    "Ext.Map": [],
    "Ext.XTemplate": [],
    "Ext.data.NodeStore": [],
    "Ext.draw.sprite.AttributeParser": [],
    "Ext.form.Panel": [ "Ext.form.FormPanel" ],
    "Ext.chart.series.Series": [],
    "Ext.data.Request": [],
    "Ext.draw.sprite.Text": [],
    "Ext.layout.Float": [],
    "Ext.dataview.component.DataItem": [],
    "Ext.chart.CartesianChart": [ "Ext.chart.Chart" ],
    "Ext.data.proxy.WebStorage": [ "Ext.data.WebStorageProxy" ],
    "Ext.log.writer.Writer": [],
    "Ext.device.Communicator": [],
    "Ext.fx.animation.Flip": [],
    "Ext.util.Point": [],
    "Ext.chart.series.StackedCartesian": [],
    "Ext.fx.layout.card.Slide": [],
    "Ext.Anim": [],
    "Ext.data.DirectStore": [],
    "Ext.dataview.NestedList": [ "Ext.NestedList" ],
    "Ext.app.Route": [],
    "Ext.device.connection.Simulator": [],
    "Ext.chart.PolarChart": [],
    "Ext.event.publisher.ComponentSize": [],
    "Ext.slider.Toggle": [],
    "Ext.data.identifier.Sequential": [],
    "Ext.Template": [],
    "Ext.AbstractComponent": [],
    "Ext.device.Push": [],
    "Ext.fx.easing.BoundMomentum": [],
    "Ext.viewport.Viewport": [],
    "Ext.chart.series.Polar": [],
    "Ext.event.recognizer.VerticalSwipe": [],
    "Ext.event.Event": [ "Ext.EventObject" ],
    "Ext.behavior.Behavior": [],
    "Ext.chart.grid.VerticalGrid": [],
    "Ext.chart.label.Label": [],
    "Ext.draw.sprite.EllipticalArc": [],
    "Ext.fx.easing.EaseOut": [],
    "Ext.Toolbar": [],
    "Ext.event.recognizer.LongPress": [],
    "Ext.device.notification.Sencha": [],
    "Ext.chart.series.sprite.Line": [],
    "Ext.data.ArrayStore": [],
    "Ext.mixin.Sortable": [],
    "Ext.fx.layout.card.Flip": [],
    "Ext.chart.interactions.CrossZoom": [],
    "Ext.event.publisher.ComponentPaint": [],
    "Ext.event.recognizer.Rotate": [],
    "Ext.util.TranslatableList": [],
    "Ext.carousel.Item": [],
    "Ext.event.recognizer.Swipe": [],
    "Ext.util.translatable.ScrollPosition": [],
    "Ext.device.camera.Simulator": [],
    "Ext.chart.series.sprite.Area": [],
    "Ext.event.recognizer.Touch": [],
    "Ext.plugin.ListPaging": [],
    "Ext.draw.sprite.Sector": [],
    "Ext.chart.axis.segmenter.Names": [],
    "Ext.mixin.Observable": [ "Ext.util.Observable" ],
    "Ext.carousel.Infinite": [],
    "Ext.draw.Matrix": [],
    "Ext.Mask": [],
    "Ext.event.publisher.Publisher": [],
    "Ext.layout.wrapper.Dock": [],
    "Ext.app.History": [],
    "Ext.data.proxy.Direct": [ "Ext.data.DirectProxy" ],
    "Ext.chart.axis.layout.Continuous": [],
    "Ext.data.proxy.Sql": [ "Ext.data.proxy.SQL" ],
    "Ext.table.Cell": [],
    "Ext.fx.layout.card.ScrollCover": [],
    "Ext.device.orientation.Sencha": [],
    "Ext.util.Droppable": [],
    "Ext.draw.sprite.Composite": [],
    "Ext.chart.series.Pie": [],
    "Ext.device.Purchases.Product": [],
    "Ext.device.Orientation": [],
    "Ext.direct.Provider": [],
    "Ext.draw.sprite.Arc": [],
    "Ext.chart.axis.segmenter.Time": [],
    "Ext.util.Draggable": [],
    "Ext.device.contacts.Sencha": [],
    "Ext.chart.grid.HorizontalGrid": [],
    "Ext.mixin.Traversable": [],
    "Ext.util.AbstractMixedCollection": [],
    "Ext.data.JsonStore": [],
    "Ext.draw.SegmentTree": [],
    "Ext.direct.RemotingEvent": [],
    "Ext.plugin.PullRefresh": [],
    "Ext.log.writer.Console": [],
    "Ext.field.Spinner": [ "Ext.form.Spinner" ],
    "Ext.chart.axis.segmenter.Numeric": [],
    "Ext.data.proxy.LocalStorage": [ "Ext.data.LocalStorageProxy" ],
    "Ext.fx.animation.Wipe": [ "Ext.fx.animation.WipeIn" ],
    "Ext.fx.layout.Card": [],
    "Ext.TaskQueue": [],
    "Ext.Label": [],
    "Ext.util.translatable.CssTransform": [],
    "Ext.viewport.Ios": [],
    "Ext.Spacer": [],
    "Ext.mixin.Selectable": [],
    "Ext.draw.sprite.Image": [],
    "Ext.data.proxy.Rest": [ "Ext.data.RestProxy" ],
    "Ext.Img": [],
    "Ext.chart.series.sprite.Bar": [],
    "Ext.log.writer.DocumentTitle": [],
    "Ext.data.Error": [],
    "Ext.util.Sorter": [],
    "Ext.draw.gradient.Radial": [],
    "Ext.layout.Abstract": [],
    "Ext.device.notification.Abstract": [],
    "Ext.log.filter.Filter": [],
    "Ext.device.camera.Sencha": [],
    "Ext.draw.sprite.Sprite": [],
    "Ext.draw.Color": [],
    "Ext.chart.series.Bar": [],
    "Ext.field.Slider": [ "Ext.form.Slider" ],
    "Ext.field.Search": [ "Ext.form.Search" ],
    "Ext.chart.series.Scatter": [],
    "Ext.device.Device": [],
    "Ext.event.Dispatcher": [],
    "Ext.data.Store": [],
    "Ext.draw.modifier.Highlight": [],
    "Ext.behavior.Translatable": [],
    "Ext.direct.Manager": [ "Ext.Direct" ],
    "Ext.data.proxy.Proxy": [ "Ext.data.DataProxy", "Ext.data.Proxy" ],
    "Ext.draw.modifier.Modifier": [],
    "Ext.navigation.View": [ "Ext.NavigationView" ],
    "Ext.draw.modifier.Target": [],
    "Ext.draw.sprite.AttributeDefinition": [],
    "Ext.device.Notification": [],
    "Ext.draw.Component": [],
    "Ext.layout.VBox": [],
    "Ext.slider.Thumb": [],
    "Ext.MessageBox": [],
    "Ext.dataview.IndexBar": [ "Ext.IndexBar" ],
    "Ext.dataview.element.List": [],
    "Ext.layout.FlexBox": [],
    "Ext.field.Url": [ "Ext.form.Url" ],
    "Ext.draw.Solver": [],
    "Ext.data.proxy.Memory": [ "Ext.data.MemoryProxy" ],
    "Ext.chart.axis.Time": [],
    "Ext.layout.Card": [],
    "Ext.ComponentQuery": [],
    "Ext.chart.series.Pie3D": [],
    "Ext.device.camera.Abstract": [],
    "Ext.device.device.Sencha": [],
    "Ext.scroll.View": [ "Ext.util.ScrollView" ],
    "Ext.draw.sprite.Rect": [],
    "Ext.util.Region": [],
    "Ext.field.Select": [ "Ext.form.Select" ],
    "Ext.draw.Draw": [],
    "Ext.ItemCollection": [],
    "Ext.log.formatter.Default": [],
    "Ext.navigation.Bar": [],
    "Ext.chart.axis.layout.CombineDuplicate": [],
    "Ext.device.Geolocation": [],
    "Ext.chart.SpaceFillingChart": [],
    "Ext.data.proxy.SessionStorage": [ "Ext.data.SessionStorageProxy" ],
    "Ext.fx.easing.EaseIn": [],
    "Ext.draw.sprite.AnimationParser": [],
    "Ext.field.Password": [ "Ext.form.Password" ],
    "Ext.device.connection.Abstract": [],
    "Ext.direct.Event": [],
    "Ext.direct.RemotingMethod": [],
    "Ext.Evented": [ "Ext.EventedBase" ],
    "Ext.carousel.Indicator": [ "Ext.Carousel.Indicator" ],
    "Ext.util.Collection": [],
    "Ext.chart.interactions.ItemInfo": [],
    "Ext.chart.MarkerHolder": [],
    "Ext.carousel.Carousel": [ "Ext.Carousel" ],
    "Ext.Audio": [],
    "Ext.device.Contacts": [],
    "Ext.table.Table": [],
    "Ext.draw.engine.SvgContext.Gradient": [],
    "Ext.chart.axis.layout.Layout": [],
    "Ext.data.Errors": [],
    "Ext.field.Text": [ "Ext.form.Text" ],
    "Ext.field.TextAreaInput": [],
    "Ext.field.DatePicker": [ "Ext.form.DatePicker" ],
    "Ext.draw.engine.Svg": [],
    "Ext.event.recognizer.Tap": [],
    "Ext.device.orientation.Abstract": [],
    "Ext.AbstractManager": [],
    "Ext.chart.series.Radar": [],
    "Ext.chart.interactions.Abstract": [],
    "Ext.scroll.indicator.CssTransform": [],
    "Ext.util.PaintMonitor": [],
    "Ext.direct.PollingProvider": [],
    "Ext.device.notification.PhoneGap": [],
    "Ext.data.writer.Xml": [ "Ext.data.XmlWriter" ],
    "Ext.event.recognizer.SingleTouch": [],
    "Ext.draw.sprite.Instancing": [],
    "Ext.event.publisher.ComponentDelegation": [],
    "Ext.chart.axis.Numeric": [],
    "Ext.field.Toggle": [ "Ext.form.Toggle" ],
    "Ext.fx.layout.card.ScrollReveal": [],
    "Ext.data.Operation": [],
    "Ext.fx.animation.Abstract": [],
    "Ext.chart.interactions.Rotate": [],
    "Ext.draw.engine.SvgContext": [],
    "Ext.scroll.Scroller": [],
    "Ext.util.SizeMonitor": [],
    "Ext.event.ListenerStack": [],
    "Ext.util.MixedCollection": []
});

Ext.ClassManager.addNameAliasMappings({
    "Ext.app.Profile": [],
    "Ext.event.recognizer.MultiTouch": [],
    "Ext.fx.Runner": [],
    "Ext.chart.grid.CircularGrid": [ "grid.circular" ],
    "Ext.mixin.Templatable": [],
    "Ext.event.recognizer.Pinch": [],
    "Ext.util.Format": [],
    "Ext.direct.JsonProvider": [ "direct.jsonprovider" ],
    "Ext.data.identifier.Simple": [ "data.identifier.simple" ],
    "Ext.dataview.DataView": [ "widget.dataview" ],
    "Ext.field.Hidden": [ "widget.hiddenfield" ],
    "Ext.field.Number": [ "widget.numberfield" ],
    "Ext.chart.series.CandleStick": [ "series.candlestick" ],
    "Ext.device.Connection": [],
    "Ext.data.Model": [],
    "Ext.data.reader.Reader": [],
    "Ext.Sheet": [ "widget.sheet" ],
    "Ext.tab.Tab": [ "widget.tab" ],
    "Ext.chart.series.sprite.StackedCartesian": [],
    "Ext.util.Grouper": [],
    "Ext.util.translatable.CssPosition": [],
    "Ext.util.paintmonitor.Abstract": [],
    "Ext.direct.RemotingProvider": [ "direct.remotingprovider" ],
    "Ext.data.NodeInterface": [],
    "Ext.chart.interactions.PanZoom": [ "interaction.panzoom" ],
    "Ext.util.PositionMap": [],
    "Ext.chart.series.ItemPublisher": [],
    "Ext.util.Sortable": [],
    "Ext.chart.series.sprite.AbstractRadial": [],
    "Ext.fx.runner.Css": [],
    "Ext.fx.runner.CssTransition": [],
    "Ext.draw.Group": [],
    "Ext.XTemplateCompiler": [],
    "Ext.util.Wrapper": [],
    "Ext.app.Router": [],
    "Ext.direct.Transaction": [ "direct.transaction" ],
    "Ext.util.Offset": [],
    "Ext.device.device.Abstract": [],
    "Ext.mixin.Mixin": [],
    "Ext.fx.animation.FadeOut": [ "animation.fadeOut" ],
    "Ext.util.Geolocation": [],
    "Ext.ComponentManager": [],
    "Ext.util.sizemonitor.OverflowChange": [],
    "Ext.event.publisher.ElementSize": [],
    "Ext.tab.Bar": [ "widget.tabbar" ],
    "Ext.event.Dom": [],
    "Ext.app.Application": [],
    "Ext.dataview.List": [ "widget.list" ],
    "Ext.util.translatable.Dom": [],
    "Ext.fx.layout.card.Scroll": [ "fx.layout.card.scroll" ],
    "Ext.draw.LimitedCache": [],
    "Ext.device.geolocation.Sencha": [],
    "Ext.dataview.ListItemHeader": [ "widget.listitemheader" ],
    "Ext.event.publisher.TouchGesture": [],
    "Ext.data.SortTypes": [],
    "Ext.device.contacts.Abstract": [],
    "Ext.device.push.Sencha": [],
    "Ext.fx.animation.WipeOut": [],
    "Ext.slider.Slider": [ "widget.slider" ],
    "Ext.Component": [ "widget.component" ],
    "Ext.device.communicator.Default": [],
    "Ext.fx.runner.CssAnimation": [],
    "Ext.chart.axis.Axis": [ "widget.axis" ],
    "Ext.fx.animation.Cube": [ "animation.cube" ],
    "Ext.chart.Markers": [],
    "Ext.chart.series.sprite.Radar": [ "sprite.radar" ],
    "Ext.device.device.Simulator": [],
    "Ext.Ajax": [],
    "Ext.dataview.component.ListItem": [ "widget.listitem" ],
    "Ext.util.Filter": [],
    "Ext.layout.wrapper.Inner": [],
    "Ext.draw.Animator": [],
    "Ext.device.geolocation.Simulator": [],
    "Ext.data.association.BelongsTo": [ "association.belongsto" ],
    "Ext.draw.Surface": [ "widget.surface" ],
    "Ext.scroll.indicator.ScrollPosition": [],
    "Ext.field.Email": [ "widget.emailfield" ],
    "Ext.fx.layout.card.Abstract": [],
    "Ext.event.Controller": [],
    "Ext.dataview.component.Container": [],
    "Ext.log.writer.Remote": [],
    "Ext.fx.layout.card.Style": [],
    "Ext.device.purchases.Sencha": [],
    "Ext.chart.axis.segmenter.Segmenter": [],
    "Ext.viewport.Android": [],
    "Ext.log.formatter.Identity": [],
    "Ext.chart.interactions.ItemHighlight": [ "interaction.itemhighlight" ],
    "Ext.picker.Picker": [ "widget.picker" ],
    "Ext.data.Batch": [],
    "Ext.draw.modifier.Animation": [ "modifier.animation" ],
    "Ext.chart.AbstractChart": [],
    "Ext.field.File": [ "widget.file" ],
    "Ext.tab.Panel": [ "widget.tabpanel" ],
    "Ext.draw.Path": [],
    "Ext.scroll.indicator.Throttled": [],
    "Ext.fx.animation.SlideOut": [ "animation.slideOut" ],
    "Ext.device.connection.Sencha": [],
    "Ext.fx.layout.card.Pop": [ "fx.layout.card.pop" ],
    "Ext.chart.axis.layout.Discrete": [ "axisLayout.discrete" ],
    "Ext.data.Field": [ "data.field" ],
    "Ext.chart.series.Gauge": [ "series.gauge" ],
    "Ext.data.StoreManager": [],
    "Ext.fx.animation.PopOut": [ "animation.popOut" ],
    "Ext.chart.label.Callout": [],
    "Ext.device.push.Abstract": [],
    "Ext.util.DelayedTask": [],
    "Ext.fx.easing.Momentum": [],
    "Ext.fx.easing.Abstract": [],
    "Ext.Title": [ "widget.title" ],
    "Ext.event.recognizer.Drag": [],
    "Ext.field.TextArea": [ "widget.textareafield" ],
    "Ext.fx.Easing": [],
    "Ext.chart.series.sprite.Scatter": [ "sprite.scatterSeries" ],
    "Ext.data.reader.Array": [ "reader.array" ],
    "Ext.picker.Date": [ "widget.datepicker" ],
    "Ext.data.proxy.JsonP": [ "proxy.jsonp", "proxy.scripttag" ],
    "Ext.device.communicator.Android": [],
    "Ext.chart.series.Area": [ "series.area" ],
    "Ext.device.device.PhoneGap": [],
    "Ext.field.Checkbox": [ "widget.checkboxfield" ],
    "Ext.chart.Legend": [ "widget.legend" ],
    "Ext.Media": [ "widget.media" ],
    "Ext.TitleBar": [ "widget.titlebar" ],
    "Ext.chart.interactions.RotatePie3D": [ "interaction.rotatePie3d" ],
    "Ext.draw.gradient.Linear": [],
    "Ext.util.TapRepeater": [],
    "Ext.event.Touch": [],
    "Ext.mixin.Bindable": [],
    "Ext.data.proxy.Server": [ "proxy.server" ],
    "Ext.chart.series.Cartesian": [],
    "Ext.util.sizemonitor.Scroll": [],
    "Ext.data.ResultSet": [],
    "Ext.data.association.HasMany": [ "association.hasmany" ],
    "Ext.draw.TimingFunctions": [],
    "Ext.draw.engine.Canvas": [],
    "Ext.data.proxy.Ajax": [ "proxy.ajax" ],
    "Ext.fx.animation.Fade": [ "animation.fade", "animation.fadeIn" ],
    "Ext.layout.Default": [ "layout.default", "layout.auto" ],
    "Ext.util.paintmonitor.CssAnimation": [],
    "Ext.data.writer.Writer": [ "writer.base" ],
    "Ext.event.recognizer.Recognizer": [],
    "Ext.form.FieldSet": [ "widget.fieldset" ],
    "Ext.scroll.Indicator": [],
    "Ext.XTemplateParser": [],
    "Ext.behavior.Scrollable": [],
    "Ext.chart.series.sprite.CandleStick": [ "sprite.candlestickSeries" ],
    "Ext.data.JsonP": [],
    "Ext.device.connection.PhoneGap": [],
    "Ext.event.publisher.Dom": [],
    "Ext.fx.layout.card.Fade": [ "fx.layout.card.fade" ],
    "Ext.app.Controller": [],
    "Ext.fx.State": [],
    "Ext.layout.wrapper.BoxDock": [],
    "Ext.chart.series.sprite.Pie3DPart": [ "sprite.pie3dPart" ],
    "Ext.viewport.Default": [ "widget.viewport" ],
    "Ext.layout.HBox": [ "layout.hbox" ],
    "Ext.scroll.indicator.Default": [],
    "Ext.data.ModelManager": [],
    "Ext.data.Validations": [],
    "Ext.util.translatable.Abstract": [],
    "Ext.scroll.indicator.Abstract": [],
    "Ext.Button": [ "widget.button" ],
    "Ext.field.Radio": [ "widget.radiofield" ],
    "Ext.util.HashMap": [],
    "Ext.field.Input": [ "widget.input" ],
    "Ext.device.Camera": [],
    "Ext.mixin.Filterable": [],
    "Ext.draw.TextMeasurer": [],
    "Ext.dataview.element.Container": [],
    "Ext.chart.series.sprite.PieSlice": [ "sprite.pieslice" ],
    "Ext.data.Connection": [],
    "Ext.direct.ExceptionEvent": [ "direct.exception" ],
    "Ext.Panel": [ "widget.panel" ],
    "Ext.data.association.HasOne": [ "association.hasone" ],
    "Ext.device.geolocation.Abstract": [],
    "Ext.ActionSheet": [ "widget.actionsheet" ],
    "Ext.layout.Box": [ "layout.tablebox" ],
    "Ext.bb.CrossCut": [ "widget.crosscut" ],
    "Ext.Video": [ "widget.video" ],
    "Ext.chart.series.Line": [ "series.line" ],
    "Ext.fx.layout.card.Cube": [ "fx.layout.card.cube" ],
    "Ext.event.recognizer.HorizontalSwipe": [],
    "Ext.data.writer.Json": [ "writer.json" ],
    "Ext.layout.Fit": [ "layout.fit" ],
    "Ext.fx.animation.Slide": [ "animation.slide", "animation.slideIn" ],
    "Ext.device.Purchases.Purchase": [],
    "Ext.table.Row": [ "widget.tablerow" ],
    "Ext.log.formatter.Formatter": [],
    "Ext.Container": [ "widget.container" ],
    "Ext.fx.animation.Pop": [ "animation.pop", "animation.popIn" ],
    "Ext.draw.sprite.Circle": [ "sprite.circle" ],
    "Ext.fx.layout.card.Reveal": [ "fx.layout.card.reveal" ],
    "Ext.fx.layout.card.Cover": [ "fx.layout.card.cover" ],
    "Ext.log.Base": [],
    "Ext.data.reader.Xml": [ "reader.xml" ],
    "Ext.event.publisher.ElementPaint": [],
    "Ext.chart.axis.Category": [ "axis.category" ],
    "Ext.data.reader.Json": [ "reader.json" ],
    "Ext.Decorator": [],
    "Ext.data.TreeStore": [ "store.tree" ],
    "Ext.device.Purchases": [],
    "Ext.device.orientation.HTML5": [],
    "Ext.draw.gradient.Gradient": [],
    "Ext.event.recognizer.DoubleTap": [],
    "Ext.log.Logger": [],
    "Ext.picker.Slot": [ "widget.pickerslot" ],
    "Ext.device.notification.Simulator": [],
    "Ext.field.Field": [ "widget.field" ],
    "Ext.log.filter.Priority": [],
    "Ext.util.sizemonitor.Abstract": [],
    "Ext.chart.series.sprite.Polar": [],
    "Ext.util.paintmonitor.OverflowChange": [],
    "Ext.util.LineSegment": [],
    "Ext.SegmentedButton": [ "widget.segmentedbutton" ],
    "Ext.Sortable": [],
    "Ext.fx.easing.Linear": [ "easing.linear" ],
    "Ext.chart.series.sprite.Aggregative": [],
    "Ext.dom.CompositeElement": [],
    "Ext.data.identifier.Uuid": [ "data.identifier.uuid" ],
    "Ext.data.proxy.Client": [],
    "Ext.fx.easing.Bounce": [],
    "Ext.data.Types": [],
    "Ext.chart.series.sprite.Cartesian": [],
    "Ext.app.Action": [],
    "Ext.util.Translatable": [],
    "Ext.device.camera.PhoneGap": [],
    "Ext.draw.sprite.Path": [ "sprite.path" ],
    "Ext.LoadMask": [ "widget.loadmask" ],
    "Ext.data.association.Association": [],
    "Ext.chart.axis.sprite.Axis": [],
    "Ext.behavior.Draggable": [],
    "Ext.chart.grid.RadialGrid": [ "grid.radial" ],
    "Ext.util.TranslatableGroup": [],
    "Ext.fx.Animation": [],
    "Ext.draw.sprite.Ellipse": [ "sprite.ellipse" ],
    "Ext.util.Inflector": [],
    "Ext.Map": [ "widget.map" ],
    "Ext.XTemplate": [],
    "Ext.data.NodeStore": [ "store.node" ],
    "Ext.draw.sprite.AttributeParser": [],
    "Ext.form.Panel": [ "widget.formpanel" ],
    "Ext.chart.series.Series": [],
    "Ext.data.Request": [],
    "Ext.draw.sprite.Text": [ "sprite.text" ],
    "Ext.layout.Float": [ "layout.float" ],
    "Ext.dataview.component.DataItem": [ "widget.dataitem" ],
    "Ext.chart.CartesianChart": [ "widget.chart", "Ext.chart.Chart" ],
    "Ext.data.proxy.WebStorage": [],
    "Ext.log.writer.Writer": [],
    "Ext.device.Communicator": [],
    "Ext.fx.animation.Flip": [ "animation.flip" ],
    "Ext.util.Point": [],
    "Ext.chart.series.StackedCartesian": [],
    "Ext.fx.layout.card.Slide": [ "fx.layout.card.slide" ],
    "Ext.Anim": [],
    "Ext.data.DirectStore": [ "store.direct" ],
    "Ext.dataview.NestedList": [ "widget.nestedlist" ],
    "Ext.app.Route": [],
    "Ext.device.connection.Simulator": [],
    "Ext.chart.PolarChart": [ "widget.polar" ],
    "Ext.event.publisher.ComponentSize": [],
    "Ext.slider.Toggle": [],
    "Ext.data.identifier.Sequential": [ "data.identifier.sequential" ],
    "Ext.Template": [],
    "Ext.AbstractComponent": [],
    "Ext.device.Push": [],
    "Ext.fx.easing.BoundMomentum": [],
    "Ext.viewport.Viewport": [],
    "Ext.chart.series.Polar": [],
    "Ext.event.recognizer.VerticalSwipe": [],
    "Ext.event.Event": [],
    "Ext.behavior.Behavior": [],
    "Ext.chart.grid.VerticalGrid": [ "grid.vertical" ],
    "Ext.chart.label.Label": [],
    "Ext.draw.sprite.EllipticalArc": [ "sprite.ellipticalArc" ],
    "Ext.fx.easing.EaseOut": [ "easing.ease-out" ],
    "Ext.Toolbar": [ "widget.toolbar" ],
    "Ext.event.recognizer.LongPress": [],
    "Ext.device.notification.Sencha": [],
    "Ext.chart.series.sprite.Line": [ "sprite.lineSeries" ],
    "Ext.data.ArrayStore": [ "store.array" ],
    "Ext.mixin.Sortable": [],
    "Ext.fx.layout.card.Flip": [ "fx.layout.card.flip" ],
    "Ext.chart.interactions.CrossZoom": [ "interaction.crosszoom" ],
    "Ext.event.publisher.ComponentPaint": [],
    "Ext.event.recognizer.Rotate": [],
    "Ext.util.TranslatableList": [],
    "Ext.carousel.Item": [],
    "Ext.event.recognizer.Swipe": [],
    "Ext.util.translatable.ScrollPosition": [],
    "Ext.device.camera.Simulator": [],
    "Ext.chart.series.sprite.Area": [ "sprite.areaSeries" ],
    "Ext.event.recognizer.Touch": [],
    "Ext.plugin.ListPaging": [ "plugin.listpaging" ],
    "Ext.draw.sprite.Sector": [ "sprite.sector" ],
    "Ext.chart.axis.segmenter.Names": [ "segmenter.names" ],
    "Ext.mixin.Observable": [],
    "Ext.carousel.Infinite": [],
    "Ext.draw.Matrix": [],
    "Ext.Mask": [ "widget.mask" ],
    "Ext.event.publisher.Publisher": [],
    "Ext.layout.wrapper.Dock": [],
    "Ext.app.History": [],
    "Ext.data.proxy.Direct": [ "proxy.direct" ],
    "Ext.chart.axis.layout.Continuous": [ "axisLayout.continuous" ],
    "Ext.data.proxy.Sql": [ "proxy.sql" ],
    "Ext.table.Cell": [ "widget.tablecell" ],
    "Ext.fx.layout.card.ScrollCover": [ "fx.layout.card.scrollcover" ],
    "Ext.device.orientation.Sencha": [],
    "Ext.util.Droppable": [],
    "Ext.draw.sprite.Composite": [ "sprite.composite" ],
    "Ext.chart.series.Pie": [ "series.pie" ],
    "Ext.device.Purchases.Product": [],
    "Ext.device.Orientation": [],
    "Ext.direct.Provider": [ "direct.provider" ],
    "Ext.draw.sprite.Arc": [ "sprite.arc" ],
    "Ext.chart.axis.segmenter.Time": [ "segmenter.time" ],
    "Ext.util.Draggable": [],
    "Ext.device.contacts.Sencha": [],
    "Ext.chart.grid.HorizontalGrid": [ "grid.horizontal" ],
    "Ext.mixin.Traversable": [],
    "Ext.util.AbstractMixedCollection": [],
    "Ext.data.JsonStore": [ "store.json" ],
    "Ext.draw.SegmentTree": [],
    "Ext.direct.RemotingEvent": [ "direct.rpc" ],
    "Ext.plugin.PullRefresh": [ "plugin.pullrefresh" ],
    "Ext.log.writer.Console": [],
    "Ext.field.Spinner": [ "widget.spinnerfield" ],
    "Ext.chart.axis.segmenter.Numeric": [ "segmenter.numeric" ],
    "Ext.data.proxy.LocalStorage": [ "proxy.localstorage" ],
    "Ext.fx.animation.Wipe": [],
    "Ext.fx.layout.Card": [],
    "Ext.TaskQueue": [],
    "Ext.Label": [ "widget.label" ],
    "Ext.util.translatable.CssTransform": [],
    "Ext.viewport.Ios": [],
    "Ext.Spacer": [ "widget.spacer" ],
    "Ext.mixin.Selectable": [],
    "Ext.draw.sprite.Image": [ "sprite.image" ],
    "Ext.data.proxy.Rest": [ "proxy.rest" ],
    "Ext.Img": [ "widget.img", "widget.image" ],
    "Ext.chart.series.sprite.Bar": [ "sprite.barSeries" ],
    "Ext.log.writer.DocumentTitle": [],
    "Ext.data.Error": [],
    "Ext.util.Sorter": [],
    "Ext.draw.gradient.Radial": [],
    "Ext.layout.Abstract": [],
    "Ext.device.notification.Abstract": [],
    "Ext.log.filter.Filter": [],
    "Ext.device.camera.Sencha": [],
    "Ext.draw.sprite.Sprite": [ "sprite.sprite" ],
    "Ext.draw.Color": [],
    "Ext.chart.series.Bar": [ "series.bar" ],
    "Ext.field.Slider": [ "widget.sliderfield" ],
    "Ext.field.Search": [ "widget.searchfield" ],
    "Ext.chart.series.Scatter": [ "series.scatter" ],
    "Ext.device.Device": [],
    "Ext.event.Dispatcher": [],
    "Ext.data.Store": [ "store.store" ],
    "Ext.draw.modifier.Highlight": [ "modifier.highlight" ],
    "Ext.behavior.Translatable": [],
    "Ext.direct.Manager": [],
    "Ext.data.proxy.Proxy": [ "proxy.proxy" ],
    "Ext.draw.modifier.Modifier": [],
    "Ext.navigation.View": [ "widget.navigationview" ],
    "Ext.draw.modifier.Target": [ "modifier.target" ],
    "Ext.draw.sprite.AttributeDefinition": [],
    "Ext.device.Notification": [],
    "Ext.draw.Component": [ "widget.draw" ],
    "Ext.layout.VBox": [ "layout.vbox" ],
    "Ext.slider.Thumb": [ "widget.thumb" ],
    "Ext.MessageBox": [],
    "Ext.dataview.IndexBar": [],
    "Ext.dataview.element.List": [],
    "Ext.layout.FlexBox": [ "layout.box" ],
    "Ext.field.Url": [ "widget.urlfield" ],
    "Ext.draw.Solver": [],
    "Ext.data.proxy.Memory": [ "proxy.memory" ],
    "Ext.chart.axis.Time": [ "axis.time" ],
    "Ext.layout.Card": [ "layout.card" ],
    "Ext.ComponentQuery": [],
    "Ext.chart.series.Pie3D": [ "series.pie3d" ],
    "Ext.device.camera.Abstract": [],
    "Ext.device.device.Sencha": [],
    "Ext.scroll.View": [],
    "Ext.draw.sprite.Rect": [ "sprite.rect" ],
    "Ext.util.Region": [],
    "Ext.field.Select": [ "widget.selectfield" ],
    "Ext.draw.Draw": [],
    "Ext.ItemCollection": [],
    "Ext.log.formatter.Default": [],
    "Ext.navigation.Bar": [],
    "Ext.chart.axis.layout.CombineDuplicate": [ "axisLayout.combineDuplicate" ],
    "Ext.device.Geolocation": [],
    "Ext.chart.SpaceFillingChart": [ "widget.spacefilling" ],
    "Ext.data.proxy.SessionStorage": [ "proxy.sessionstorage" ],
    "Ext.fx.easing.EaseIn": [ "easing.ease-in" ],
    "Ext.draw.sprite.AnimationParser": [],
    "Ext.field.Password": [ "widget.passwordfield" ],
    "Ext.device.connection.Abstract": [],
    "Ext.direct.Event": [ "direct.event" ],
    "Ext.direct.RemotingMethod": [],
    "Ext.Evented": [],
    "Ext.carousel.Indicator": [ "widget.carouselindicator" ],
    "Ext.util.Collection": [],
    "Ext.chart.interactions.ItemInfo": [ "interaction.iteminfo" ],
    "Ext.chart.MarkerHolder": [],
    "Ext.carousel.Carousel": [ "widget.carousel" ],
    "Ext.Audio": [ "widget.audio" ],
    "Ext.device.Contacts": [],
    "Ext.table.Table": [ "widget.table" ],
    "Ext.draw.engine.SvgContext.Gradient": [],
    "Ext.chart.axis.layout.Layout": [],
    "Ext.data.Errors": [],
    "Ext.field.Text": [ "widget.textfield" ],
    "Ext.field.TextAreaInput": [ "widget.textareainput" ],
    "Ext.field.DatePicker": [ "widget.datepickerfield" ],
    "Ext.draw.engine.Svg": [],
    "Ext.event.recognizer.Tap": [],
    "Ext.device.orientation.Abstract": [],
    "Ext.AbstractManager": [],
    "Ext.chart.series.Radar": [ "series.radar" ],
    "Ext.chart.interactions.Abstract": [ "widget.interaction" ],
    "Ext.scroll.indicator.CssTransform": [],
    "Ext.util.PaintMonitor": [],
    "Ext.direct.PollingProvider": [ "direct.pollingprovider" ],
    "Ext.device.notification.PhoneGap": [],
    "Ext.data.writer.Xml": [ "writer.xml" ],
    "Ext.event.recognizer.SingleTouch": [],
    "Ext.draw.sprite.Instancing": [ "sprite.instancing" ],
    "Ext.event.publisher.ComponentDelegation": [],
    "Ext.chart.axis.Numeric": [ "axis.numeric" ],
    "Ext.field.Toggle": [ "widget.togglefield" ],
    "Ext.fx.layout.card.ScrollReveal": [ "fx.layout.card.scrollreveal" ],
    "Ext.data.Operation": [],
    "Ext.fx.animation.Abstract": [],
    "Ext.chart.interactions.Rotate": [ "interaction.rotate" ],
    "Ext.draw.engine.SvgContext": [],
    "Ext.scroll.Scroller": [],
    "Ext.util.SizeMonitor": [],
    "Ext.event.ListenerStack": [],
    "Ext.util.MixedCollection": []
});

Ext.define("Ext.event.ListenerStack", {
    currentOrder: "current",
    length: 0,
    constructor: function() {
        this.listeners = {
            before: [],
            current: [],
            after: []
        };
        this.lateBindingMap = {};
        return this;
    },
    add: function(e, t, i, n) {
        var r = this.lateBindingMap, s = this.getAll(n), a = s.length, o, l, u;
        if (typeof e == "string" && t.isIdentifiable) {
            u = t.getId();
            o = r[u];
            if (o) {
                if (o[e]) {
                    return false;
                } else {
                    o[e] = true;
                }
            } else {
                r[u] = o = {};
                o[e] = true;
            }
        } else {
            if (a > 0) {
                while (a--) {
                    l = s[a];
                    if (l.fn === e && l.scope === t) {
                        l.options = i;
                        return false;
                    }
                }
            }
        }
        l = this.create(e, t, i, n);
        if (i && i.prepend) {
            delete i.prepend;
            s.unshift(l);
        } else {
            s.push(l);
        }
        this.length++;
        return true;
    },
    getAt: function(e, t) {
        return this.getAll(t)[e];
    },
    getAll: function(e) {
        if (!e) {
            e = this.currentOrder;
        }
        return this.listeners[e];
    },
    count: function(e) {
        return this.getAll(e).length;
    },
    create: function(e, t, i, n) {
        return {
            stack: this,
            fn: e,
            firingFn: false,
            boundFn: false,
            isLateBinding: typeof e == "string",
            scope: t,
            options: i || {},
            order: n
        };
    },
    remove: function(e, t, i) {
        var n = this.getAll(i), r = n.length, s = false, a = this.lateBindingMap, o, l;
        if (r > 0) {
            while (r--) {
                o = n[r];
                if (o.fn === e && o.scope === t) {
                    n.splice(r, 1);
                    s = true;
                    this.length--;
                    if (typeof e == "string" && t.isIdentifiable) {
                        l = t.getId();
                        if (a[l] && a[l][e]) {
                            delete a[l][e];
                        }
                    }
                    break;
                }
            }
        }
        return s;
    }
});

Ext.define("Ext.event.Controller", {
    isFiring: false,
    listenerStack: null,
    constructor: function(e) {
        this.firingListeners = [];
        this.firingArguments = [];
        this.setInfo(e);
        return this;
    },
    setInfo: function(e) {
        this.info = e;
    },
    getInfo: function() {
        return this.info;
    },
    setListenerStacks: function(e) {
        this.listenerStacks = e;
    },
    fire: function(e, t) {
        var i = this.listenerStacks, n = this.firingListeners, r = this.firingArguments, s = n.push, a = i.length, o, l, u, c, f = false, d = false, h;
        n.length = 0;
        if (t) {
            if (t.order !== "after") {
                f = true;
            } else {
                d = true;
            }
        }
        if (a === 1) {
            o = i[0].listeners;
            l = o.before;
            u = o.current;
            c = o.after;
            if (l.length > 0) {
                s.apply(n, l);
            }
            if (f) {
                s.call(n, t);
            }
            if (u.length > 0) {
                s.apply(n, u);
            }
            if (d) {
                s.call(n, t);
            }
            if (c.length > 0) {
                s.apply(n, c);
            }
        } else {
            for (h = 0; h < a; h++) {
                l = i[h].listeners.before;
                if (l.length > 0) {
                    s.apply(n, l);
                }
            }
            if (f) {
                s.call(n, t);
            }
            for (h = 0; h < a; h++) {
                u = i[h].listeners.current;
                if (u.length > 0) {
                    s.apply(n, u);
                }
            }
            if (d) {
                s.call(n, t);
            }
            for (h = 0; h < a; h++) {
                c = i[h].listeners.after;
                if (c.length > 0) {
                    s.apply(n, c);
                }
            }
        }
        if (n.length === 0) {
            return this;
        }
        if (!e) {
            e = [];
        }
        r.length = 0;
        r.push.apply(r, e);
        r.push(null, this);
        this.doFire();
        return this;
    },
    doFire: function() {
        var e = this.firingListeners, t = this.firingArguments, i = t.length - 2, n, r, s, a, o, l, u, c, f, d, h;
        this.isPausing = false;
        this.isPaused = false;
        this.isStopped = false;
        this.isFiring = true;
        for (n = 0, r = e.length; n < r; n++) {
            s = e[n];
            a = s.options;
            o = s.fn;
            l = s.firingFn;
            u = s.boundFn;
            c = s.isLateBinding;
            f = s.scope;
            if (c && u && u !== f[o]) {
                u = false;
                l = false;
            }
            if (!u) {
                if (c) {
                    u = f[o];
                    if (!u) {
                        continue;
                    }
                } else {
                    u = o;
                }
                s.boundFn = u;
            }
            if (!l) {
                l = u;
                if (a.buffer) {
                    l = Ext.Function.createBuffered(l, a.buffer, f);
                }
                if (a.delay) {
                    l = Ext.Function.createDelayed(l, a.delay, f);
                }
                s.firingFn = l;
            }
            t[i] = a;
            d = t;
            if (a.args) {
                d = a.args.concat(d);
            }
            if (a.single === true) {
                s.stack.remove(o, f, s.order);
            }
            h = l.apply(f, d);
            if (h === false) {
                this.stop();
            }
            if (this.isStopped) {
                break;
            }
            if (this.isPausing) {
                this.isPaused = true;
                e.splice(0, n + 1);
                return;
            }
        }
        this.isFiring = false;
        this.listenerStacks = null;
        e.length = 0;
        t.length = 0;
        this.connectingController = null;
    },
    connect: function(e) {
        this.connectingController = e;
    },
    resume: function() {
        var e = this.connectingController;
        this.isPausing = false;
        if (this.isPaused && this.firingListeners.length > 0) {
            this.isPaused = false;
            this.doFire();
        }
        if (e) {
            e.resume();
        }
        return this;
    },
    isInterrupted: function() {
        return this.isStopped || this.isPaused;
    },
    stop: function() {
        var e = this.connectingController;
        this.isStopped = true;
        if (e) {
            this.connectingController = null;
            e.stop();
        }
        this.isFiring = false;
        this.listenerStacks = null;
        return this;
    },
    pause: function() {
        var e = this.connectingController;
        this.isPausing = true;
        if (e) {
            e.pause();
        }
        return this;
    }
});

Ext.define("Ext.event.publisher.Publisher", {
    targetType: "",
    idSelectorRegex: /^#([\w\-]+)$/i,
    constructor: function() {
        var e = this.handledEvents, t, i, n, r;
        t = this.handledEventsMap = {};
        for (i = 0, n = e.length; i < n; i++) {
            r = e[i];
            t[r] = true;
        }
        this.subscribers = {};
        return this;
    },
    handles: function(e) {
        var t = this.handledEventsMap;
        return !!t[e] || !!t["*"] || e === "*";
    },
    getHandledEvents: function() {
        return this.handledEvents;
    },
    setDispatcher: function(e) {
        this.dispatcher = e;
    },
    subscribe: function() {
        return false;
    },
    unsubscribe: function() {
        return false;
    },
    unsubscribeAll: function() {
        delete this.subscribers;
        this.subscribers = {};
        return this;
    },
    notify: function() {
        return false;
    },
    getTargetType: function() {
        return this.targetType;
    },
    dispatch: function(e, t, i) {
        this.dispatcher.doDispatchEvent(this.targetType, e, t, i);
    }
});

Ext.define("Ext.event.Event", {
    alternateClassName: "Ext.EventObject",
    isStopped: false,
    set: function(e, t) {
        if (arguments.length === 1 && typeof e != "string") {
            var i = e;
            for (e in i) {
                if (i.hasOwnProperty(e)) {
                    this[e] = i[e];
                }
            }
        } else {
            this[e] = i[e];
        }
    },
    stopEvent: function() {
        return this.stopPropagation();
    },
    stopPropagation: function() {
        this.isStopped = true;
        return this;
    }
});

Ext.define("Ext.event.Dispatcher", {
    requires: [ "Ext.event.ListenerStack", "Ext.event.Controller" ],
    statics: {
        getInstance: function() {
            if (!this.instance) {
                this.instance = new this();
            }
            return this.instance;
        },
        setInstance: function(e) {
            this.instance = e;
            return this;
        }
    },
    config: {
        publishers: {}
    },
    wildcard: "*",
    constructor: function(e) {
        this.listenerStacks = {};
        this.activePublishers = {};
        this.publishersCache = {};
        this.noActivePublishers = [];
        this.controller = null;
        this.initConfig(e);
        return this;
    },
    getListenerStack: function(e, t, i, n) {
        var r = this.listenerStacks, s = r[e], a;
        n = Boolean(n);
        if (!s) {
            if (n) {
                r[e] = s = {};
            } else {
                return null;
            }
        }
        s = s[t];
        if (!s) {
            if (n) {
                r[e][t] = s = {};
            } else {
                return null;
            }
        }
        a = s[i];
        if (!a) {
            if (n) {
                s[i] = a = new Ext.event.ListenerStack();
            } else {
                return null;
            }
        }
        return a;
    },
    getController: function(e, t, i, n) {
        var r = this.controller, s = {
            targetType: e,
            target: t,
            eventName: i
        };
        if (!r) {
            this.controller = r = new Ext.event.Controller();
        }
        if (r.isFiring) {
            r = new Ext.event.Controller();
        }
        r.setInfo(s);
        if (n && r !== n) {
            r.connect(n);
        }
        return r;
    },
    applyPublishers: function(e) {
        var t, i;
        this.publishersCache = {};
        for (t in e) {
            if (e.hasOwnProperty(t)) {
                i = e[t];
                this.registerPublisher(i);
            }
        }
        return e;
    },
    registerPublisher: function(e) {
        var t = this.activePublishers, i = e.getTargetType(), n = t[i];
        if (!n) {
            t[i] = n = [];
        }
        n.push(e);
        e.setDispatcher(this);
        return this;
    },
    getCachedActivePublishers: function(e, t) {
        var i = this.publishersCache, n;
        if ((n = i[e]) && (n = n[t])) {
            return n;
        }
        return null;
    },
    cacheActivePublishers: function(e, t, i) {
        var n = this.publishersCache;
        if (!n[e]) {
            n[e] = {};
        }
        n[e][t] = i;
        return i;
    },
    getActivePublishers: function(e, t) {
        var i, n, r, s, a;
        if (i = this.getCachedActivePublishers(e, t)) {
            return i;
        }
        n = this.activePublishers[e];
        if (n) {
            i = [];
            for (r = 0, s = n.length; r < s; r++) {
                a = n[r];
                if (a.handles(t)) {
                    i.push(a);
                }
            }
        } else {
            i = this.noActivePublishers;
        }
        return this.cacheActivePublishers(e, t, i);
    },
    hasListener: function(e, t, i) {
        var n = this.getListenerStack(e, t, i);
        if (n) {
            return n.count() > 0;
        }
        return false;
    },
    addListener: function(e, t, i) {
        var n = this.getActivePublishers(e, i), r = n.length, s, a;
        a = this.doAddListener.apply(this, arguments);
        if (a && r > 0) {
            for (s = 0; s < r; s++) {
                n[s].subscribe(t, i);
            }
        }
        return a;
    },
    doAddListener: function(e, t, i, n, r, s, a) {
        var o = this.getListenerStack(e, t, i, true);
        return o.add(n, r, s, a);
    },
    removeListener: function(e, t, i) {
        var n = this.getActivePublishers(e, i), r = n.length, s, a;
        a = this.doRemoveListener.apply(this, arguments);
        if (a && r > 0) {
            for (s = 0; s < r; s++) {
                n[s].unsubscribe(t, i);
            }
        }
        return a;
    },
    doRemoveListener: function(e, t, i, n, r, s) {
        var a = this.getListenerStack(e, t, i);
        if (a === null) {
            return false;
        }
        return a.remove(n, r, s);
    },
    clearListeners: function(e, t, i) {
        var n = this.listenerStacks, r = arguments.length, s, a, o, l;
        if (r === 3) {
            if (n[e] && n[e][t]) {
                this.removeListener(e, t, i);
                delete n[e][t][i];
            }
        } else if (r === 2) {
            if (n[e]) {
                s = n[e][t];
                if (s) {
                    for (i in s) {
                        if (s.hasOwnProperty(i)) {
                            a = this.getActivePublishers(e, i);
                            for (o = 0, r = a.length; o < r; o++) {
                                a[o].unsubscribe(t, i, true);
                            }
                        }
                    }
                    delete n[e][t];
                }
            }
        } else if (r === 1) {
            a = this.activePublishers[e];
            for (o = 0, r = a.length; o < r; o++) {
                a[o].unsubscribeAll();
            }
            delete n[e];
        } else {
            a = this.activePublishers;
            for (e in a) {
                if (a.hasOwnProperty(e)) {
                    l = a[e];
                    for (o = 0, r = l.length; o < r; o++) {
                        l[o].unsubscribeAll();
                    }
                }
            }
            delete this.listenerStacks;
            this.listenerStacks = {};
        }
        return this;
    },
    dispatchEvent: function(e, t, i) {
        var n = this.getActivePublishers(e, i), r = n.length, s;
        if (r > 0) {
            for (s = 0; s < r; s++) {
                n[s].notify(t, i);
            }
        }
        return this.doDispatchEvent.apply(this, arguments);
    },
    doDispatchEvent: function(e, t, i, n, r, s) {
        var a = this.getListenerStack(e, t, i), o = this.getWildcardListenerStacks(e, t, i), l;
        if (a === null || a.length == 0) {
            if (o.length == 0 && !r) {
                return;
            }
        } else {
            o.push(a);
        }
        l = this.getController(e, t, i, s);
        l.setListenerStacks(o);
        l.fire(n, r);
        return !l.isInterrupted();
    },
    getWildcardListenerStacks: function(e, t, i) {
        var n = [], r = this.wildcard, s = i !== r, a = t !== r, o;
        if (s && (o = this.getListenerStack(e, t, r))) {
            n.push(o);
        }
        if (a && (o = this.getListenerStack(e, r, i))) {
            n.push(o);
        }
        return n;
    }
});

Ext.define("Ext.event.Dom", {
    extend: "Ext.event.Event",
    constructor: function(e) {
        var t = e.target, i;
        if (t && t.nodeType !== 1) {
            t = t.parentNode;
        }
        i = e.changedTouches;
        if (i) {
            i = i[0];
            this.pageX = i.pageX;
            this.pageY = i.pageY;
        } else {
            this.pageX = e.pageX;
            this.pageY = e.pageY;
        }
        this.browserEvent = this.event = e;
        this.target = this.delegatedTarget = t;
        this.type = e.type;
        this.timeStamp = this.time = e.timeStamp;
        if (typeof this.time != "number") {
            this.time = new Date(this.time).getTime();
        }
        return this;
    },
    stopEvent: function() {
        this.preventDefault();
        return this.callParent();
    },
    preventDefault: function() {
        this.browserEvent.preventDefault();
    },
    getPageX: function() {
        return this.browserEvent.pageX;
    },
    getPageY: function() {
        return this.browserEvent.pageY;
    },
    getXY: function() {
        if (!this.xy) {
            this.xy = [ this.getPageX(), this.getPageY() ];
        }
        return this.xy;
    },
    getTarget: function(e, t, i) {
        if (arguments.length === 0) {
            return this.delegatedTarget;
        }
        return e ? Ext.fly(this.target).findParent(e, t, i) : i ? Ext.get(this.target) : this.target;
    },
    getTime: function() {
        return this.time;
    },
    setDelegatedTarget: function(e) {
        this.delegatedTarget = e;
    },
    makeUnpreventable: function() {
        this.browserEvent.preventDefault = Ext.emptyFn;
    }
});

Ext.define("Ext.event.publisher.Dom", {
    extend: "Ext.event.publisher.Publisher",
    requires: [ "Ext.env.Browser", "Ext.Element", "Ext.event.Dom" ],
    targetType: "element",
    idOrClassSelectorRegex: /^([#|\.])([\w\-]+)$/,
    handledEvents: [ "click", "focus", "blur", "paste", "input", "mousemove", "mousedown", "mouseup", "mouseover", "mouseout", "keyup", "keydown", "keypress", "submit", "transitionend", "animationstart", "animationend" ],
    classNameSplitRegex: /\s+/,
    SELECTOR_ALL: "*",
    constructor: function() {
        var e = this.getHandledEvents(), t = {}, i, n, r, s;
        this.doBubbleEventsMap = {
            click: true,
            submit: true,
            mousedown: true,
            mousemove: true,
            mouseup: true,
            mouseover: true,
            mouseout: true,
            transitionend: true
        };
        this.onEvent = Ext.Function.bind(this.onEvent, this);
        for (i = 0, n = e.length; i < n; i++) {
            r = e[i];
            s = this.getVendorEventName(r);
            t[s] = r;
            this.attachListener(s);
        }
        this.eventNameMap = t;
        return this.callParent();
    },
    getSubscribers: function(e) {
        var t = this.subscribers, i = t[e];
        if (!i) {
            i = t[e] = {
                id: {
                    $length: 0
                },
                className: {
                    $length: 0
                },
                selector: [],
                all: 0,
                $length: 0
            };
        }
        return i;
    },
    getVendorEventName: function(e) {
        if (e === "transitionend") {
            e = Ext.browser.getVendorProperyName("transitionEnd");
        } else if (e === "animationstart") {
            e = Ext.browser.getVendorProperyName("animationStart");
        } else if (e === "animationend") {
            e = Ext.browser.getVendorProperyName("animationEnd");
        }
        return e;
    },
    attachListener: function(e) {
        document.addEventListener(e, this.onEvent, !this.doesEventBubble(e));
        return this;
    },
    removeListener: function(e) {
        document.removeEventListener(e, this.onEvent, !this.doesEventBubble(e));
        return this;
    },
    doesEventBubble: function(e) {
        return !!this.doBubbleEventsMap[e];
    },
    subscribe: function(e, t) {
        if (!this.handles(t)) {
            return false;
        }
        var i = e.match(this.idOrClassSelectorRegex), n = this.getSubscribers(t), r = n.id, s = n.className, a = n.selector, o, l;
        if (i !== null) {
            o = i[1];
            l = i[2];
            if (o === "#") {
                if (r.hasOwnProperty(l)) {
                    r[l]++;
                    return true;
                }
                r[l] = 1;
                r.$length++;
            } else {
                if (s.hasOwnProperty(l)) {
                    s[l]++;
                    return true;
                }
                s[l] = 1;
                s.$length++;
            }
        } else {
            if (e === this.SELECTOR_ALL) {
                n.all++;
            } else {
                if (a.hasOwnProperty(e)) {
                    a[e]++;
                    return true;
                }
                a[e] = 1;
                a.push(e);
            }
        }
        n.$length++;
        return true;
    },
    unsubscribe: function(e, t, i) {
        if (!this.handles(t)) {
            return false;
        }
        var n = e.match(this.idOrClassSelectorRegex), r = this.getSubscribers(t), s = r.id, a = r.className, o = r.selector, l, u;
        i = Boolean(i);
        if (n !== null) {
            l = n[1];
            u = n[2];
            if (l === "#") {
                if (!s.hasOwnProperty(u) || !i && --s[u] > 0) {
                    return true;
                }
                delete s[u];
                s.$length--;
            } else {
                if (!a.hasOwnProperty(u) || !i && --a[u] > 0) {
                    return true;
                }
                delete a[u];
                a.$length--;
            }
        } else {
            if (e === this.SELECTOR_ALL) {
                if (i) {
                    r.all = 0;
                } else {
                    r.all--;
                }
            } else {
                if (!o.hasOwnProperty(e) || !i && --o[e] > 0) {
                    return true;
                }
                delete o[e];
                Ext.Array.remove(o, e);
            }
        }
        r.$length--;
        return true;
    },
    getElementTarget: function(e) {
        if (e.nodeType !== 1) {
            e = e.parentNode;
            if (!e || e.nodeType !== 1) {
                return null;
            }
        }
        return e;
    },
    getBubblingTargets: function(e) {
        var t = [];
        if (!e) {
            return t;
        }
        do {
            t[t.length] = e;
            e = e.parentNode;
        } while (e && e.nodeType === 1);
        return t;
    },
    dispatch: function(e, t, i) {
        i.push(i[0].target);
        this.callParent(arguments);
    },
    publish: function(e, t, i) {
        var n = this.getSubscribers(e), r;
        if (n.$length === 0 || !this.doPublish(n, e, t, i)) {
            r = this.getSubscribers("*");
            if (r.$length > 0) {
                this.doPublish(r, e, t, i);
            }
        }
        return this;
    },
    doPublish: function(e, t, i, n) {
        var r = e.id, s = e.className, a = e.selector, o = r.$length > 0, l = s.$length > 0, u = a.length > 0, c = e.all > 0, f = {}, d = [ n ], h = false, g = this.classNameSplitRegex, p, m, x, E, y, v, b, S, C;
        for (p = 0, m = i.length; p < m; p++) {
            y = i[p];
            n.setDelegatedTarget(y);
            if (o) {
                v = y.id;
                if (v) {
                    if (r.hasOwnProperty(v)) {
                        h = true;
                        this.dispatch("#" + v, t, d);
                    }
                }
            }
            if (l) {
                b = y.className;
                if (b) {
                    S = b.split(g);
                    for (x = 0, E = S.length; x < E; x++) {
                        b = S[x];
                        if (!f[b]) {
                            f[b] = true;
                            if (s.hasOwnProperty(b)) {
                                h = true;
                                this.dispatch("." + b, t, d);
                            }
                        }
                    }
                }
            }
            if (n.isStopped) {
                return h;
            }
        }
        if (c && !h) {
            n.setDelegatedTarget(n.browserEvent.target);
            h = true;
            this.dispatch(this.SELECTOR_ALL, t, d);
            if (n.isStopped) {
                return h;
            }
        }
        if (u) {
            for (x = 0, E = i.length; x < E; x++) {
                y = i[x];
                for (p = 0, m = a.length; p < m; p++) {
                    C = a[p];
                    if (this.matchesSelector(y, C)) {
                        n.setDelegatedTarget(y);
                        h = true;
                        this.dispatch(C, t, d);
                    }
                    if (n.isStopped) {
                        return h;
                    }
                }
            }
        }
        return h;
    },
    matchesSelector: function(e, t) {
        if ("webkitMatchesSelector" in e) {
            return e.webkitMatchesSelector(t);
        }
        return Ext.DomQuery.is(e, t);
    },
    onEvent: function(e) {
        var t = this.eventNameMap[e.type];
        Ext.frameStartTime = e.timeStamp;
        if (!t || this.getSubscribersCount(t) === 0) {
            return;
        }
        var i = this.getElementTarget(e.target), n;
        if (!i) {
            return;
        }
        if (this.doesEventBubble(t)) {
            n = this.getBubblingTargets(i);
        } else {
            n = [ i ];
        }
        this.publish(t, n, new Ext.event.Dom(e));
    },
    hasSubscriber: function(e, t) {
        if (!this.handles(t)) {
            return false;
        }
        var i = e.match(this.idOrClassSelectorRegex), n = this.getSubscribers(t), r, s;
        if (i !== null) {
            r = i[1];
            s = i[2];
            if (r === "#") {
                return n.id.hasOwnProperty(s);
            } else {
                return n.className.hasOwnProperty(s);
            }
        } else {
            return n.selector.hasOwnProperty(e) && Ext.Array.indexOf(n.selector, e) !== -1;
        }
        return false;
    },
    getSubscribersCount: function(e) {
        if (!this.handles(e)) {
            return 0;
        }
        return this.getSubscribers(e).$length + this.getSubscribers("*").$length;
    }
});

Ext.define("Ext.util.Point", {
    radianToDegreeConstant: 180 / Math.PI,
    statics: {
        fromEvent: function(e) {
            var t = e.changedTouches, i = t && t.length > 0 ? t[0] : e;
            return this.fromTouch(i);
        },
        fromTouch: function(e) {
            return new this(e.pageX, e.pageY);
        },
        from: function(e) {
            if (!e) {
                return new this(0, 0);
            }
            if (!(e instanceof this)) {
                return new this(e.x, e.y);
            }
            return e;
        }
    },
    constructor: function(e, t) {
        if (typeof e == "undefined") {
            e = 0;
        }
        if (typeof t == "undefined") {
            t = 0;
        }
        this.x = e;
        this.y = t;
        return this;
    },
    clone: function() {
        return new this.self(this.x, this.y);
    },
    copy: function() {
        return this.clone.apply(this, arguments);
    },
    copyFrom: function(e) {
        this.x = e.x;
        this.y = e.y;
        return this;
    },
    toString: function() {
        return "Point[" + this.x + "," + this.y + "]";
    },
    equals: function(e) {
        return this.x === e.x && this.y === e.y;
    },
    isCloseTo: function(e, t) {
        if (typeof t == "number") {
            t = {
                x: t
            };
            t.y = t.x;
        }
        var i = e.x, n = e.y, r = t.x, s = t.y;
        return this.x <= i + r && this.x >= i - r && this.y <= n + s && this.y >= n - s;
    },
    isWithin: function() {
        return this.isCloseTo.apply(this, arguments);
    },
    translate: function(e, t) {
        this.x += e;
        this.y += t;
        return this;
    },
    roundedEquals: function(e) {
        return Math.round(this.x) === Math.round(e.x) && Math.round(this.y) === Math.round(e.y);
    },
    getDistanceTo: function(e) {
        var t = this.x - e.x, i = this.y - e.y;
        return Math.sqrt(t * t + i * i);
    },
    getAngleTo: function(e) {
        var t = this.x - e.x, i = this.y - e.y;
        return Math.atan2(i, t) * this.radianToDegreeConstant;
    }
});

Ext.define("Ext.event.Touch", {
    extend: "Ext.event.Dom",
    requires: [ "Ext.util.Point" ],
    constructor: function(e, t) {
        if (t) {
            this.set(t);
        }
        this.touchesMap = {};
        this.changedTouches = this.cloneTouches(e.changedTouches);
        this.touches = this.cloneTouches(e.touches);
        this.targetTouches = this.cloneTouches(e.targetTouches);
        return this.callParent([ e ]);
    },
    clone: function() {
        return new this.self(this);
    },
    setTargets: function(e) {
        this.doSetTargets(this.changedTouches, e);
        this.doSetTargets(this.touches, e);
        this.doSetTargets(this.targetTouches, e);
    },
    doSetTargets: function(e, t) {
        var i, n, r, s, a;
        for (i = 0, n = e.length; i < n; i++) {
            r = e[i];
            s = r.identifier;
            a = t[s];
            if (a) {
                r.targets = a;
            }
        }
    },
    cloneTouches: function(e) {
        var t = this.touchesMap, i = [], n = null, r, s, a, o;
        for (r = 0, s = e.length; r < s; r++) {
            a = e[r];
            o = a.identifier;
            if (n !== null && o === n) {
                o++;
            }
            n = o;
            if (!t[o]) {
                t[o] = {
                    pageX: a.pageX,
                    pageY: a.pageY,
                    identifier: o,
                    target: a.target,
                    timeStamp: a.timeStamp,
                    point: Ext.util.Point.fromTouch(a),
                    targets: a.targets
                };
            }
            i[r] = t[o];
        }
        return i;
    }
});

Ext.define("Ext.event.publisher.TouchGesture", {
    extend: "Ext.event.publisher.Dom",
    requires: [ "Ext.util.Point", "Ext.event.Touch" ],
    handledEvents: [ "touchstart", "touchmove", "touchend", "touchcancel" ],
    moveEventName: "touchmove",
    config: {
        moveThrottle: 1,
        buffering: {
            enabled: false,
            interval: 10
        },
        recognizers: {}
    },
    currentTouchesCount: 0,
    constructor: function(e) {
        this.processEvents = Ext.Function.bind(this.processEvents, this);
        this.eventProcessors = {
            touchstart: this.onTouchStart,
            touchmove: this.onTouchMove,
            touchend: this.onTouchEnd,
            touchcancel: this.onTouchEnd
        };
        this.eventToRecognizerMap = {};
        this.activeRecognizers = [];
        this.currentRecognizers = [];
        this.currentTargets = {};
        this.currentTouches = {};
        this.buffer = [];
        this.initConfig(e);
        return this.callParent();
    },
    applyBuffering: function(e) {
        if (e.enabled === true) {
            this.bufferTimer = setInterval(this.processEvents, e.interval);
        } else {
            clearInterval(this.bufferTimer);
        }
        return e;
    },
    applyRecognizers: function(e) {
        var t, i;
        for (t in e) {
            if (e.hasOwnProperty(t)) {
                i = e[t];
                if (i) {
                    this.registerRecognizer(i);
                }
            }
        }
        return e;
    },
    handles: function(e) {
        return this.callParent(arguments) || this.eventToRecognizerMap.hasOwnProperty(e);
    },
    doesEventBubble: function() {
        return true;
    },
    eventLogs: [],
    onEvent: function(e) {
        var t = this.getBuffering();
        e = new Ext.event.Touch(e);
        if (t.enabled) {
            this.buffer.push(e);
        } else {
            this.processEvent(e);
        }
    },
    processEvents: function() {
        var e = this.buffer, t = e.length, i = [], n, r, s;
        if (t > 0) {
            n = e.slice(0);
            e.length = 0;
            for (s = 0; s < t; s++) {
                r = n[s];
                if (r.type === this.moveEventName) {
                    i.push(r);
                } else {
                    if (i.length > 0) {
                        this.processEvent(this.mergeEvents(i));
                        i.length = 0;
                    }
                    this.processEvent(r);
                }
            }
            if (i.length > 0) {
                this.processEvent(this.mergeEvents(i));
                i.length = 0;
            }
        }
    },
    mergeEvents: function(e) {
        var t = [], i = e.length, n, r, s;
        s = e[i - 1];
        if (i === 1) {
            return s;
        }
        for (n = 0; n < i; n++) {
            r = e[n];
            t.push(r.changedTouches);
        }
        s.changedTouches = this.mergeTouchLists(t);
        return s;
    },
    mergeTouchLists: function(e) {
        var t = {}, i = [], n, r, s, a, o, l, u;
        for (n = 0, r = e.length; n < r; n++) {
            s = e[n];
            for (a = 0, o = s.length; a < o; a++) {
                l = s[a];
                u = l.identifier;
                t[u] = l;
            }
        }
        for (u in t) {
            if (t.hasOwnProperty(u)) {
                i.push(t[u]);
            }
        }
        return i;
    },
    registerRecognizer: function(e) {
        var t = this.eventToRecognizerMap, i = this.activeRecognizers, n = e.getHandledEvents(), r, s, a;
        e.setOnRecognized(this.onRecognized);
        e.setCallbackScope(this);
        for (r = 0, s = n.length; r < s; r++) {
            a = n[r];
            t[a] = e;
        }
        i.push(e);
        return this;
    },
    onRecognized: function(e, t, i, n) {
        var r = [], s = i.length, a, o, l;
        if (s === 1) {
            return this.publish(e, i[0].targets, t, n);
        }
        for (o = 0; o < s; o++) {
            l = i[o];
            r.push(l.targets);
        }
        a = this.getCommonTargets(r);
        this.publish(e, a, t, n);
    },
    publish: function(e, t, i, n) {
        i.set(n);
        return this.callParent([ e, t, i ]);
    },
    getCommonTargets: function(e) {
        var t = e[0], i = e.length;
        if (i === 1) {
            return t;
        }
        var n = [], r = 1, s, a, o;
        while (true) {
            s = t[t.length - r];
            if (!s) {
                return n;
            }
            for (o = 1; o < i; o++) {
                a = e[o];
                if (a[a.length - r] !== s) {
                    return n;
                }
            }
            n.unshift(s);
            r++;
        }
        return n;
    },
    invokeRecognizers: function(e, t) {
        var i = this.activeRecognizers, n = i.length, r, s;
        if (e === "onStart") {
            for (r = 0; r < n; r++) {
                i[r].isActive = true;
            }
        }
        for (r = 0; r < n; r++) {
            s = i[r];
            if (s.isActive && s[e].call(s, t) === false) {
                s.isActive = false;
            }
        }
    },
    getActiveRecognizers: function() {
        return this.activeRecognizers;
    },
    processEvent: function(e) {
        this.eventProcessors[e.type].call(this, e);
    },
    onTouchStart: function(e) {
        var t = this.currentTargets, i = this.currentTouches, n = this.currentTouchesCount, r = {}, s = e.changedTouches, a = s.length, o = e.touches, l = o.length, u, c, f, d;
        n += a;
        if (n > l) {
            for (u = 0; u < l; u++) {
                c = o[u];
                f = c.identifier;
                r[f] = true;
            }
            if (!Ext.os.is.Android3 && !Ext.os.is.Android4) {
                for (f in i) {
                    if (i.hasOwnProperty(f)) {
                        if (!r[f]) {
                            n--;
                            d = e.clone();
                            c = i[f];
                            c.targets = this.getBubblingTargets(this.getElementTarget(c.target));
                            d.changedTouches = [ c ];
                            this.onTouchEnd(d);
                        }
                    }
                }
            }
            if (Ext.os.is.Android2 && n > l) {
                return;
            }
        }
        for (u = 0; u < a; u++) {
            c = s[u];
            f = c.identifier;
            if (!i.hasOwnProperty(f)) {
                this.currentTouchesCount++;
            }
            i[f] = c;
            t[f] = this.getBubblingTargets(this.getElementTarget(c.target));
        }
        e.setTargets(t);
        for (u = 0; u < a; u++) {
            c = s[u];
            this.publish("touchstart", c.targets, e, {
                touch: c
            });
        }
        if (!this.isStarted) {
            this.isStarted = true;
            this.invokeRecognizers("onStart", e);
        }
        this.invokeRecognizers("onTouchStart", e);
    },
    onTouchMove: function(e) {
        if (!this.isStarted) {
            return;
        }
        var t = this.currentTargets, i = this.currentTouches, n = this.getMoveThrottle(), r = e.changedTouches, s = 0, a, o, l, u, c, f;
        e.setTargets(t);
        for (a = 0, o = r.length; a < o; a++) {
            l = r[a];
            f = l.identifier;
            u = l.point;
            c = i[f].point;
            if (n && u.isCloseTo(c, n)) {
                s++;
                continue;
            }
            i[f] = l;
            this.publish("touchmove", l.targets, e, {
                touch: l
            });
        }
        if (s < o) {
            this.invokeRecognizers("onTouchMove", e);
        }
    },
    onTouchEnd: function(e) {
        if (!this.isStarted) {
            return;
        }
        var t = this.currentTargets, i = this.currentTouches, n = e.changedTouches, r = n.length, s, a, o, l;
        e.setTargets(t);
        this.currentTouchesCount -= r;
        s = this.currentTouchesCount === 0;
        if (s) {
            this.isStarted = false;
        }
        for (o = 0; o < r; o++) {
            l = n[o];
            a = l.identifier;
            delete i[a];
            delete t[a];
            this.publish("touchend", l.targets, e, {
                touch: l
            });
        }
        this.invokeRecognizers("onTouchEnd", e);
        if (s) {
            this.invokeRecognizers("onEnd", e);
        }
    }
}, function() {
    if (!Ext.feature.has.Touch) {
        this.override({
            moveEventName: "mousemove",
            map: {
                mouseToTouch: {
                    mousedown: "touchstart",
                    mousemove: "touchmove",
                    mouseup: "touchend"
                },
                touchToMouse: {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup"
                }
            },
            attachListener: function(e) {
                e = this.map.touchToMouse[e];
                if (!e) {
                    return;
                }
                return this.callOverridden([ e ]);
            },
            lastEventType: null,
            onEvent: function(e) {
                if ("button" in e && e.button !== 0) {
                    return;
                }
                var t = e.type, i = [ e ];
                if (t === "mousedown" && this.lastEventType && this.lastEventType !== "mouseup") {
                    var n = document.createEvent("MouseEvent");
                    n.initMouseEvent("mouseup", e.bubbles, e.cancelable, document.defaultView, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.metaKey, e.button, e.relatedTarget);
                    this.onEvent(n);
                }
                if (t !== "mousemove") {
                    this.lastEventType = t;
                }
                e.identifier = 1;
                e.touches = t !== "mouseup" ? i : [];
                e.targetTouches = t !== "mouseup" ? i : [];
                e.changedTouches = i;
                return this.callOverridden([ e ]);
            },
            processEvent: function(e) {
                this.eventProcessors[this.map.mouseToTouch[e.type]].call(this, e);
            }
        });
    }
});

Ext.define("Ext.event.recognizer.Recognizer", {
    mixins: [ "Ext.mixin.Identifiable" ],
    handledEvents: [],
    config: {
        onRecognized: Ext.emptyFn,
        onFailed: Ext.emptyFn,
        callbackScope: null
    },
    constructor: function(e) {
        this.initConfig(e);
        return this;
    },
    getHandledEvents: function() {
        return this.handledEvents;
    },
    onStart: Ext.emptyFn,
    onEnd: Ext.emptyFn,
    fail: function() {
        this.getOnFailed().apply(this.getCallbackScope(), arguments);
        return false;
    },
    fire: function() {
        this.getOnRecognized().apply(this.getCallbackScope(), arguments);
    }
});

Ext.define("Ext.event.recognizer.Touch", {
    extend: "Ext.event.recognizer.Recognizer",
    onTouchStart: Ext.emptyFn,
    onTouchMove: Ext.emptyFn,
    onTouchEnd: Ext.emptyFn
});

Ext.define("Ext.event.recognizer.SingleTouch", {
    extend: "Ext.event.recognizer.Touch",
    inheritableStatics: {
        NOT_SINGLE_TOUCH: 1,
        TOUCH_MOVED: 2
    },
    onTouchStart: function(e) {
        if (e.touches.length > 1) {
            return this.fail(this.self.NOT_SINGLE_TOUCH);
        }
    }
});

Ext.define("Ext.event.recognizer.Drag", {
    extend: "Ext.event.recognizer.SingleTouch",
    isStarted: false,
    startPoint: null,
    previousPoint: null,
    lastPoint: null,
    handledEvents: [ "dragstart", "drag", "dragend" ],
    onTouchStart: function(e) {
        var t, i;
        if (this.callParent(arguments) === false) {
            if (this.isStarted && this.lastMoveEvent !== null) {
                this.onTouchEnd(this.lastMoveEvent);
            }
            return false;
        }
        this.startTouches = t = e.changedTouches;
        this.startTouch = i = t[0];
        this.startPoint = i.point;
    },
    onTouchMove: function(e) {
        var t = e.changedTouches, i = t[0], n = i.point, r = e.time;
        if (this.lastPoint) {
            this.previousPoint = this.lastPoint;
        }
        if (this.lastTime) {
            this.previousTime = this.lastTime;
        }
        this.lastTime = r;
        this.lastPoint = n;
        this.lastMoveEvent = e;
        if (!this.isStarted) {
            this.isStarted = true;
            this.startTime = r;
            this.previousTime = r;
            this.previousPoint = this.startPoint;
            this.fire("dragstart", e, this.startTouches, this.getInfo(e, this.startTouch));
        } else {
            this.fire("drag", e, t, this.getInfo(e, i));
        }
    },
    onTouchEnd: function(e) {
        if (this.isStarted) {
            var t = e.changedTouches, i = t[0], n = i.point;
            this.isStarted = false;
            this.lastPoint = n;
            this.fire("dragend", e, t, this.getInfo(e, i));
            this.startTime = 0;
            this.previousTime = 0;
            this.lastTime = 0;
            this.startPoint = null;
            this.previousPoint = null;
            this.lastPoint = null;
            this.lastMoveEvent = null;
        }
    },
    getInfo: function(e, t) {
        var i = e.time, n = this.startPoint, r = this.previousPoint, s = this.startTime, a = this.previousTime, o = this.lastPoint, l = o.x - n.x, u = o.y - n.y, c = {
            touch: t,
            startX: n.x,
            startY: n.y,
            previousX: r.x,
            previousY: r.y,
            pageX: o.x,
            pageY: o.y,
            deltaX: l,
            deltaY: u,
            absDeltaX: Math.abs(l),
            absDeltaY: Math.abs(u),
            previousDeltaX: o.x - r.x,
            previousDeltaY: o.y - r.y,
            time: i,
            startTime: s,
            previousTime: a,
            deltaTime: i - s,
            previousDeltaTime: i - a
        };
        return c;
    }
});

Ext.define("Ext.event.recognizer.Tap", {
    handledEvents: [ "tap" ],
    extend: "Ext.event.recognizer.SingleTouch",
    onTouchMove: function() {
        return this.fail(this.self.TOUCH_MOVED);
    },
    onTouchEnd: function(e) {
        var t = e.changedTouches[0];
        this.fire("tap", e, [ t ]);
    }
}, function() {
    this.override({
        handledEvents: [ "tap", "tapstart", "tapcancel" ],
        onTouchStart: function(e) {
            if (this.callOverridden(arguments) === false) {
                return false;
            }
            this.fire("tapstart", e, [ e.changedTouches[0] ]);
        },
        onTouchMove: function(e) {
            this.fire("tapcancel", e, [ e.changedTouches[0] ]);
            return this.callOverridden(arguments);
        }
    });
});

Ext.define("Ext.event.recognizer.DoubleTap", {
    extend: "Ext.event.recognizer.SingleTouch",
    inheritableStatics: {
        DIFFERENT_TARGET: 3
    },
    config: {
        maxDuration: 300
    },
    handledEvents: [ "singletap", "doubletap" ],
    singleTapTimer: null,
    startTime: 0,
    lastTapTime: 0,
    onTouchStart: function(e) {
        if (this.callParent(arguments) === false) {
            return false;
        }
        this.startTime = e.time;
        clearTimeout(this.singleTapTimer);
    },
    onTouchMove: function() {
        return this.fail(this.self.TOUCH_MOVED);
    },
    onEnd: function(e) {
        var t = this, i = this.getMaxDuration(), n = e.changedTouches[0], r = e.time, s = e.target, a = this.lastTapTime, o = this.lastTarget, l;
        this.lastTapTime = r;
        this.lastTarget = s;
        if (a) {
            l = r - a;
            if (l <= i) {
                if (s !== o) {
                    return this.fail(this.self.DIFFERENT_TARGET);
                }
                this.lastTarget = null;
                this.lastTapTime = 0;
                this.fire("doubletap", e, [ n ], {
                    touch: n,
                    duration: l
                });
                return;
            }
        }
        if (r - this.startTime > i) {
            this.fireSingleTap(e, n);
        } else {
            this.singleTapTimer = setTimeout(function() {
                t.fireSingleTap(e, n);
            }, i);
        }
    },
    fireSingleTap: function(e, t) {
        this.fire("singletap", e, [ t ], {
            touch: t
        });
    }
});

Ext.define("Ext.event.recognizer.LongPress", {
    extend: "Ext.event.recognizer.SingleTouch",
    inheritableStatics: {
        DURATION_NOT_ENOUGH: 32
    },
    config: {
        minDuration: 1e3
    },
    handledEvents: [ "longpress" ],
    fireLongPress: function(e) {
        var t = e.changedTouches[0];
        this.fire("longpress", e, [ t ], {
            touch: t,
            duration: this.getMinDuration()
        });
        this.isLongPress = true;
    },
    onTouchStart: function(e) {
        var t = this;
        if (this.callParent(arguments) === false) {
            return false;
        }
        this.isLongPress = false;
        this.timer = setTimeout(function() {
            t.fireLongPress(e);
        }, this.getMinDuration());
    },
    onTouchMove: function() {
        return this.fail(this.self.TOUCH_MOVED);
    },
    onTouchEnd: function() {
        if (!this.isLongPress) {
            return this.fail(this.self.DURATION_NOT_ENOUGH);
        }
    },
    fail: function() {
        clearTimeout(this.timer);
        return this.callParent(arguments);
    }
}, function() {
    this.override({
        handledEvents: [ "longpress", "taphold" ],
        fire: function(e) {
            if (e === "longpress") {
                var t = Array.prototype.slice.call(arguments);
                t[0] = "taphold";
                this.fire.apply(this, t);
            }
            return this.callOverridden(arguments);
        }
    });
});

Ext.define("Ext.event.recognizer.Swipe", {
    extend: "Ext.event.recognizer.SingleTouch",
    handledEvents: [ "swipe" ],
    inheritableStatics: {
        MAX_OFFSET_EXCEEDED: 16,
        MAX_DURATION_EXCEEDED: 17,
        DISTANCE_NOT_ENOUGH: 18
    },
    config: {
        minDistance: 80,
        maxOffset: 35,
        maxDuration: 1e3
    },
    onTouchStart: function(e) {
        if (this.callParent(arguments) === false) {
            return false;
        }
        var t = e.changedTouches[0];
        this.startTime = e.time;
        this.isHorizontal = true;
        this.isVertical = true;
        this.startX = t.pageX;
        this.startY = t.pageY;
    },
    onTouchMove: function(e) {
        var t = e.changedTouches[0], i = t.pageX, n = t.pageY, r = Math.abs(i - this.startX), s = Math.abs(n - this.startY), a = e.time;
        if (a - this.startTime > this.getMaxDuration()) {
            return this.fail(this.self.MAX_DURATION_EXCEEDED);
        }
        if (this.isVertical && r > this.getMaxOffset()) {
            this.isVertical = false;
        }
        if (this.isHorizontal && s > this.getMaxOffset()) {
            this.isHorizontal = false;
        }
        if (!this.isHorizontal && !this.isVertical) {
            return this.fail(this.self.MAX_OFFSET_EXCEEDED);
        }
    },
    onTouchEnd: function(e) {
        if (this.onTouchMove(e) === false) {
            return false;
        }
        var t = e.changedTouches[0], i = t.pageX, n = t.pageY, r = i - this.startX, s = n - this.startY, a = Math.abs(r), o = Math.abs(s), l = this.getMinDistance(), u = e.time - this.startTime, c, f;
        if (this.isVertical && o < l) {
            this.isVertical = false;
        }
        if (this.isHorizontal && a < l) {
            this.isHorizontal = false;
        }
        if (this.isHorizontal) {
            c = r < 0 ? "left" : "right";
            f = a;
        } else if (this.isVertical) {
            c = s < 0 ? "up" : "down";
            f = o;
        } else {
            return this.fail(this.self.DISTANCE_NOT_ENOUGH);
        }
        this.fire("swipe", e, [ t ], {
            touch: t,
            direction: c,
            distance: f,
            duration: u
        });
    }
});

Ext.define("Ext.event.recognizer.HorizontalSwipe", {
    extend: "Ext.event.recognizer.Swipe",
    handledEvents: [ "swipe" ],
    onTouchStart: function(e) {
        if (this.callParent(arguments) === false) {
            return false;
        }
        var t = e.changedTouches[0];
        this.startTime = e.time;
        this.startX = t.pageX;
        this.startY = t.pageY;
    },
    onTouchMove: function(e) {
        var t = e.changedTouches[0], i = t.pageY, n = Math.abs(i - this.startY), r = e.time, s = this.getMaxDuration(), a = this.getMaxOffset();
        if (r - this.startTime > s) {
            return this.fail(this.self.MAX_DURATION_EXCEEDED);
        }
        if (n > a) {
            return this.fail(this.self.MAX_OFFSET_EXCEEDED);
        }
    },
    onTouchEnd: function(e) {
        if (this.onTouchMove(e) !== false) {
            var t = e.changedTouches[0], i = t.pageX, n = i - this.startX, r = Math.abs(n), s = e.time - this.startTime, a = this.getMinDistance(), o;
            if (r < a) {
                return this.fail(this.self.DISTANCE_NOT_ENOUGH);
            }
            o = n < 0 ? "left" : "right";
            this.fire("swipe", e, [ t ], {
                touch: t,
                direction: o,
                distance: r,
                duration: s
            });
        }
    }
});

Ext.define("Ext.event.recognizer.MultiTouch", {
    extend: "Ext.event.recognizer.Touch",
    requiredTouchesCount: 2,
    isTracking: false,
    isStarted: false,
    onTouchStart: function(e) {
        var t = this.requiredTouchesCount, i = e.touches, n = i.length;
        if (n === t) {
            this.start(e);
        } else if (n > t) {
            this.end(e);
        }
    },
    onTouchEnd: function(e) {
        this.end(e);
    },
    start: function() {
        if (!this.isTracking) {
            this.isTracking = true;
            this.isStarted = false;
        }
    },
    end: function(e) {
        if (this.isTracking) {
            this.isTracking = false;
            if (this.isStarted) {
                this.isStarted = false;
                this.fireEnd(e);
            }
        }
    }
});

Ext.define("Ext.event.recognizer.Pinch", {
    extend: "Ext.event.recognizer.MultiTouch",
    requiredTouchesCount: 2,
    handledEvents: [ "pinchstart", "pinch", "pinchend" ],
    startDistance: 0,
    lastTouches: null,
    onTouchMove: function(e) {
        if (!this.isTracking) {
            return;
        }
        var t = Array.prototype.slice.call(e.touches), i, n, r;
        i = t[0].point;
        n = t[1].point;
        r = i.getDistanceTo(n);
        if (r === 0) {
            return;
        }
        if (!this.isStarted) {
            this.isStarted = true;
            this.startDistance = r;
            this.fire("pinchstart", e, t, {
                touches: t,
                distance: r,
                scale: 1
            });
        } else {
            this.fire("pinch", e, t, {
                touches: t,
                distance: r,
                scale: r / this.startDistance
            });
        }
        this.lastTouches = t;
    },
    fireEnd: function(e) {
        this.fire("pinchend", e, this.lastTouches);
    },
    fail: function() {
        return this.callParent(arguments);
    }
});

Ext.define("Ext.event.recognizer.Rotate", {
    extend: "Ext.event.recognizer.MultiTouch",
    requiredTouchesCount: 2,
    handledEvents: [ "rotatestart", "rotate", "rotateend" ],
    startAngle: 0,
    lastTouches: null,
    lastAngle: null,
    onTouchMove: function(e) {
        if (!this.isTracking) {
            return;
        }
        var t = Array.prototype.slice.call(e.touches), i = this.lastAngle, n, r, s, a, o, l;
        n = t[0].point;
        r = t[1].point;
        s = n.getAngleTo(r);
        if (i !== null) {
            l = Math.abs(i - s);
            a = s + 360;
            o = s - 360;
            if (Math.abs(a - i) < l) {
                s = a;
            } else if (Math.abs(o - i) < l) {
                s = o;
            }
        }
        this.lastAngle = s;
        if (!this.isStarted) {
            this.isStarted = true;
            this.startAngle = s;
            this.fire("rotatestart", e, t, {
                touches: t,
                angle: s,
                rotation: 0
            });
        } else {
            this.fire("rotate", e, t, {
                touches: t,
                angle: s,
                rotation: s - this.startAngle
            });
        }
        this.lastTouches = t;
    },
    fireEnd: function(e) {
        this.lastAngle = null;
        this.fire("rotateend", e, this.lastTouches);
    }
});

Ext.define("Ext.ComponentQuery", {
    singleton: true,
    uses: [ "Ext.ComponentManager" ]
}, function() {
    var e = this, t = [ "var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;" ].join(""), i = function(e, t) {
        return t.method.apply(this, [ e ].concat(t.args));
    }, n = function(e, t) {
        var i = [], n = 0, r = e.length, s, a = t !== ">";
        for (;n < r; n++) {
            s = e[n];
            if (s.getRefItems) {
                i = i.concat(s.getRefItems(a));
            }
        }
        return i;
    }, r = function(e) {
        var t = [], i = 0, n = e.length, r;
        for (;i < n; i++) {
            r = e[i];
            while (!!(r = r.ownerCt || r.floatParent)) {
                t.push(r);
            }
        }
        return t;
    }, s = function(e, t, i) {
        if (t === "*") {
            return e.slice();
        } else {
            var n = [], r = 0, s = e.length, a;
            for (;r < s; r++) {
                a = e[r];
                if (a.isXType(t, i)) {
                    n.push(a);
                }
            }
            return n;
        }
    }, a = function(e, t) {
        var i = Ext.Array, n = [], r = 0, s = e.length, a;
        for (;r < s; r++) {
            a = e[r];
            if (a.el ? a.el.hasCls(t) : i.contains(a.initCls(), t)) {
                n.push(a);
            }
        }
        return n;
    }, o = function(e, t, i, n) {
        var r = [], s = 0, a = e.length, o, l, u;
        for (;s < a; s++) {
            o = e[s];
            l = Ext.Class.getConfigNameMap(t).get;
            if (o[l]) {
                u = o[l]();
                if (!n ? !!u : String(u) === n) {
                    r.push(o);
                }
            } else if (o.config && o.config[t]) {
                if (!n ? !!o.config[t] : String(o.config[t]) === n) {
                    r.push(o);
                }
            } else if (!n ? !!o[t] : String(o[t]) === n) {
                r.push(o);
            }
        }
        return r;
    }, l = function(e, t) {
        var i = [], n = 0, r = e.length, s;
        for (;n < r; n++) {
            s = e[n];
            if (s.getId() === t || s.getItemId() === t) {
                i.push(s);
            }
        }
        return i;
    }, u = function(t, i, n) {
        return e.pseudos[i](t, n);
    }, c = /^(\s?([>\^])\s?|\s|$)/, f = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/, d = [ {
        re: /^\.([\w\-]+)(?:\((true|false)\))?/,
        method: s
    }, {
        re: /^(?:[\[](?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]])/,
        method: o
    }, {
        re: /^#([\w\-]+)/,
        method: l
    }, {
        re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
        method: u
    }, {
        re: /^(?:\{([^\}]+)\})/,
        method: t
    } ];
    e.Query = Ext.extend(Object, {
        constructor: function(e) {
            e = e || {};
            Ext.apply(this, e);
        },
        execute: function(e) {
            var t = this.operations, s = 0, a = t.length, o, l;
            if (!e) {
                l = Ext.ComponentManager.all.getArray();
            } else if (Ext.isArray(e)) {
                l = e;
            }
            for (;s < a; s++) {
                o = t[s];
                if (o.mode === "^") {
                    l = r(l || [ e ]);
                } else if (o.mode) {
                    l = n(l || [ e ], o.mode);
                } else {
                    l = i(l || n([ e ]), o);
                }
                if (s === a - 1) {
                    return l;
                }
            }
            return [];
        },
        is: function(e) {
            var t = this.operations, n = Ext.isArray(e) ? e : [ e ], r = n.length, s = t[t.length - 1], a, o;
            n = i(n, s);
            if (n.length === r) {
                if (t.length > 1) {
                    for (o = 0, a = n.length; o < a; o++) {
                        if (Ext.Array.indexOf(this.execute(), n[o]) === -1) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        }
    });
    Ext.apply(this, {
        cache: {},
        pseudos: {
            not: function(e, t) {
                var i = Ext.ComponentQuery, n = 0, r = e.length, s = [], a = -1, o;
                for (;n < r; ++n) {
                    o = e[n];
                    if (!i.is(o, t)) {
                        s[++a] = o;
                    }
                }
                return s;
            }
        },
        query: function(e, t) {
            var i = e.split(","), n = i.length, r = 0, s = [], a = [], o = {}, l, u, c;
            for (;r < n; r++) {
                e = Ext.String.trim(i[r]);
                l = this.parse(e);
                s = s.concat(l.execute(t));
            }
            if (n > 1) {
                u = s.length;
                for (r = 0; r < u; r++) {
                    c = s[r];
                    if (!o[c.id]) {
                        a.push(c);
                        o[c.id] = true;
                    }
                }
                s = a;
            }
            return s;
        },
        is: function(e, t) {
            if (!t) {
                return true;
            }
            var i = this.cache[t];
            if (!i) {
                this.cache[t] = i = this.parse(t);
            }
            return i.is(e);
        },
        parse: function(t) {
            var i = [], n = d.length, r, o, u, h, g, p, m, x;
            while (t && r !== t) {
                r = t;
                o = t.match(f);
                if (o) {
                    u = o[1];
                    if (u === "#") {
                        i.push({
                            method: l,
                            args: [ Ext.String.trim(o[2]) ]
                        });
                    } else if (u === ".") {
                        i.push({
                            method: a,
                            args: [ Ext.String.trim(o[2]) ]
                        });
                    } else {
                        i.push({
                            method: s,
                            args: [ Ext.String.trim(o[2]), Boolean(o[3]) ]
                        });
                    }
                    t = t.replace(o[0], "");
                }
                while (!(h = t.match(c))) {
                    for (p = 0; t && p < n; p++) {
                        m = d[p];
                        g = t.match(m.re);
                        x = m.method;
                        if (g) {
                            i.push({
                                method: Ext.isString(m.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [ x ].concat(g.slice(1)))) : m.method,
                                args: g.slice(1)
                            });
                            t = t.replace(g[0], "");
                            break;
                        }
                        if (p === n - 1) {
                            Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
                        }
                    }
                }
                if (h[1]) {
                    i.push({
                        mode: h[2] || h[1]
                    });
                    t = t.replace(h[0], "");
                }
            }
            return new e.Query({
                operations: i
            });
        }
    });
});

Ext.define("Ext.ComponentManager", {
    alternateClassName: "Ext.ComponentMgr",
    singleton: true,
    constructor: function() {
        var e = {};
        this.all = {
            map: e,
            getArray: function() {
                var t = [], i;
                for (i in e) {
                    t.push(e[i]);
                }
                return t;
            }
        };
        this.map = e;
    },
    register: function(e) {
        var t = e.getId();
        if (this.map[t]) {
            Ext.Logger.warn("Registering a component with a id (`" + t + "`) which has already been used. Please ensure the existing component has been destroyed (`Ext.Component#destroy()`.");
        }
        this.map[e.getId()] = e;
    },
    unregister: function(e) {
        delete this.map[e.getId()];
    },
    isRegistered: function(e) {
        return this.map[e] !== undefined;
    },
    get: function(e) {
        return this.map[e];
    },
    create: function(e, t) {
        if (e.isComponent) {
            return e;
        } else if (Ext.isString(e)) {
            return Ext.createByAlias("widget." + e);
        } else {
            var i = e.xtype || t;
            return Ext.createByAlias("widget." + i, e);
        }
    },
    registerType: Ext.emptyFn
});

Ext.define("Ext.mixin.Mixin", {
    onClassExtended: function(e, t) {
        var i = t.mixinConfig, n, r, s;
        if (i) {
            n = e.superclass.mixinConfig;
            if (n) {
                i = t.mixinConfig = Ext.merge({}, n, i);
            }
            t.mixinId = i.id;
            r = i.beforeHooks;
            s = i.hooks || i.afterHooks;
            if (r || s) {
                Ext.Function.interceptBefore(t, "onClassMixedIn", function(e) {
                    var t = this.prototype;
                    if (r) {
                        Ext.Object.each(r, function(i, n) {
                            e.override(n, function() {
                                if (t[i].apply(this, arguments) !== false) {
                                    return this.callOverridden(arguments);
                                }
                            });
                        });
                    }
                    if (s) {
                        Ext.Object.each(s, function(i, n) {
                            e.override(n, function() {
                                var e = this.callOverridden(arguments);
                                t[i].apply(this, arguments);
                                return e;
                            });
                        });
                    }
                });
            }
        }
    }
});

Ext.define("Ext.behavior.Behavior", {
    constructor: function(e) {
        this.component = e;
        e.on("destroy", "onComponentDestroy", this);
    },
    onComponentDestroy: Ext.emptyFn
});

Ext.define("Ext.mixin.Observable", {
    requires: [ "Ext.event.Dispatcher" ],
    extend: "Ext.mixin.Mixin",
    mixins: [ "Ext.mixin.Identifiable" ],
    mixinConfig: {
        id: "observable",
        hooks: {
            destroy: "destroy"
        }
    },
    alternateClassName: "Ext.util.Observable",
    isObservable: true,
    observableType: "observable",
    validIdRegex: /^([\w\-]+)$/,
    observableIdPrefix: "#",
    listenerOptionsRegex: /^(?:delegate|single|delay|buffer|args|prepend)$/,
    config: {
        listeners: null,
        bubbleEvents: null
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    applyListeners: function(e) {
        if (e) {
            this.addListener(e);
        }
    },
    applyBubbleEvents: function(e) {
        if (e) {
            this.enableBubble(e);
        }
    },
    getOptimizedObservableId: function() {
        return this.observableId;
    },
    getObservableId: function() {
        if (!this.observableId) {
            var e = this.getUniqueId();
            if (!e.match(this.validIdRegex)) {
                Ext.Logger.error("Invalid unique id of '" + e + "' for this object", this);
            }
            this.observableId = this.observableIdPrefix + e;
            this.getObservableId = this.getOptimizedObservableId;
        }
        return this.observableId;
    },
    getOptimizedEventDispatcher: function() {
        return this.eventDispatcher;
    },
    getEventDispatcher: function() {
        if (!this.eventDispatcher) {
            this.eventDispatcher = Ext.event.Dispatcher.getInstance();
            this.getEventDispatcher = this.getOptimizedEventDispatcher;
            this.getListeners();
            this.getBubbleEvents();
        }
        return this.eventDispatcher;
    },
    getManagedListeners: function(e, t) {
        var i = e.getUniqueId(), n = this.managedListeners;
        if (!n) {
            this.managedListeners = n = {};
        }
        if (!n[i]) {
            n[i] = {};
            e.doAddListener("destroy", "clearManagedListeners", this, {
                single: true,
                args: [ e ]
            });
        }
        if (!n[i][t]) {
            n[i][t] = [];
        }
        return n[i][t];
    },
    getUsedSelectors: function() {
        var e = this.usedSelectors;
        if (!e) {
            e = this.usedSelectors = [];
            e.$map = {};
        }
        return e;
    },
    fireEvent: function(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return this.doFireEvent(e, t);
    },
    fireAction: function(e, t, i, n, r, s) {
        var a = typeof i, o;
        if (t === undefined) {
            t = [];
        }
        if (a != "undefined") {
            o = {
                fn: i,
                isLateBinding: a == "string",
                scope: n || this,
                options: r || {},
                order: s
            };
        }
        return this.doFireEvent(e, t, o);
    },
    doFireEvent: function(e, t, i, n) {
        if (this.eventFiringSuspended) {
            return;
        }
        var r = this.getObservableId(), s = this.getEventDispatcher();
        return s.dispatchEvent(this.observableType, r, e, t, i, n);
    },
    doAddListener: function(e, t, i, n, r) {
        var s = i && i !== this && i.isIdentifiable, a = this.getUsedSelectors(), o = a.$map, l = this.getObservableId(), u, c, f;
        if (!n) {
            n = {};
        }
        if (!i) {
            i = this;
        }
        if (n.delegate) {
            f = n.delegate;
            l += " " + f;
        }
        if (!(l in o)) {
            o[l] = true;
            a.push(l);
        }
        u = this.addDispatcherListener(l, e, t, i, n, r);
        if (u && s) {
            c = this.getManagedListeners(i, e);
            c.push({
                delegate: f,
                scope: i,
                fn: t,
                order: r
            });
        }
        return u;
    },
    addDispatcherListener: function(e, t, i, n, r, s) {
        return this.getEventDispatcher().addListener(this.observableType, e, t, i, n, r, s);
    },
    doRemoveListener: function(e, t, i, n, r) {
        var s = i && i !== this && i.isIdentifiable, a = this.getObservableId(), o, l, u, c, f, d;
        if (n && n.delegate) {
            d = n.delegate;
            a += " " + d;
        }
        if (!i) {
            i = this;
        }
        o = this.removeDispatcherListener(a, e, t, i, r);
        if (o && s) {
            l = this.getManagedListeners(i, e);
            for (u = 0, c = l.length; u < c; u++) {
                f = l[u];
                if (f.fn === t && f.scope === i && f.delegate === d && f.order === r) {
                    l.splice(u, 1);
                    break;
                }
            }
        }
        return o;
    },
    removeDispatcherListener: function(e, t, i, n, r) {
        return this.getEventDispatcher().removeListener(this.observableType, e, t, i, n, r);
    },
    clearManagedListeners: function(e) {
        var t = this.managedListeners, i, n, r, s, a, o, l, u;
        if (!t) {
            return this;
        }
        if (e) {
            if (typeof e != "string") {
                i = e.getUniqueId();
            } else {
                i = e;
            }
            n = t[i];
            for (s in n) {
                if (n.hasOwnProperty(s)) {
                    r = n[s];
                    for (a = 0, o = r.length; a < o; a++) {
                        l = r[a];
                        u = {};
                        if (l.delegate) {
                            u.delegate = l.delegate;
                        }
                        if (this.doRemoveListener(s, l.fn, l.scope, u, l.order)) {
                            a--;
                            o--;
                        }
                    }
                }
            }
            delete t[i];
            return this;
        }
        for (i in t) {
            if (t.hasOwnProperty(i)) {
                this.clearManagedListeners(i);
            }
        }
    },
    changeListener: function(e, t, i, n, r, s) {
        var a, o, l, u, c, f, d, h, g, p;
        if (typeof i != "undefined") {
            if (typeof t != "string") {
                for (d = 0, h = t.length; d < h; d++) {
                    c = t[d];
                    e.call(this, c, i, n, r, s);
                }
                return this;
            }
            e.call(this, t, i, n, r, s);
        } else if (Ext.isArray(t)) {
            o = t;
            for (d = 0, h = o.length; d < h; d++) {
                g = o[d];
                e.call(this, g.event, g.fn, g.scope, g, g.order);
            }
        } else {
            l = this.listenerOptionsRegex;
            r = t;
            a = [];
            o = [];
            u = {};
            for (c in r) {
                f = r[c];
                if (c === "scope") {
                    n = f;
                    continue;
                } else if (c === "order") {
                    s = f;
                    continue;
                }
                if (!l.test(c)) {
                    p = typeof f;
                    if (p != "string" && p != "function") {
                        e.call(this, c, f.fn, f.scope || n, f, f.order || s);
                        continue;
                    }
                    a.push(c);
                    o.push(f);
                } else {
                    u[c] = f;
                }
            }
            for (d = 0, h = a.length; d < h; d++) {
                e.call(this, a[d], o[d], n, u, s);
            }
        }
        return this;
    },
    addListener: function(e, t, i, n, r) {
        return this.changeListener(this.doAddListener, e, t, i, n, r);
    },
    toggleListener: function(e, t, i, n, r, s) {
        return this.changeListener(e ? this.doAddListener : this.doRemoveListener, t, i, n, r, s);
    },
    addBeforeListener: function(e, t, i, n) {
        return this.addListener(e, t, i, n, "before");
    },
    addAfterListener: function(e, t, i, n) {
        return this.addListener(e, t, i, n, "after");
    },
    removeListener: function(e, t, i, n, r) {
        return this.changeListener(this.doRemoveListener, e, t, i, n, r);
    },
    removeBeforeListener: function(e, t, i, n) {
        return this.removeListener(e, t, i, n, "before");
    },
    removeAfterListener: function(e, t, i, n) {
        return this.removeListener(e, t, i, n, "after");
    },
    clearListeners: function() {
        var e = this.getUsedSelectors(), t = this.getEventDispatcher(), i, n, r;
        for (i = 0, n = e.length; i < n; i++) {
            r = e[i];
            t.clearListeners(this.observableType, r);
        }
    },
    hasListener: function(e) {
        return this.getEventDispatcher().hasListener(this.observableType, this.getObservableId(), e);
    },
    suspendEvents: function() {
        this.eventFiringSuspended = true;
    },
    resumeEvents: function() {
        this.eventFiringSuspended = false;
    },
    relayEvents: function(e, t, i) {
        var n, r, s, a;
        if (typeof i == "undefined") {
            i = "";
        }
        if (typeof t == "string") {
            t = [ t ];
        }
        if (Ext.isArray(t)) {
            for (n = 0, r = t.length; n < r; n++) {
                s = t[n];
                a = i + s;
                e.addListener(s, this.createEventRelayer(a), this);
            }
        } else {
            for (s in t) {
                if (t.hasOwnProperty(s)) {
                    a = i + t[s];
                    e.addListener(s, this.createEventRelayer(a), this);
                }
            }
        }
        return this;
    },
    relayEvent: function(e, t, i, n, r) {
        var s = typeof t, a = e[e.length - 1], o = a.getInfo().eventName, l;
        e = Array.prototype.slice.call(e, 0, -2);
        e[0] = this;
        if (s != "undefined") {
            l = {
                fn: t,
                scope: i || this,
                options: n || {},
                order: r,
                isLateBinding: s == "string"
            };
        }
        return this.doFireEvent(o, e, l, a);
    },
    createEventRelayer: function(e) {
        return function() {
            return this.doFireEvent(e, Array.prototype.slice.call(arguments, 0, -2));
        };
    },
    enableBubble: function(e) {
        var t = this.isBubblingEnabled, i, n, r;
        if (!t) {
            t = this.isBubblingEnabled = {};
        }
        if (typeof e == "string") {
            e = Ext.Array.clone(arguments);
        }
        for (i = 0, n = e.length; i < n; i++) {
            r = e[i];
            if (!t[r]) {
                t[r] = true;
                this.addListener(r, this.createEventBubbler(r), this);
            }
        }
    },
    createEventBubbler: function(e) {
        return function t() {
            var i = "getBubbleTarget" in this ? this.getBubbleTarget() : null;
            if (i && i !== this && i.isObservable) {
                i.fireAction(e, Array.prototype.slice.call(arguments, 0, -2), t, i, null, "after");
            }
        };
    },
    getBubbleTarget: function() {
        return false;
    },
    destroy: function() {
        if (this.observableId) {
            this.fireEvent("destroy", this);
            this.clearListeners();
            this.clearManagedListeners();
        }
    },
    addEvents: Ext.emptyFn
}, function() {
    this.createAlias({
        on: "addListener",
        un: "removeListener",
        onBefore: "addBeforeListener",
        onAfter: "addAfterListener",
        unBefore: "removeBeforeListener",
        unAfter: "removeAfterListener"
    });
    Ext.deprecateClassMethod(this, "addEvents", function() {}, "addEvents() is deprecated. It's no longer needed to add events before firing");
    Ext.deprecateClassMethod(this, "addManagedListener", function(e, t, i, n, r) {
        return e.addListener(t, i, n, r);
    }, "addManagedListener() / mon() is deprecated, simply use addListener() / on(). All listeners are now automatically managed where necessary.");
    Ext.deprecateClassMethod(this, "removeManagedListener", function(e, t, i, n) {
        return e.removeListener(t, i, n);
    }, "removeManagedListener() / mun() is deprecated, simply use removeListener() / un(). All listeners are now automatically managed where necessary.");
    this.createAlias({
        mon: "addManagedListener",
        mun: "removeManagedListener"
    });
});

Ext.define("Ext.XTemplateParser", {
    constructor: function(e) {
        Ext.apply(this, e);
    },
    doTpl: Ext.emptyFn,
    parse: function(e) {
        var t = this, i = e.length, n = {
            elseif: "elif"
        }, r = t.topRe, s = t.actionsRe, a, o, l, u, c, f, d, h, g, p, m, x;
        t.level = 0;
        t.stack = o = [];
        for (a = 0; a < i; a = p) {
            r.lastIndex = a;
            u = r.exec(e);
            if (!u) {
                t.doText(e.substring(a, i));
                break;
            }
            g = u.index;
            p = r.lastIndex;
            if (a < g) {
                t.doText(e.substring(a, g));
            }
            if (u[1]) {
                p = e.indexOf("%}", g + 2);
                t.doEval(e.substring(g + 2, p));
                p += 2;
            } else if (u[2]) {
                p = e.indexOf("]}", g + 2);
                t.doExpr(e.substring(g + 2, p));
                p += 2;
            } else if (u[3]) {
                t.doTag(u[3]);
            } else if (u[4]) {
                m = null;
                while ((h = s.exec(u[4])) !== null) {
                    l = h[2] || h[3];
                    if (l) {
                        l = Ext.String.htmlDecode(l);
                        c = h[1];
                        c = n[c] || c;
                        m = m || {};
                        f = m[c];
                        if (typeof f == "string") {
                            m[c] = [ f, l ];
                        } else if (f) {
                            m[c].push(l);
                        } else {
                            m[c] = l;
                        }
                    }
                }
                if (!m) {
                    if (t.elseRe.test(u[4])) {
                        t.doElse();
                    } else if (t.defaultRe.test(u[4])) {
                        t.doDefault();
                    } else {
                        t.doTpl();
                        o.push({
                            type: "tpl"
                        });
                    }
                } else if (m["if"]) {
                    t.doIf(m["if"], m);
                    o.push({
                        type: "if"
                    });
                } else if (m["switch"]) {
                    t.doSwitch(m["switch"], m);
                    o.push({
                        type: "switch"
                    });
                } else if (m["case"]) {
                    t.doCase(m["case"], m);
                } else if (m["elif"]) {
                    t.doElseIf(m["elif"], m);
                } else if (m["for"]) {
                    ++t.level;
                    if (x = t.propRe.exec(u[4])) {
                        m.propName = x[1] || x[2];
                    }
                    t.doFor(m["for"], m);
                    o.push({
                        type: "for",
                        actions: m
                    });
                } else if (m.exec) {
                    t.doExec(m.exec, m);
                    o.push({
                        type: "exec",
                        actions: m
                    });
                }
            } else if (u[0].length === 5) {
                o.push({
                    type: "tpl"
                });
            } else {
                d = o.pop();
                t.doEnd(d.type, d.actions);
                if (d.type == "for") {
                    --t.level;
                }
            }
        }
    },
    topRe: /(?:(\{\%)|(\{\[)|\{([^{}]*)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
    actionsRe: /\s*(elif|elseif|if|for|exec|switch|case|eval)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
    propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
    defaultRe: /^\s*default\s*$/,
    elseRe: /^\s*else\s*$/
});

Ext.define("Ext.fx.easing.Abstract", {
    config: {
        startTime: 0,
        startValue: 0
    },
    isEasing: true,
    isEnded: false,
    constructor: function(e) {
        this.initConfig(e);
        return this;
    },
    applyStartTime: function(e) {
        if (!e) {
            e = Ext.Date.now();
        }
        return e;
    },
    updateStartTime: function(e) {
        this.reset();
    },
    reset: function() {
        this.isEnded = false;
    },
    getValue: Ext.emptyFn
});

Ext.define("Ext.mixin.Traversable", {
    extend: "Ext.mixin.Mixin",
    mixinConfig: {
        id: "traversable"
    },
    setParent: function(e) {
        this.parent = e;
        return this;
    },
    hasParent: function() {
        return Boolean(this.parent);
    },
    getParent: function() {
        return this.parent;
    },
    getAncestors: function() {
        var e = [], t = this.getParent();
        while (t) {
            e.push(t);
            t = t.getParent();
        }
        return e;
    },
    getAncestorIds: function() {
        var e = [], t = this.getParent();
        while (t) {
            e.push(t.getId());
            t = t.getParent();
        }
        return e;
    }
});

Ext.define("Ext.Evented", {
    alternateClassName: "Ext.EventedBase",
    mixins: [ "Ext.mixin.Observable" ],
    statics: {
        generateSetter: function(e) {
            var t = e.internal, i = e.apply, n = e.changeEvent, r = e.doSet;
            return function(s) {
                var a = this.initialized, o = this[t], l = this[i];
                if (l) {
                    s = l.call(this, s, o);
                    if (typeof s == "undefined") {
                        return this;
                    }
                }
                o = this[t];
                if (s !== o) {
                    if (a) {
                        this.fireAction(n, [ this, s, o ], this.doSet, this, {
                            nameMap: e
                        });
                    } else {
                        this[t] = s;
                        if (this[r]) {
                            this[r].call(this, s, o);
                        }
                    }
                }
                return this;
            };
        }
    },
    initialized: false,
    constructor: function(e) {
        this.initialConfig = e;
        this.initialize();
    },
    initialize: function() {
        this.initConfig(this.initialConfig);
        this.initialized = true;
    },
    doSet: function(e, t, i, n) {
        var r = n.nameMap;
        e[r.internal] = t;
        if (e[r.doSet]) {
            e[r.doSet].call(this, t, i);
        }
    },
    onClassExtended: function(e, t) {
        if (!t.hasOwnProperty("eventedConfig")) {
            return;
        }
        var i = Ext.Class, n = t.config, r = t.eventedConfig, s, a;
        t.config = n ? Ext.applyIf(n, r) : r;
        for (s in r) {
            if (r.hasOwnProperty(s)) {
                a = i.getConfigNameMap(s);
                t[a.set] = this.generateSetter(a);
            }
        }
    }
});

Ext.define("Ext.AbstractComponent", {
    extend: "Ext.Evented",
    onClassExtended: function(e, t) {
        if (!t.hasOwnProperty("cachedConfig")) {
            return;
        }
        var i = e.prototype, n = t.config, r = t.cachedConfig, s = i.cachedConfigList, a = i.hasCachedConfig, o, l;
        delete t.cachedConfig;
        i.cachedConfigList = s = s ? s.slice() : [];
        i.hasCachedConfig = a = a ? Ext.Object.chain(a) : {};
        if (!n) {
            t.config = n = {};
        }
        for (o in r) {
            if (r.hasOwnProperty(o)) {
                l = r[o];
                if (!a[o]) {
                    a[o] = true;
                    s.push(o);
                }
                n[o] = l;
            }
        }
    },
    getElementConfig: Ext.emptyFn,
    referenceAttributeName: "reference",
    referenceSelector: "[reference]",
    addReferenceNode: function(e, t) {
        Ext.Object.defineProperty(this, e, {
            get: function() {
                var i;
                delete this[e];
                this[e] = i = new Ext.Element(t);
                return i;
            },
            configurable: true
        });
    },
    initElement: function() {
        var e = this.self.prototype, t = this.getId(), i = [], n = true, r = this.referenceAttributeName, s = false, a, o, l, u, c, f, d, h, g, p, m, x, E, y, v, b, S, C;
        if (e.hasOwnProperty("renderTemplate")) {
            a = this.renderTemplate.cloneNode(true);
            o = a.firstChild;
        } else {
            n = false;
            s = true;
            a = document.createDocumentFragment();
            o = Ext.Element.create(this.getElementConfig(), true);
            a.appendChild(o);
        }
        u = a.querySelectorAll(this.referenceSelector);
        for (c = 0, f = u.length; c < f; c++) {
            d = u[c];
            h = d.getAttribute(r);
            if (n) {
                d.removeAttribute(r);
            }
            if (h == "element") {
                d.id = t;
                this.element = l = new Ext.Element(d);
            } else {
                this.addReferenceNode(h, d);
            }
            i.push(h);
        }
        this.referenceList = i;
        if (!this.innerElement) {
            this.innerElement = l;
        }
        if (!this.bodyElement) {
            this.bodyElement = this.innerElement;
        }
        if (o === l.dom) {
            this.renderElement = l;
        } else {
            this.addReferenceNode("renderElement", o);
        }
        if (s) {
            g = Ext.Class.configNameCache;
            p = this.config;
            m = this.cachedConfigList;
            x = this.initConfigList;
            E = this.initConfigMap;
            y = [];
            for (c = 0, f = m.length; c < f; c++) {
                b = m[c];
                S = g[b];
                if (E[b]) {
                    E[b] = false;
                    Ext.Array.remove(x, b);
                }
                if (p[b] !== null) {
                    y.push(b);
                    this[S.get] = this[S.initGet];
                }
            }
            for (c = 0, f = y.length; c < f; c++) {
                b = y[c];
                S = g[b];
                C = S.internal;
                this[C] = null;
                this[S.set].call(this, p[b]);
                delete this[S.get];
                e[C] = this[C];
            }
            o = this.renderElement.dom;
            e.renderTemplate = a = document.createDocumentFragment();
            a.appendChild(o.cloneNode(true));
            v = a.querySelectorAll("[id]");
            for (c = 0, f = v.length; c < f; c++) {
                l = v[c];
                l.removeAttribute("id");
            }
            for (c = 0, f = i.length; c < f; c++) {
                h = i[c];
                this[h].dom.removeAttribute("reference");
            }
        }
        return this;
    }
});

Ext.define("Ext.XTemplateCompiler", {
    extend: "Ext.XTemplateParser",
    useEval: Ext.isGecko,
    useIndex: Ext.isIE6 || Ext.isIE7,
    useFormat: true,
    propNameRe: /^[\w\d\$]*$/,
    compile: function(e) {
        var t = this, i = t.generate(e);
        return t.useEval ? t.evalTpl(i) : new Function("Ext", i)(Ext);
    },
    generate: function(e) {
        var t = this, i = "var fm=Ext.util.Format,ts=Object.prototype.toString;", n;
        t.maxLevel = 0;
        t.body = [ "var c0=values, a0=" + t.createArrayTest(0) + ", p0=parent, n0=xcount, i0=xindex, v;\n" ];
        if (t.definitions) {
            if (typeof t.definitions === "string") {
                t.definitions = [ t.definitions, i ];
            } else {
                t.definitions.push(i);
            }
        } else {
            t.definitions = [ i ];
        }
        t.switches = [];
        t.parse(e);
        t.definitions.push((t.useEval ? "$=" : "return") + " function (" + t.fnArgs + ") {", t.body.join(""), "}");
        n = t.definitions.join("\n");
        t.definitions.length = t.body.length = t.switches.length = 0;
        delete t.definitions;
        delete t.body;
        delete t.switches;
        return n;
    },
    doText: function(e) {
        var t = this, i = t.body;
        e = e.replace(t.aposRe, "\\'").replace(t.newLineRe, "\\n");
        if (t.useIndex) {
            i.push("out[out.length]='", e, "'\n");
        } else {
            i.push("out.push('", e, "')\n");
        }
    },
    doExpr: function(e) {
        var t = this.body;
        t.push("if ((v=" + e + ")!==undefined && (v=" + e + ")!==null) out");
        if (this.useIndex) {
            t.push("[out.length]=v+''\n");
        } else {
            t.push(".push(v+'')\n");
        }
    },
    doTag: function(e) {
        this.doExpr(this.parseTag(e));
    },
    doElse: function() {
        this.body.push("} else {\n");
    },
    doEval: function(e) {
        this.body.push(e, "\n");
    },
    doIf: function(e, t) {
        var i = this;
        if (e === ".") {
            i.body.push("if (values) {\n");
        } else if (i.propNameRe.test(e)) {
            i.body.push("if (", i.parseTag(e), ") {\n");
        } else {
            i.body.push("if (", i.addFn(e), i.callFn, ") {\n");
        }
        if (t.exec) {
            i.doExec(t.exec);
        }
    },
    doElseIf: function(e, t) {
        var i = this;
        if (e === ".") {
            i.body.push("else if (values) {\n");
        } else if (i.propNameRe.test(e)) {
            i.body.push("} else if (", i.parseTag(e), ") {\n");
        } else {
            i.body.push("} else if (", i.addFn(e), i.callFn, ") {\n");
        }
        if (t.exec) {
            i.doExec(t.exec);
        }
    },
    doSwitch: function(e) {
        var t = this;
        if (e === ".") {
            t.body.push("switch (values) {\n");
        } else if (t.propNameRe.test(e)) {
            t.body.push("switch (", t.parseTag(e), ") {\n");
        } else {
            t.body.push("switch (", t.addFn(e), t.callFn, ") {\n");
        }
        t.switches.push(0);
    },
    doCase: function(e) {
        var t = this, i = Ext.isArray(e) ? e : [ e ], n = t.switches.length - 1, r, s;
        if (t.switches[n]) {
            t.body.push("break;\n");
        } else {
            t.switches[n]++;
        }
        for (s = 0, n = i.length; s < n; ++s) {
            r = t.intRe.exec(i[s]);
            i[s] = r ? r[1] : "'" + i[s].replace(t.aposRe, "\\'") + "'";
        }
        t.body.push("case ", i.join(": case "), ":\n");
    },
    doDefault: function() {
        var e = this, t = e.switches.length - 1;
        if (e.switches[t]) {
            e.body.push("break;\n");
        } else {
            e.switches[t]++;
        }
        e.body.push("default:\n");
    },
    doEnd: function(e, t) {
        var i = this, n = i.level - 1;
        if (e == "for") {
            if (t.exec) {
                i.doExec(t.exec);
            }
            i.body.push("}\n");
            i.body.push("parent=p", n, ";values=r", n + 1, ";xcount=n", n, ";xindex=i", n, "\n");
        } else if (e == "if" || e == "switch") {
            i.body.push("}\n");
        }
    },
    doFor: function(e, t) {
        var i = this, n, r = i.level, s = r - 1, a = "p" + r, o;
        if (e === ".") {
            n = "values";
        } else if (i.propNameRe.test(e)) {
            n = i.parseTag(e);
        } else {
            n = i.addFn(e) + i.callFn;
        }
        if (i.maxLevel < r) {
            i.maxLevel = r;
            i.body.push("var ");
        }
        if (e == ".") {
            o = "c" + r;
        } else {
            o = "a" + s + "?c" + s + "[i" + s + "]:p" + r;
        }
        i.body.push("i", r, "=0,n", r, "=0,c", r, "=", n, ",a", r, "=", i.createArrayTest(r), ",p", r, "=c", s, ",r", r, "=values;\n", "parent=", o, "\n", "if (c", r, "){if(a", r, "){n", r, "=c", r, ".length;}else if (c", r, ".isMixedCollection){c", r, "=c", r, ".items;n", r, "=c", r, ".length;}else if(c", r, ".isStore){c", r, "=c", r, ".data.items;n", r, "=c", r, ".length;}else{c", r, "=[c", r, "];n", r, "=1;}}\n", "for (xcount=n", r, ";i", r, "<n" + r + ";++i", r, "){\n", "values=c", r, "[i", r, "]");
        if (t.propName) {
            i.body.push(".", t.propName);
        }
        i.body.push("\n", "xindex=i", r, "+1\n");
    },
    createArrayTest: "isArray" in Array ? function(e) {
        return "Array.isArray(c" + e + ")";
    } : function(e) {
        return "ts.call(c" + e + ')==="[object Array]"';
    },
    doExec: function(e, t) {
        var i = this, n = "f" + i.definitions.length;
        i.definitions.push("function " + n + "(" + i.fnArgs + ") {", " try { with(values) {", "  " + e, " }} catch(e) {", 'Ext.Logger.log("XTemplate Error: " + e.message);', "}", "}");
        i.body.push(n + i.callFn + "\n");
    },
    addFn: function(e) {
        var t = this, i = "f" + t.definitions.length;
        if (e === ".") {
            t.definitions.push("function " + i + "(" + t.fnArgs + ") {", " return values", "}");
        } else if (e === "..") {
            t.definitions.push("function " + i + "(" + t.fnArgs + ") {", " return parent", "}");
        } else {
            t.definitions.push("function " + i + "(" + t.fnArgs + ") {", " try { with(values) {", "  return(" + e + ")", " }} catch(e) {", 'Ext.Logger.log("XTemplate Error: " + e.message);', "}", "}");
        }
        return i;
    },
    parseTag: function(e) {
        var t = this, i = t.tagRe.exec(e), n = i[1], r = i[2], s = i[3], a = i[4], o;
        if (n == ".") {
            if (!t.validTypes) {
                t.definitions.push("var validTypes={string:1,number:1,boolean:1};");
                t.validTypes = true;
            }
            o = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""';
        } else if (n == "#") {
            o = "xindex";
        } else if (n.substr(0, 7) == "parent.") {
            o = n;
        } else if (isNaN(n) && n.indexOf("-") == -1 && n.indexOf(".") != -1) {
            o = "values." + n;
        } else {
            o = "values['" + n + "']";
        }
        if (a) {
            o = "(" + o + a + ")";
        }
        if (r && t.useFormat) {
            s = s ? "," + s : "";
            if (r.substr(0, 5) != "this.") {
                r = "fm." + r + "(";
            } else {
                r += "(";
            }
        } else {
            return o;
        }
        return r + o + s + ")";
    },
    evalTpl: function($) {
        eval($);
        return $;
    },
    newLineRe: /\r\n|\r|\n/g,
    aposRe: /[']/g,
    intRe: /^\s*(\d+)\s*$/,
    tagRe: /([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?/
}, function() {
    var e = this.prototype;
    e.fnArgs = "out,values,parent,xindex,xcount";
    e.callFn = ".call(this," + e.fnArgs + ")";
});

(function() {
    function e(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return e.replace(/\{(\d+)\}/g, function(e, i) {
            return t[i];
        });
    }
    Ext.DateExtras = {
        now: Date.now || function() {
            return +new Date();
        },
        getElapsed: function(e, t) {
            return Math.abs(e - (t || new Date()));
        },
        useStrict: false,
        formatCodeToRegex: function(i, n) {
            var r = t.parseCodes[i];
            if (r) {
                r = typeof r == "function" ? r() : r;
                t.parseCodes[i] = r;
            }
            return r ? Ext.applyIf({
                c: r.c ? e(r.c, n || "{0}") : r.c
            }, r) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(i)
            };
        },
        parseFunctions: {
            MS: function(e, t) {
                var i = new RegExp("\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/");
                var n = (e || "").match(i);
                return n ? new Date(((n[1] || "") + n[2]) * 1) : null;
            }
        },
        parseRegexes: [],
        formatFunctions: {
            MS: function() {
                return "\\/Date(" + this.getTime() + ")\\/";
            }
        },
        y2kYear: 50,
        MILLI: "ms",
        SECOND: "s",
        MINUTE: "mi",
        HOUR: "h",
        DAY: "d",
        MONTH: "mo",
        YEAR: "y",
        defaults: {},
        dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
        monthNumbers: {
            Jan: 0,
            Feb: 1,
            Mar: 2,
            Apr: 3,
            May: 4,
            Jun: 5,
            Jul: 6,
            Aug: 7,
            Sep: 8,
            Oct: 9,
            Nov: 10,
            Dec: 11
        },
        defaultFormat: "m/d/Y",
        getShortMonthName: function(e) {
            return t.monthNames[e].substring(0, 3);
        },
        getShortDayName: function(e) {
            return t.dayNames[e].substring(0, 3);
        },
        getMonthNumber: function(e) {
            return t.monthNumbers[e.substring(0, 1).toUpperCase() + e.substring(1, 3).toLowerCase()];
        },
        formatCodes: {
            d: "Ext.String.leftPad(this.getDate(), 2, '0')",
            D: "Ext.Date.getShortDayName(this.getDay())",
            j: "this.getDate()",
            l: "Ext.Date.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "Ext.Date.getSuffix(this)",
            w: "this.getDay()",
            z: "Ext.Date.getDayOfYear(this)",
            W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
            F: "Ext.Date.monthNames[this.getMonth()]",
            m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
            M: "Ext.Date.getShortMonthName(this.getMonth())",
            n: "(this.getMonth() + 1)",
            t: "Ext.Date.getDaysInMonth(this)",
            L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
            o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
            y: "('' + this.getFullYear()).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "Ext.Date.getGMTOffset(this)",
            P: "Ext.Date.getGMTOffset(this, true)",
            T: "Ext.Date.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",
            c: function() {
                for (var e = "Y-m-dTH:i:sP", i = [], n = 0, r = e.length; n < r; ++n) {
                    var s = e.charAt(n);
                    i.push(s == "T" ? "'T'" : t.getFormatCode(s));
                }
                return i.join(" + ");
            },
            U: "Math.round(this.getTime() / 1000)"
        },
        isValid: function(e, i, n, r, s, a, o) {
            r = r || 0;
            s = s || 0;
            a = a || 0;
            o = o || 0;
            var l = t.add(new Date(e < 100 ? 100 : e, i - 1, n, r, s, a, o), t.YEAR, e < 100 ? e - 100 : 0);
            return e == l.getFullYear() && i == l.getMonth() + 1 && n == l.getDate() && r == l.getHours() && s == l.getMinutes() && a == l.getSeconds() && o == l.getMilliseconds();
        },
        parse: function(e, i, n) {
            var r = t.parseFunctions;
            if (r[i] == null) {
                t.createParser(i);
            }
            return r[i](e, Ext.isDefined(n) ? n : t.useStrict);
        },
        parseDate: function(e, i, n) {
            return t.parse(e, i, n);
        },
        getFormatCode: function(e) {
            var i = t.formatCodes[e];
            if (i) {
                i = typeof i == "function" ? i() : i;
                t.formatCodes[e] = i;
            }
            return i || "'" + Ext.String.escape(e) + "'";
        },
        createFormat: function(e) {
            var i = [], n = false, r = "";
            for (var s = 0; s < e.length; ++s) {
                r = e.charAt(s);
                if (!n && r == "\\") {
                    n = true;
                } else if (n) {
                    n = false;
                    i.push("'" + Ext.String.escape(r) + "'");
                } else if (r == "\n") {
                    i.push(Ext.JSON.encode(r));
                } else {
                    i.push(t.getFormatCode(r));
                }
            }
            t.formatFunctions[e] = Ext.functionFactory("return " + i.join("+"));
        },
        createParser: function() {
            var i = [ "var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,", "def = Ext.Date.defaults,", "results = String(input).match(Ext.Date.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = Ext.Date.clearTime(new Date);", "y = Ext.Number.from(y, Ext.Number.from(def.y, dt.getFullYear()));", "m = Ext.Number.from(m, Ext.Number.from(def.m - 1, dt.getMonth()));", "d = Ext.Number.from(d, Ext.Number.from(def.d, dt.getDate()));", "h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));", "i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));", "s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));", "ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (Ext.Date.isLeapYear(v) && z <= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);", "}else if(strict === true && !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "if(v){", "if(zz != null){", "v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return v;" ].join("\n");
            return function(n) {
                var r = t.parseRegexes.length, s = 1, a = [], o = [], l = false, u = "";
                for (var c = 0; c < n.length; ++c) {
                    u = n.charAt(c);
                    if (!l && u == "\\") {
                        l = true;
                    } else if (l) {
                        l = false;
                        o.push(Ext.String.escape(u));
                    } else {
                        var f = t.formatCodeToRegex(u, s);
                        s += f.g;
                        o.push(f.s);
                        if (f.g && f.c) {
                            a.push(f.c);
                        }
                    }
                }
                t.parseRegexes[r] = new RegExp("^" + o.join("") + "$", "i");
                t.parseFunctions[n] = Ext.functionFactory("input", "strict", e(i, r, a.join("")));
            };
        }(),
        parseCodes: {
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,2})"
            },
            D: function() {
                for (var e = [], i = 0; i < 7; e.push(t.getShortDayName(i)), ++i) ;
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + e.join("|") + ")"
                };
            },
            l: function() {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + t.dayNames.join("|") + ")"
                };
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]"
            },
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            w: {
                g: 0,
                c: null,
                s: "[0-6]"
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})"
            },
            W: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            F: function() {
                return {
                    g: 1,
                    c: "m = parseInt(Ext.Date.getMonthNumber(results[{0}]), 10);\n",
                    s: "(" + t.monthNames.join("|") + ")"
                };
            },
            M: function() {
                for (var e = [], i = 0; i < 12; e.push(t.getShortMonthName(i)), ++i) ;
                return Ext.applyIf({
                    s: "(" + e.join("|") + ")"
                }, t.formatCodeToRegex("F"));
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(\\d{2})"
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(\\d{1,2})"
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: function() {
                return t.formatCodeToRegex("Y");
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})"
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\n" + "y = ty > Ext.Date.y2kYear ? 1900 + ty : 2000 + ty;\n",
                s: "(\\d{1,2})"
            },
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n" + "if (!h || h == 12) { h = 0; }\n" + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)"
            },
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n" + "if (!h || h == 12) { h = 0; }\n" + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)"
            },
            g: function() {
                return t.formatCodeToRegex("G");
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,2})"
            },
            h: function() {
                return t.formatCodeToRegex("H");
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)"
            },
            O: {
                g: 1,
                c: [ "o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" ].join("\n"),
                s: "([+-]\\d{4})"
            },
            P: {
                g: 1,
                c: [ "o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" ].join("\n"),
                s: "([+-]\\d{2}:\\d{2})"
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,4}"
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\n" + "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+-]?\\d{1,5})"
            },
            c: function() {
                var e = [], i = [ t.formatCodeToRegex("Y", 1), t.formatCodeToRegex("m", 2), t.formatCodeToRegex("d", 3), t.formatCodeToRegex("h", 4), t.formatCodeToRegex("i", 5), t.formatCodeToRegex("s", 6), {
                    c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                }, {
                    c: [ "if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", t.formatCodeToRegex("P", 8).c, "}else{", t.formatCodeToRegex("O", 8).c, "}", "}" ].join("\n")
                } ];
                for (var n = 0, r = i.length; n < r; ++n) {
                    e.push(i[n].c);
                }
                return {
                    g: 1,
                    c: e.join(""),
                    s: [ i[0].s, "(?:", "-", i[1].s, "(?:", "-", i[2].s, "(?:", "(?:T| )?", i[3].s, ":", i[4].s, "(?::", i[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?" ].join("")
                };
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)"
            }
        },
        dateFormat: function(e, i) {
            return t.format(e, i);
        },
        format: function(e, i) {
            if (t.formatFunctions[i] == null) {
                t.createFormat(i);
            }
            var n = t.formatFunctions[i].call(e);
            return n + "";
        },
        getTimezone: function(e) {
            return e.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "");
        },
        getGMTOffset: function(e, t) {
            var i = e.getTimezoneOffset();
            return (i > 0 ? "-" : "+") + Ext.String.leftPad(Math.floor(Math.abs(i) / 60), 2, "0") + (t ? ":" : "") + Ext.String.leftPad(Math.abs(i % 60), 2, "0");
        },
        getDayOfYear: function(e) {
            var i = 0, n = Ext.Date.clone(e), r = e.getMonth(), s;
            for (s = 0, n.setDate(1), n.setMonth(0); s < r; n.setMonth(++s)) {
                i += t.getDaysInMonth(n);
            }
            return i + e.getDate() - 1;
        },
        getWeekOfYear: function() {
            var e = 864e5, t = 7 * e;
            return function(i) {
                var n = Date.UTC(i.getFullYear(), i.getMonth(), i.getDate() + 3) / e, r = Math.floor(n / 7), s = new Date(r * t).getUTCFullYear();
                return r - Math.floor(Date.UTC(s, 0, 7) / t) + 1;
            };
        }(),
        isLeapYear: function(e) {
            var t = e.getFullYear();
            return !!((t & 3) == 0 && (t % 100 || t % 400 == 0 && t));
        },
        getFirstDayOfMonth: function(e) {
            var t = (e.getDay() - (e.getDate() - 1)) % 7;
            return t < 0 ? t + 7 : t;
        },
        getLastDayOfMonth: function(e) {
            return t.getLastDateOfMonth(e).getDay();
        },
        getFirstDateOfMonth: function(e) {
            return new Date(e.getFullYear(), e.getMonth(), 1);
        },
        getLastDateOfMonth: function(e) {
            return new Date(e.getFullYear(), e.getMonth(), t.getDaysInMonth(e));
        },
        getDaysInMonth: function() {
            var e = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
            return function(i) {
                var n = i.getMonth();
                return n == 1 && t.isLeapYear(i) ? 29 : e[n];
            };
        }(),
        getSuffix: function(e) {
            switch (e.getDate()) {
              case 1:
              case 21:
              case 31:
                return "st";

              case 2:
              case 22:
                return "nd";

              case 3:
              case 23:
                return "rd";

              default:
                return "th";
            }
        },
        clone: function(e) {
            return new Date(e.getTime());
        },
        isDST: function(e) {
            return new Date(e.getFullYear(), 0, 1).getTimezoneOffset() != e.getTimezoneOffset();
        },
        clearTime: function(e, i) {
            if (i) {
                return Ext.Date.clearTime(Ext.Date.clone(e));
            }
            var n = e.getDate();
            e.setHours(0);
            e.setMinutes(0);
            e.setSeconds(0);
            e.setMilliseconds(0);
            if (e.getDate() != n) {
                for (var r = 1, s = t.add(e, Ext.Date.HOUR, r); s.getDate() != n; r++, s = t.add(e, Ext.Date.HOUR, r)) ;
                e.setDate(n);
                e.setHours(s.getHours());
            }
            return e;
        },
        add: function(e, t, i) {
            var n = Ext.Date.clone(e);
            if (!t || i === 0) return n;
            switch (t.toLowerCase()) {
              case Ext.Date.MILLI:
                n = new Date(n.valueOf() + i);
                break;

              case Ext.Date.SECOND:
                n = new Date(n.valueOf() + i * 1e3);
                break;

              case Ext.Date.MINUTE:
                n = new Date(n.valueOf() + i * 6e4);
                break;

              case Ext.Date.HOUR:
                n = new Date(n.valueOf() + i * 36e5);
                break;

              case Ext.Date.DAY:
                n = new Date(n.valueOf() + i * 864e5);
                break;

              case Ext.Date.MONTH:
                var r = e.getDate();
                if (r > 28) {
                    r = Math.min(r, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(e), "mo", i)).getDate());
                }
                n.setDate(r);
                n.setMonth(e.getMonth() + i);
                break;

              case Ext.Date.YEAR:
                n.setFullYear(e.getFullYear() + i);
                break;
            }
            return n;
        },
        between: function(e, t, i) {
            var n = e.getTime();
            return t.getTime() <= n && n <= i.getTime();
        },
        diff: function(e, t, i) {
            var n = Ext.Date, r, s = +t - e;
            switch (i) {
              case n.MILLI:
                return s;

              case n.SECOND:
                return Math.floor(s / 1e3);

              case n.MINUTE:
                return Math.floor(s / 6e4);

              case n.HOUR:
                return Math.floor(s / 36e5);

              case n.DAY:
                return Math.floor(s / 864e5);

              case "w":
                return Math.floor(s / 6048e5);

              case n.MONTH:
                r = t.getFullYear() * 12 + t.getMonth() - (e.getFullYear() * 12 + e.getMonth());
                if (Ext.Date.add(e, i, r) > t) {
                    return r - 1;
                } else {
                    return r;
                }

              case n.YEAR:
                r = t.getFullYear() - e.getFullYear();
                if (Ext.Date.add(e, i, r) > t) {
                    return r - 1;
                } else {
                    return r;
                }
            }
        },
        align: function(e, t, i) {
            var n = new Date(+e);
            switch (t.toLowerCase()) {
              case Ext.Date.MILLI:
                return n;
                break;

              case Ext.Date.SECOND:
                n.setUTCSeconds(n.getUTCSeconds() - n.getUTCSeconds() % i);
                n.setUTCMilliseconds(0);
                return n;
                break;

              case Ext.Date.MINUTE:
                n.setUTCMinutes(n.getUTCMinutes() - n.getUTCMinutes() % i);
                n.setUTCSeconds(0);
                n.setUTCMilliseconds(0);
                return n;
                break;

              case Ext.Date.HOUR:
                n.setUTCHours(n.getUTCHours() - n.getUTCHours() % i);
                n.setUTCMinutes(0);
                n.setUTCSeconds(0);
                n.setUTCMilliseconds(0);
                return n;
                break;

              case Ext.Date.DAY:
                if (i == 7 || i == 14) {
                    n.setUTCDate(n.getUTCDate() - n.getUTCDay() + 1);
                }
                n.setUTCHours(0);
                n.setUTCMinutes(0);
                n.setUTCSeconds(0);
                n.setUTCMilliseconds(0);
                return n;
                break;

              case Ext.Date.MONTH:
                n.setUTCMonth(n.getUTCMonth() - (n.getUTCMonth() - 1) % i, 1);
                n.setUTCHours(0);
                n.setUTCMinutes(0);
                n.setUTCSeconds(0);
                n.setUTCMilliseconds(0);
                return n;
                break;

              case Ext.Date.YEAR:
                n.setUTCFullYear(n.getUTCFullYear() - n.getUTCFullYear() % i, 1, 1);
                n.setUTCHours(0);
                n.setUTCMinutes(0);
                n.setUTCSeconds(0);
                n.setUTCMilliseconds(0);
                return e;
                break;
            }
        }
    };
    var t = Ext.DateExtras;
    Ext.apply(Ext.Date, t);
    Ext.apply(Ext.util.Date, t);
})();

Ext.define("Ext.util.Format", {
    requires: [ "Ext.DateExtras" ],
    singleton: true,
    defaultDateFormat: "m/d/Y",
    escapeRe: /('|\\)/g,
    trimRe: /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
    formatRe: /\{(\d+)\}/g,
    escapeRegexRe: /([-.*+?^${}()|[\]\/\\])/g,
    dashesRe: /-/g,
    iso8601TestRe: /\d\dT\d\d/,
    iso8601SplitRe: /[- :T\.Z\+]/,
    ellipsis: function(e, t, i) {
        if (e && e.length > t) {
            if (i) {
                var n = e.substr(0, t - 2), r = Math.max(n.lastIndexOf(" "), n.lastIndexOf("."), n.lastIndexOf("!"), n.lastIndexOf("?"));
                if (r != -1 && r >= t - 15) {
                    return n.substr(0, r) + "...";
                }
            }
            return e.substr(0, t - 3) + "...";
        }
        return e;
    },
    escapeRegex: function(e) {
        return e.replace(Ext.util.Format.escapeRegexRe, "\\$1");
    },
    escape: function(e) {
        return e.replace(Ext.util.Format.escapeRe, "\\$1");
    },
    toggle: function(e, t, i) {
        return e == t ? i : t;
    },
    trim: function(e) {
        return e.replace(Ext.util.Format.trimRe, "");
    },
    leftPad: function(e, t, i) {
        var n = String(e);
        i = i || " ";
        while (n.length < t) {
            n = i + n;
        }
        return n;
    },
    format: function(e) {
        var t = Ext.toArray(arguments, 1);
        return e.replace(Ext.util.Format.formatRe, function(e, i) {
            return t[i];
        });
    },
    htmlEncode: function(e) {
        return !e ? e : String(e).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
    },
    htmlDecode: function(e) {
        return !e ? e : String(e).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
    },
    date: function(e, t) {
        var i = e;
        if (!e) {
            return "";
        }
        if (!Ext.isDate(e)) {
            i = new Date(Date.parse(e));
            if (isNaN(i)) {
                if (this.iso8601TestRe.test(e)) {
                    i = e.split(this.iso8601SplitRe);
                    i = new Date(i[0], i[1] - 1, i[2], i[3], i[4], i[5]);
                }
                if (isNaN(i)) {
                    i = new Date(Date.parse(e.replace(this.dashesRe, "/")));
                    if (isNaN(i)) {
                        Ext.Logger.error("Cannot parse the passed value " + e + " into a valid date");
                    }
                }
            }
            e = i;
        }
        return Ext.Date.format(e, t || Ext.util.Format.defaultDateFormat);
    }
});

Ext.define("Ext.Template", {
    requires: [ "Ext.dom.Helper", "Ext.util.Format" ],
    inheritableStatics: {
        from: function(e, t) {
            e = Ext.getDom(e);
            return new this(e.value || e.innerHTML, t || "");
        }
    },
    constructor: function(e) {
        var t = this, i = arguments, n = [], r = 0, s = i.length, a;
        t.initialConfig = {};
        if (s === 1 && Ext.isArray(e)) {
            i = e;
            s = i.length;
        }
        if (s > 1) {
            for (;r < s; r++) {
                a = i[r];
                if (typeof a == "object") {
                    Ext.apply(t.initialConfig, a);
                    Ext.apply(t, a);
                } else {
                    n.push(a);
                }
            }
        } else {
            n.push(e);
        }
        t.html = n.join("");
        if (t.compiled) {
            t.compile();
        }
    },
    isTemplate: true,
    disableFormats: false,
    re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
    apply: function(e) {
        var t = this, i = t.disableFormats !== true, n = Ext.util.Format, r = t, s;
        if (t.compiled) {
            return t.compiled(e).join("");
        }
        function a(t, s, a, o) {
            if (a && i) {
                if (o) {
                    o = [ e[s] ].concat(Ext.functionFactory("return [" + o + "];")());
                } else {
                    o = [ e[s] ];
                }
                if (a.substr(0, 5) == "this.") {
                    return r[a.substr(5)].apply(r, o);
                } else {
                    return n[a].apply(n, o);
                }
            } else {
                return e[s] !== undefined ? e[s] : "";
            }
        }
        s = t.html.replace(t.re, a);
        return s;
    },
    applyOut: function(e, t) {
        var i = this;
        if (i.compiled) {
            t.push.apply(t, i.compiled(e));
        } else {
            t.push(i.apply(e));
        }
        return t;
    },
    applyTemplate: function() {
        return this.apply.apply(this, arguments);
    },
    set: function(e, t) {
        var i = this;
        i.html = e;
        i.compiled = null;
        return t ? i.compile() : i;
    },
    compileARe: /\\/g,
    compileBRe: /(\r\n|\n)/g,
    compileCRe: /'/g,
    compile: function() {
        var me = this, fm = Ext.util.Format, useFormat = me.disableFormats !== true, body, bodyReturn;
        function fn(e, t, i, n) {
            if (i && useFormat) {
                n = n ? "," + n : "";
                if (i.substr(0, 5) != "this.") {
                    i = "fm." + i + "(";
                } else {
                    i = "this." + i.substr(5) + "(";
                }
            } else {
                n = "";
                i = "(values['" + t + "'] == undefined ? '' : ";
            }
            return "'," + i + "values['" + t + "']" + n + ") ,'";
        }
        bodyReturn = me.html.replace(me.compileARe, "\\\\").replace(me.compileBRe, "\\n").replace(me.compileCRe, "\\'").replace(me.re, fn);
        body = "this.compiled = function(values){ return ['" + bodyReturn + "'];};";
        eval(body);
        return me;
    },
    insertFirst: function(e, t, i) {
        return this.doInsert("afterBegin", e, t, i);
    },
    insertBefore: function(e, t, i) {
        return this.doInsert("beforeBegin", e, t, i);
    },
    insertAfter: function(e, t, i) {
        return this.doInsert("afterEnd", e, t, i);
    },
    append: function(e, t, i) {
        return this.doInsert("beforeEnd", e, t, i);
    },
    doInsert: function(e, t, i, n) {
        var r = Ext.DomHelper.insertHtml(e, Ext.getDom(t), this.apply(i));
        return n ? Ext.get(r) : r;
    },
    overwrite: function(e, t, i) {
        var n = Ext.DomHelper.overwrite(Ext.getDom(e), this.apply(t));
        return i ? Ext.get(n) : n;
    }
});

Ext.define("Ext.XTemplate", {
    extend: "Ext.Template",
    requires: "Ext.XTemplateCompiler",
    emptyObj: {},
    apply: function(e) {
        return this.applyOut(e, []).join("");
    },
    applyOut: function(e, t, i) {
        var n = this, r = e.xindex, s = e.xcount, a;
        if (!n.fn) {
            a = new Ext.XTemplateCompiler({
                useFormat: n.disableFormats !== true,
                definitions: n.definitions
            });
            n.fn = a.compile(n.html);
        }
        try {
            r = typeof r === "number" ? r : 1;
            s = typeof s === "number" ? s : 1;
            n.fn.call(n, t, e, i || n.emptyObj, r, s);
        } catch (o) {
            Ext.Logger.log("Error: " + o.message);
        }
        return t;
    },
    compile: function() {
        return this;
    },
    statics: {
        getTpl: function(e, t) {
            var i = e[t], n;
            if (i && !i.isTemplate) {
                i = Ext.ClassManager.dynInstantiate("Ext.XTemplate", i);
                if (e.hasOwnProperty(t)) {
                    e[t] = i;
                } else {
                    for (n = e.self.prototype; n; n = n.superclass) {
                        if (n.hasOwnProperty(t)) {
                            n[t] = i;
                            break;
                        }
                    }
                }
            }
            return i || null;
        }
    }
});

Ext.define("Ext.fx.easing.Linear", {
    extend: "Ext.fx.easing.Abstract",
    alias: "easing.linear",
    config: {
        duration: 0,
        endValue: 0
    },
    updateStartValue: function(e) {
        this.distance = this.getEndValue() - e;
    },
    updateEndValue: function(e) {
        this.distance = e - this.getStartValue();
    },
    getValue: function() {
        var e = Ext.Date.now() - this.getStartTime(), t = this.getDuration();
        if (e > t) {
            this.isEnded = true;
            return this.getEndValue();
        } else {
            return this.getStartValue() + e / t * this.distance;
        }
    }
});

Ext.define("Ext.util.translatable.Abstract", {
    extend: "Ext.Evented",
    requires: [ "Ext.fx.easing.Linear" ],
    config: {
        easing: null,
        easingX: null,
        easingY: null,
        fps: Ext.os.is.Android4 ? 50 : 60
    },
    x: 0,
    y: 0,
    activeEasingX: null,
    activeEasingY: null,
    isAnimating: false,
    isTranslatable: true,
    constructor: function(e) {
        this.doAnimationFrame = Ext.Function.bind(this.doAnimationFrame, this);
        this.initConfig(e);
    },
    factoryEasing: function(e) {
        return Ext.factory(e, Ext.fx.easing.Linear, null, "easing");
    },
    applyEasing: function(e) {
        if (!this.getEasingX()) {
            this.setEasingX(this.factoryEasing(e));
        }
        if (!this.getEasingY()) {
            this.setEasingY(this.factoryEasing(e));
        }
    },
    applyEasingX: function(e) {
        return this.factoryEasing(e);
    },
    applyEasingY: function(e) {
        return this.factoryEasing(e);
    },
    updateFps: function(e) {
        this.animationInterval = 1e3 / e;
    },
    doTranslate: Ext.emptyFn,
    translate: function(e, t, i) {
        if (i) {
            return this.translateAnimated(e, t, i);
        }
        if (this.isAnimating) {
            this.stopAnimation();
        }
        if (!isNaN(e) && typeof e == "number") {
            this.x = e;
        }
        if (!isNaN(t) && typeof t == "number") {
            this.y = t;
        }
        this.doTranslate(e, t);
    },
    translateAxis: function(e, t, i) {
        var n, r;
        if (e == "x") {
            n = t;
        } else {
            r = t;
        }
        return this.translate(n, r, i);
    },
    animate: function(e, t) {
        this.activeEasingX = e;
        this.activeEasingY = t;
        this.isAnimating = true;
        this.lastX = null;
        this.lastY = null;
        this.animationFrameId = requestAnimationFrame(this.doAnimationFrame);
        this.fireEvent("animationstart", this, this.x, this.y);
        return this;
    },
    translateAnimated: function(e, t, i) {
        if (!Ext.isObject(i)) {
            i = {};
        }
        if (this.isAnimating) {
            this.stopAnimation();
        }
        var n = Ext.Date.now(), r = i.easing, s = typeof e == "number" ? i.easingX || r || this.getEasingX() || true : null, a = typeof t == "number" ? i.easingY || r || this.getEasingY() || true : null;
        if (s) {
            s = this.factoryEasing(s);
            s.setStartTime(n);
            s.setStartValue(this.x);
            s.setEndValue(e);
            if ("duration" in i) {
                s.setDuration(i.duration);
            }
        }
        if (a) {
            a = this.factoryEasing(a);
            a.setStartTime(n);
            a.setStartValue(this.y);
            a.setEndValue(t);
            if ("duration" in i) {
                a.setDuration(i.duration);
            }
        }
        return this.animate(s, a);
    },
    doAnimationFrame: function() {
        var e = this, t = e.activeEasingX, i = e.activeEasingY, n = Date.now(), r, s;
        this.animationFrameId = requestAnimationFrame(this.doAnimationFrame);
        if (!e.isAnimating) {
            return;
        }
        e.lastRun = n;
        if (t === null && i === null) {
            e.stopAnimation();
            return;
        }
        if (t !== null) {
            e.x = r = Math.round(t.getValue());
            if (t.isEnded) {
                e.activeEasingX = null;
                e.fireEvent("axisanimationend", e, "x", r);
            }
        } else {
            r = e.x;
        }
        if (i !== null) {
            e.y = s = Math.round(i.getValue());
            if (i.isEnded) {
                e.activeEasingY = null;
                e.fireEvent("axisanimationend", e, "y", s);
            }
        } else {
            s = e.y;
        }
        if (e.lastX !== r || e.lastY !== s) {
            e.doTranslate(r, s);
            e.lastX = r;
            e.lastY = s;
        }
        e.fireEvent("animationframe", e, r, s);
    },
    stopAnimation: function() {
        if (!this.isAnimating) {
            return;
        }
        this.activeEasingX = null;
        this.activeEasingY = null;
        this.isAnimating = false;
        cancelAnimationFrame(this.animationFrameId);
        this.fireEvent("animationend", this, this.x, this.y);
    },
    refresh: function() {
        this.translate(this.x, this.y);
    },
    destroy: function() {
        if (this.isAnimating) {
            this.stopAnimation();
        }
        this.callParent(arguments);
    }
});

Ext.define("Ext.util.translatable.Dom", {
    extend: "Ext.util.translatable.Abstract",
    config: {
        element: null
    },
    applyElement: function(e) {
        if (!e) {
            return;
        }
        return Ext.get(e);
    },
    updateElement: function() {
        this.refresh();
    }
});

Ext.define("Ext.util.translatable.CssTransform", {
    extend: "Ext.util.translatable.Dom",
    doTranslate: function() {
        this.getElement().dom.style.webkitTransform = "translate3d(" + this.x + "px, " + this.y + "px, 0px)";
    },
    destroy: function() {
        var e = this.getElement();
        if (e && !e.isDestroyed) {
            e.dom.style.webkitTransform = null;
        }
        this.callSuper();
    }
});

Ext.define("Ext.util.translatable.ScrollPosition", {
    extend: "Ext.util.translatable.Dom",
    wrapperWidth: 0,
    wrapperHeight: 0,
    config: {
        useWrapper: true
    },
    getWrapper: function() {
        var e = this.wrapper, t = this.getElement(), i;
        if (!e) {
            i = t.getParent();
            if (!i) {
                return null;
            }
            if (this.getUseWrapper()) {
                e = t.wrap();
            } else {
                e = i;
            }
            t.addCls("x-translatable");
            e.addCls("x-translatable-container");
            this.wrapper = e;
            e.on("resize", "onWrapperResize", this);
            e.on("painted", "refresh", this);
            this.refresh();
        }
        return e;
    },
    doTranslate: function(e, t) {
        var i = this.getWrapper(), n;
        if (i) {
            n = i.dom;
            if (typeof e == "number") {
                n.scrollLeft = this.wrapperWidth - e;
            }
            if (typeof t == "number") {
                n.scrollTop = this.wrapperHeight - t;
            }
        }
    },
    onWrapperResize: function(e, t) {
        this.wrapperWidth = t.width;
        this.wrapperHeight = t.height;
        this.refresh();
    },
    destroy: function() {
        var e = this.getElement(), t = this.wrapper;
        if (t) {
            if (!e.isDestroyed) {
                if (this.getUseWrapper()) {
                    t.doReplaceWith(e);
                }
                e.removeCls("x-translatable");
            }
            t.removeCls("x-translatable-container");
            t.un("resize", "onWrapperResize", this);
            t.un("painted", "refresh", this);
            delete this.wrapper;
            delete this._element;
        }
        this.callSuper();
    }
});

Ext.define("Ext.util.Translatable", {
    requires: [ "Ext.util.translatable.CssTransform", "Ext.util.translatable.ScrollPosition" ],
    constructor: function(e) {
        var t = Ext.util.translatable, i = t.CssTransform, n = t.ScrollPosition, r;
        if (typeof e == "object" && "translationMethod" in e) {
            if (e.translationMethod === "scrollposition") {
                r = n;
            } else if (e.translationMethod === "csstransform") {
                r = i;
            }
        }
        if (!r) {
            if (Ext.os.is.Android2) {
                r = n;
            } else {
                r = i;
            }
        }
        return new r(e);
    }
});

Ext.define("Ext.behavior.Translatable", {
    extend: "Ext.behavior.Behavior",
    requires: [ "Ext.util.Translatable" ],
    setConfig: function(e) {
        var t = this.translatable, i = this.component;
        if (e) {
            if (!t) {
                this.translatable = t = new Ext.util.Translatable(e);
                t.setElement(i.renderElement);
                t.on("destroy", "onTranslatableDestroy", this);
            } else if (Ext.isObject(e)) {
                t.setConfig(e);
            }
        } else if (t) {
            t.destroy();
        }
        return this;
    },
    getTranslatable: function() {
        return this.translatable;
    },
    onTranslatableDestroy: function() {
        delete this.translatable;
    },
    onComponentDestroy: function() {
        var e = this.translatable;
        if (e) {
            e.destroy();
        }
    }
});

Ext.define("Ext.util.Draggable", {
    isDraggable: true,
    mixins: [ "Ext.mixin.Observable" ],
    requires: [ "Ext.util.Translatable" ],
    config: {
        cls: Ext.baseCSSPrefix + "draggable",
        draggingCls: Ext.baseCSSPrefix + "dragging",
        element: null,
        constraint: "container",
        disabled: null,
        direction: "both",
        initialOffset: {
            x: 0,
            y: 0
        },
        translatable: {}
    },
    DIRECTION_BOTH: "both",
    DIRECTION_VERTICAL: "vertical",
    DIRECTION_HORIZONTAL: "horizontal",
    defaultConstraint: {
        min: {
            x: -Infinity,
            y: -Infinity
        },
        max: {
            x: Infinity,
            y: Infinity
        }
    },
    containerWidth: 0,
    containerHeight: 0,
    width: 0,
    height: 0,
    constructor: function(e) {
        var t;
        this.extraConstraint = {};
        this.initialConfig = e;
        this.offset = {
            x: 0,
            y: 0
        };
        this.listeners = {
            dragstart: "onDragStart",
            drag: "onDrag",
            dragend: "onDragEnd",
            resize: "onElementResize",
            scope: this
        };
        if (e && e.element) {
            t = e.element;
            delete e.element;
            this.setElement(t);
        }
        return this;
    },
    applyElement: function(e) {
        if (!e) {
            return;
        }
        return Ext.get(e);
    },
    updateElement: function(e) {
        e.on(this.listeners);
        this.initConfig(this.initialConfig);
    },
    updateInitialOffset: function(e) {
        if (typeof e == "number") {
            e = {
                x: e,
                y: e
            };
        }
        var t = this.offset, i, n;
        t.x = i = e.x;
        t.y = n = e.y;
        this.getTranslatable().translate(i, n);
    },
    updateCls: function(e) {
        this.getElement().addCls(e);
    },
    applyTranslatable: function(e, t) {
        e = Ext.factory(e, Ext.util.Translatable, t);
        e.setElement(this.getElement());
        return e;
    },
    setExtraConstraint: function(e) {
        this.extraConstraint = e || {};
        this.refreshConstraint();
        return this;
    },
    addExtraConstraint: function(e) {
        Ext.merge(this.extraConstraint, e);
        this.refreshConstraint();
        return this;
    },
    applyConstraint: function(e) {
        this.currentConstraint = e;
        if (!e) {
            e = this.defaultConstraint;
        }
        if (e === "container") {
            return Ext.merge(this.getContainerConstraint(), this.extraConstraint);
        }
        return Ext.merge({}, this.extraConstraint, e);
    },
    updateConstraint: function() {
        this.refreshOffset();
    },
    getContainerConstraint: function() {
        var e = this.getContainer(), t = this.getElement();
        if (!e || !t.dom) {
            return this.defaultConstraint;
        }
        return {
            min: {
                x: 0,
                y: 0
            },
            max: {
                x: this.containerWidth - this.width,
                y: this.containerHeight - this.height
            }
        };
    },
    getContainer: function() {
        var e = this.container;
        if (!e) {
            e = this.getElement().getParent();
            if (e) {
                this.container = e;
                e.on({
                    resize: "onContainerResize",
                    destroy: "onContainerDestroy",
                    scope: this
                });
            }
        }
        return e;
    },
    onElementResize: function(e, t) {
        this.width = t.width;
        this.height = t.height;
        this.refresh();
    },
    onContainerResize: function(e, t) {
        this.containerWidth = t.width;
        this.containerHeight = t.height;
        this.refresh();
    },
    onContainerDestroy: function() {
        delete this.container;
        delete this.containerSizeMonitor;
    },
    detachListeners: function() {
        this.getElement().un(this.listeners);
    },
    isAxisEnabled: function(e) {
        var t = this.getDirection();
        if (e === "x") {
            return t === this.DIRECTION_BOTH || t === this.DIRECTION_HORIZONTAL;
        }
        return t === this.DIRECTION_BOTH || t === this.DIRECTION_VERTICAL;
    },
    onDragStart: function(e) {
        if (this.getDisabled()) {
            return false;
        }
        var t = this.offset;
        this.fireAction("dragstart", [ this, e, t.x, t.y ], this.initDragStart);
    },
    initDragStart: function(e, t, i, n) {
        this.dragStartOffset = {
            x: i,
            y: n
        };
        this.isDragging = true;
        this.getElement().addCls(this.getDraggingCls());
    },
    onDrag: function(e) {
        if (!this.isDragging) {
            return;
        }
        var t = this.dragStartOffset;
        this.fireAction("drag", [ this, e, t.x + e.deltaX, t.y + e.deltaY ], this.doDrag);
    },
    doDrag: function(e, t, i, n) {
        e.setOffset(i, n);
    },
    onDragEnd: function(e) {
        if (!this.isDragging) {
            return;
        }
        this.onDrag(e);
        this.isDragging = false;
        this.getElement().removeCls(this.getDraggingCls());
        this.fireEvent("dragend", this, e, this.offset.x, this.offset.y);
    },
    setOffset: function(e, t, i) {
        var n = this.offset, r = this.getConstraint(), s = r.min, a = r.max, o = Math.min, l = Math.max;
        if (this.isAxisEnabled("x") && typeof e == "number") {
            e = o(l(e, s.x), a.x);
        } else {
            e = n.x;
        }
        if (this.isAxisEnabled("y") && typeof t == "number") {
            t = o(l(t, s.y), a.y);
        } else {
            t = n.y;
        }
        n.x = e;
        n.y = t;
        this.getTranslatable().translate(e, t, i);
    },
    getOffset: function() {
        return this.offset;
    },
    refreshConstraint: function() {
        this.setConstraint(this.currentConstraint);
    },
    refreshOffset: function() {
        var e = this.offset;
        this.setOffset(e.x, e.y);
    },
    refresh: function() {
        this.refreshConstraint();
        this.getTranslatable().refresh();
        this.refreshOffset();
    },
    enable: function() {
        return this.setDisabled(false);
    },
    disable: function() {
        return this.setDisabled(true);
    },
    destroy: function() {
        var e = this.getTranslatable();
        var t = this.getElement();
        if (t && !t.isDestroyed) {
            t.removeCls(this.getCls());
        }
        this.detachListeners();
        if (e) {
            e.destroy();
        }
    }
}, function() {
    this.override({
        constructor: function(e) {
            if (e && e.constrain) {
                Ext.Logger.deprecate("'constrain' config is deprecated, please use 'contraint' instead");
                e.contraint = e.constrain;
                delete e.constrain;
            }
            return this.callOverridden(arguments);
        }
    });
});

Ext.define("Ext.behavior.Draggable", {
    extend: "Ext.behavior.Behavior",
    requires: [ "Ext.util.Draggable" ],
    setConfig: function(e) {
        var t = this.draggable, i = this.component;
        if (e) {
            if (!t) {
                i.setTranslatable(true);
                this.draggable = t = new Ext.util.Draggable(e);
                t.setTranslatable(i.getTranslatable());
                t.setElement(i.renderElement);
                t.on("destroy", "onDraggableDestroy", this);
                i.on(this.listeners);
            } else if (Ext.isObject(e)) {
                t.setConfig(e);
            }
        } else if (t) {
            t.destroy();
        }
        return this;
    },
    getDraggable: function() {
        return this.draggable;
    },
    onDraggableDestroy: function() {
        delete this.draggable;
    },
    onComponentDestroy: function() {
        var e = this.draggable;
        if (e) {
            e.destroy();
        }
    }
});

(function(e) {
    Ext.define("Ext.Component", {
        extend: "Ext.AbstractComponent",
        alternateClassName: "Ext.lib.Component",
        mixins: [ "Ext.mixin.Traversable" ],
        requires: [ "Ext.ComponentManager", "Ext.XTemplate", "Ext.dom.Element", "Ext.behavior.Translatable", "Ext.behavior.Draggable" ],
        xtype: "component",
        observableType: "component",
        cachedConfig: {
            baseCls: null,
            cls: null,
            floatingCls: e + "floating",
            hiddenCls: e + "item-hidden",
            ui: null,
            margin: null,
            padding: null,
            border: null,
            styleHtmlCls: e + "html",
            styleHtmlContent: null
        },
        eventedConfig: {
            flex: null,
            left: null,
            top: null,
            right: null,
            bottom: null,
            width: null,
            height: null,
            minWidth: null,
            minHeight: null,
            maxWidth: null,
            maxHeight: null,
            docked: null,
            centered: null,
            hidden: null,
            disabled: null
        },
        config: {
            style: null,
            html: null,
            draggable: null,
            translatable: null,
            renderTo: null,
            zIndex: null,
            tpl: null,
            enterAnimation: null,
            exitAnimation: null,
            showAnimation: null,
            hideAnimation: null,
            tplWriteMode: "overwrite",
            data: null,
            disabledCls: e + "item-disabled",
            contentEl: null,
            itemId: undefined,
            record: null,
            plugins: null
        },
        listenerOptionsRegex: /^(?:delegate|single|delay|buffer|args|prepend|element)$/,
        alignmentRegex: /^([a-z]+)-([a-z]+)(\?)?$/,
        isComponent: true,
        floating: false,
        rendered: false,
        isInner: true,
        dockPositions: {
            top: true,
            right: true,
            bottom: true,
            left: true
        },
        innerElement: null,
        element: null,
        template: [],
        widthLayoutSized: false,
        heightLayoutSized: false,
        layoutStretched: false,
        sizeState: false,
        sizeFlags: 0,
        LAYOUT_WIDTH: 1,
        LAYOUT_HEIGHT: 2,
        LAYOUT_BOTH: 3,
        LAYOUT_STRETCHED: 4,
        constructor: function(e) {
            var t = this, i = t.config, n;
            t.onInitializedListeners = [];
            t.initialConfig = e;
            if (e !== undefined && "id" in e) {
                n = e.id;
            } else if ("id" in i) {
                n = i.id;
            } else {
                n = t.getId();
            }
            t.id = n;
            t.setId(n);
            Ext.ComponentManager.register(t);
            t.initElement();
            t.initConfig(t.initialConfig);
            t.refreshSizeState = t.doRefreshSizeState;
            t.refreshFloating = t.doRefreshFloating;
            if (t.refreshSizeStateOnInitialized) {
                t.refreshSizeState();
            }
            if (t.refreshFloatingOnInitialized) {
                t.refreshFloating();
            }
            t.initialize();
            t.triggerInitialized();
            if (t.config.fullscreen) {
                t.fireEvent("fullscreen", t);
            }
            t.fireEvent("initialize", t);
        },
        beforeInitConfig: function(e) {
            this.beforeInitialize.apply(this, arguments);
        },
        beforeInitialize: Ext.emptyFn,
        initialize: Ext.emptyFn,
        getTemplate: function() {
            return this.template;
        },
        getElementConfig: function() {
            return {
                reference: "element",
                classList: [ "x-unsized" ],
                children: this.getTemplate()
            };
        },
        triggerInitialized: function() {
            var e = this.onInitializedListeners, t = e.length, i, n, r, s, a;
            if (!this.initialized) {
                this.initialized = true;
                if (t > 0) {
                    for (a = 0; a < t; a++) {
                        i = e[a];
                        n = i.fn;
                        r = i.scope;
                        s = i.args;
                        if (typeof n == "string") {
                            r[n].apply(r, s);
                        } else {
                            n.apply(r, s);
                        }
                    }
                    e.length = 0;
                }
            }
        },
        onInitialized: function(e, t, i) {
            var n = this.onInitializedListeners;
            if (!t) {
                t = this;
            }
            if (this.initialized) {
                if (typeof e == "string") {
                    t[e].apply(t, i);
                } else {
                    e.apply(t, i);
                }
            } else {
                n.push({
                    fn: e,
                    scope: t,
                    args: i
                });
            }
        },
        renderTo: function(e, t) {
            var i = this.renderElement.dom, n = Ext.getDom(e), r = Ext.getDom(t);
            if (n) {
                if (r) {
                    n.insertBefore(i, r);
                } else {
                    n.appendChild(i);
                }
                this.setRendered(Boolean(i.offsetParent));
            }
        },
        setParent: function(e) {
            var t = this.parent;
            if (e && t && t !== e) {
                t.remove(this, false);
            }
            this.parent = e;
            return this;
        },
        applyPlugins: function(e) {
            var t, i, n;
            if (!e) {
                return e;
            }
            e = [].concat(e);
            for (i = 0, t = e.length; i < t; i++) {
                n = e[i];
                if (Ext.isObject(n) && n.ptype) {
                    Ext.Logger.deprecate("Using a ptype is now deprecated, please use type instead", 1);
                    n.type = n.ptype;
                }
                e[i] = Ext.factory(n, "Ext.plugin.Plugin", null, "plugin");
            }
            return e;
        },
        updatePlugins: function(e, t) {
            var i, n;
            if (e) {
                for (n = 0, i = e.length; n < i; n++) {
                    e[n].init(this);
                }
            }
            if (t) {
                for (n = 0, i = t.length; n < i; n++) {
                    Ext.destroy(t[n]);
                }
            }
        },
        updateRenderTo: function(e) {
            this.renderTo(e);
        },
        updateStyle: function(e) {
            this.element.applyStyles(e);
        },
        updateBorder: function(e) {
            this.element.setBorder(e);
        },
        updatePadding: function(e) {
            this.innerElement.setPadding(e);
        },
        updateMargin: function(e) {
            this.element.setMargin(e);
        },
        updateUi: function(e, t) {
            var i = this.getBaseCls();
            if (i) {
                if (t) {
                    this.element.removeCls(t, i);
                }
                if (e) {
                    this.element.addCls(e, i);
                }
            }
        },
        applyBaseCls: function(t) {
            return t || e + this.xtype;
        },
        updateBaseCls: function(e, t) {
            var i = this, n = i.getUi();
            if (e) {
                this.element.addCls(e);
                if (n) {
                    this.element.addCls(e, null, n);
                }
            }
            if (t) {
                this.element.removeCls(t);
                if (n) {
                    this.element.removeCls(t, null, n);
                }
            }
        },
        addCls: function(e, t, i) {
            var n = this.getCls(), r = n ? n.slice() : [], s, a, o;
            t = t || "";
            i = i || "";
            if (typeof e == "string") {
                e = [ e ];
            }
            s = e.length;
            if (!r.length && t === "" && i === "") {
                r = e;
            } else {
                for (a = 0; a < s; a++) {
                    o = t + e[a] + i;
                    if (r.indexOf(o) == -1) {
                        r.push(o);
                    }
                }
            }
            this.setCls(r);
        },
        removeCls: function(e, t, i) {
            var n = this.getCls(), r = n ? n.slice() : [], s, a;
            t = t || "";
            i = i || "";
            if (typeof e == "string") {
                r = Ext.Array.remove(r, t + e + i);
            } else {
                s = e.length;
                for (a = 0; a < s; a++) {
                    r = Ext.Array.remove(r, t + e[a] + i);
                }
            }
            this.setCls(r);
        },
        replaceCls: function(e, t, i, n) {
            var r = this.getCls(), s = r ? r.slice() : [], a, o, l;
            i = i || "";
            n = n || "";
            if (typeof e == "string") {
                s = Ext.Array.remove(s, i + e + n);
            } else if (e) {
                a = e.length;
                for (o = 0; o < a; o++) {
                    s = Ext.Array.remove(s, i + e[o] + n);
                }
            }
            if (typeof t == "string") {
                s.push(i + t + n);
            } else if (t) {
                a = t.length;
                if (!s.length && i === "" && n === "") {
                    s = t;
                } else {
                    for (o = 0; o < a; o++) {
                        l = i + t[o] + n;
                        if (s.indexOf(l) == -1) {
                            s.push(l);
                        }
                    }
                }
            }
            this.setCls(s);
        },
        toggleCls: function(e, t) {
            this.element.toggleCls(e, t);
            return this;
        },
        applyCls: function(e) {
            if (typeof e == "string") {
                e = [ e ];
            }
            if (!e || !e.length) {
                e = null;
            }
            return e;
        },
        updateCls: function(e, t) {
            if (this.element && (e && !t || !e && t || e.length != t.length || Ext.Array.difference(e, t).length > 0)) {
                this.element.replaceCls(t, e);
            }
        },
        updateStyleHtmlCls: function(e, t) {
            var i = this.innerHtmlElement, n = this.innerElement;
            if (this.getStyleHtmlContent() && t) {
                if (i) {
                    i.replaceCls(t, e);
                } else {
                    n.replaceCls(t, e);
                }
            }
        },
        applyStyleHtmlContent: function(e) {
            return Boolean(e);
        },
        updateStyleHtmlContent: function(e) {
            var t = this.getStyleHtmlCls(), i = this.innerElement, n = this.innerHtmlElement;
            if (e) {
                if (n) {
                    n.addCls(t);
                } else {
                    i.addCls(t);
                }
            } else {
                if (n) {
                    n.removeCls(t);
                } else {
                    i.addCls(t);
                }
            }
        },
        applyContentEl: function(e) {
            if (e) {
                return Ext.get(e);
            }
        },
        updateContentEl: function(e, t) {
            if (t) {
                t.hide();
                Ext.getBody().append(t);
            }
            if (e) {
                this.setHtml(e.dom);
                e.show();
            }
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            };
        },
        isCentered: function() {
            return Boolean(this.getCentered());
        },
        isFloating: function() {
            return this.floating;
        },
        isDocked: function() {
            return Boolean(this.getDocked());
        },
        isInnerItem: function() {
            return this.isInner;
        },
        setIsInner: function(e) {
            if (e !== this.isInner) {
                this.isInner = e;
                if (this.initialized) {
                    this.fireEvent("innerstatechange", this, e);
                }
            }
        },
        filterPositionValue: function(e) {
            if (e === "" || e === "auto") {
                e = null;
            }
            return e;
        },
        filterLengthValue: function(e) {
            if (e === "auto" || !e && e !== 0) {
                return null;
            }
            return e;
        },
        applyTop: function(e) {
            return this.filterPositionValue(e);
        },
        applyRight: function(e) {
            return this.filterPositionValue(e);
        },
        applyBottom: function(e) {
            return this.filterPositionValue(e);
        },
        applyLeft: function(e) {
            return this.filterPositionValue(e);
        },
        applyWidth: function(e) {
            return this.filterLengthValue(e);
        },
        applyHeight: function(e) {
            return this.filterLengthValue(e);
        },
        applyMinWidth: function(e) {
            return this.filterLengthValue(e);
        },
        applyMinHeight: function(e) {
            return this.filterLengthValue(e);
        },
        applyMaxWidth: function(e) {
            return this.filterLengthValue(e);
        },
        applyMaxHeight: function(e) {
            return this.filterLengthValue(e);
        },
        doSetTop: function(e) {
            this.element.setTop(e);
            this.refreshFloating();
        },
        doSetRight: function(e) {
            this.element.setRight(e);
            this.refreshFloating();
        },
        doSetBottom: function(e) {
            this.element.setBottom(e);
            this.refreshFloating();
        },
        doSetLeft: function(e) {
            this.element.setLeft(e);
            this.refreshFloating();
        },
        doSetWidth: function(e) {
            this.element.setWidth(e);
            this.refreshSizeState();
        },
        doSetHeight: function(e) {
            this.element.setHeight(e);
            this.refreshSizeState();
        },
        applyFlex: function(e) {
            if (e) {
                e = Number(e);
                if (isNaN(e)) {
                    e = null;
                }
            } else {
                e = null;
            }
            return e;
        },
        doSetFlex: Ext.emptyFn,
        refreshSizeState: function() {
            this.refreshSizeStateOnInitialized = true;
        },
        doRefreshSizeState: function() {
            var e = this.getWidth() !== null || this.widthLayoutSized || this.getLeft() !== null && this.getRight() !== null, t = this.getHeight() !== null || this.heightLayoutSized || this.getTop() !== null && this.getBottom() !== null, i = this.layoutStretched || !t && this.getMinHeight() !== null, n = e && t, r = (e && this.LAYOUT_WIDTH) | (t && this.LAYOUT_HEIGHT) | (i && this.LAYOUT_STRETCHED);
            if (!n && i) {
                n = null;
            }
            this.setSizeState(n);
            this.setSizeFlags(r);
        },
        setLayoutSizeFlags: function(e) {
            this.layoutStretched = !!(e & this.LAYOUT_STRETCHED);
            this.widthLayoutSized = !!(e & this.LAYOUT_WIDTH);
            this.heightLayoutSized = !!(e & this.LAYOUT_HEIGHT);
            this.refreshSizeState();
        },
        setSizeFlags: function(e) {
            if (e !== this.sizeFlags) {
                this.sizeFlags = e;
                if (this.initialized) {
                    this.fireEvent("sizeflagschange", this, e);
                }
            }
        },
        getSizeFlags: function() {
            if (!this.initialized) {
                this.doRefreshSizeState();
            }
            return this.sizeFlags;
        },
        setSizeState: function(e) {
            if (e !== this.sizeState) {
                this.sizeState = e;
                this.element.setSizeState(e);
                if (this.initialized) {
                    this.fireEvent("sizestatechange", this, e);
                }
            }
        },
        getSizeState: function() {
            if (!this.initialized) {
                this.doRefreshSizeState();
            }
            return this.sizeState;
        },
        doSetMinWidth: function(e) {
            this.element.setMinWidth(e);
        },
        doSetMinHeight: function(e) {
            this.element.setMinHeight(e);
            this.refreshSizeState();
        },
        doSetMaxWidth: function(e) {
            this.element.setMaxWidth(e);
        },
        doSetMaxHeight: function(e) {
            this.element.setMaxHeight(e);
        },
        applyCentered: function(e) {
            e = Boolean(e);
            if (e) {
                this.refreshInnerState = Ext.emptyFn;
                if (this.isFloating()) {
                    this.resetFloating();
                }
                if (this.isDocked()) {
                    this.setDocked(false);
                }
                this.setIsInner(false);
                delete this.refreshInnerState;
            }
            return e;
        },
        doSetCentered: function(e) {
            this.toggleCls(this.getFloatingCls(), e);
            if (!e) {
                this.refreshInnerState();
            }
        },
        applyDocked: function(e) {
            if (!e) {
                return null;
            }
            if (!/^(top|right|bottom|left)$/.test(e)) {
                Ext.Logger.error("Invalid docking position of '" + e.position + "', must be either 'top', 'right', 'bottom', " + "'left' or `null` (for no docking)", this);
                return;
            }
            this.refreshInnerState = Ext.emptyFn;
            if (this.isFloating()) {
                this.resetFloating();
            }
            if (this.isCentered()) {
                this.setCentered(false);
            }
            this.setIsInner(false);
            delete this.refreshInnerState;
            return e;
        },
        doSetDocked: function(e, t) {
            this.fireEvent("afterdockedchange", this, e, t);
            if (!e) {
                this.refreshInnerState();
            }
        },
        resetFloating: function() {
            this.setTop(null);
            this.setRight(null);
            this.setBottom(null);
            this.setLeft(null);
        },
        refreshInnerState: function() {
            this.setIsInner(!this.isCentered() && !this.isFloating() && !this.isDocked());
        },
        refreshFloating: function() {
            this.refreshFloatingOnInitialized = true;
        },
        doRefreshFloating: function() {
            var e = true, t = this.getFloatingCls();
            if (this.getTop() === null && this.getBottom() === null && this.getRight() === null && this.getLeft() === null) {
                e = false;
            } else {
                this.refreshSizeState();
            }
            if (e !== this.floating) {
                this.floating = e;
                if (e) {
                    this.refreshInnerState = Ext.emptyFn;
                    if (this.isCentered()) {
                        this.setCentered(false);
                    }
                    if (this.isDocked()) {
                        this.setDocked(false);
                    }
                    this.setIsInner(false);
                    delete this.refreshInnerState;
                }
                this.element.toggleCls(t, e);
                if (this.initialized) {
                    this.fireEvent("floatingchange", this, e);
                }
                if (!e) {
                    this.refreshInnerState();
                }
            }
        },
        updateFloatingCls: function(e, t) {
            if (this.isFloating()) {
                this.replaceCls(t, e);
            }
        },
        applyDisabled: function(e) {
            return Boolean(e);
        },
        doSetDisabled: function(e) {
            this.element[e ? "addCls" : "removeCls"](this.getDisabledCls());
        },
        updateDisabledCls: function(e, t) {
            if (this.isDisabled()) {
                this.element.replaceCls(t, e);
            }
        },
        disable: function() {
            this.setDisabled(true);
        },
        enable: function() {
            this.setDisabled(false);
        },
        isDisabled: function() {
            return this.getDisabled();
        },
        applyZIndex: function(e) {
            if (!e && e !== 0) {
                e = null;
            }
            if (e !== null) {
                e = Number(e);
                if (isNaN(e)) {
                    e = null;
                }
            }
            return e;
        },
        updateZIndex: function(e) {
            var t = this.element, i;
            if (t && !t.isDestroyed) {
                i = t.dom.style;
                if (e !== null) {
                    i.setProperty("z-index", e, "important");
                } else {
                    i.removeProperty("z-index");
                }
            }
        },
        getInnerHtmlElement: function() {
            var e = this.innerHtmlElement, t = this.getStyleHtmlCls();
            if (!e || !e.dom || !e.dom.parentNode) {
                this.innerHtmlElement = e = this.innerElement.createChild({
                    cls: "x-innerhtml "
                });
                if (this.getStyleHtmlContent()) {
                    this.innerHtmlElement.addCls(t);
                    this.innerElement.removeCls(t);
                }
            }
            return e;
        },
        updateHtml: function(e) {
            var t = this.getInnerHtmlElement();
            if (Ext.isElement(e)) {
                t.setHtml("");
                t.append(e);
            } else {
                t.setHtml(e);
            }
        },
        applyHidden: function(e) {
            return Boolean(e);
        },
        doSetHidden: function(e) {
            var t = this.renderElement;
            if (t.isDestroyed) {
                return;
            }
            if (e) {
                t.hide();
            } else {
                t.show();
            }
            if (this.element) {
                this.element[e ? "addCls" : "removeCls"](this.getHiddenCls());
            }
            this.fireEvent(e ? "hide" : "show", this);
        },
        updateHiddenCls: function(e, t) {
            if (this.isHidden()) {
                this.element.replaceCls(t, e);
            }
        },
        isHidden: function() {
            return this.getHidden();
        },
        hide: function(e) {
            if (!this.getHidden()) {
                if (e === undefined || e && e.isComponent) {
                    e = this.getHideAnimation();
                }
                if (e) {
                    if (e === true) {
                        e = "fadeOut";
                    }
                    this.onBefore({
                        hiddenchange: "animateFn",
                        scope: this,
                        single: true,
                        args: [ e ]
                    });
                }
                this.setHidden(true);
            }
            return this;
        },
        show: function(e) {
            var t = this.getHidden();
            if (t || t === null) {
                if (e === true) {
                    e = "fadeIn";
                } else if (e === undefined || e && e.isComponent) {
                    e = this.getShowAnimation();
                }
                if (e) {
                    this.onBefore({
                        hiddenchange: "animateFn",
                        scope: this,
                        single: true,
                        args: [ e ]
                    });
                }
                this.setHidden(false);
            }
            return this;
        },
        animateFn: function(e, t, i, n, r, s) {
            if (e && (!i || i && this.isPainted())) {
                var a = new Ext.fx.Animation(e);
                a.setElement(t.element);
                if (i) {
                    a.setOnEnd(function() {
                        s.resume();
                    });
                    s.pause();
                }
                Ext.Animator.run(a);
            }
        },
        setVisibility: function(e) {
            this.renderElement.setVisibility(e);
        },
        isRendered: function() {
            return this.rendered;
        },
        isPainted: function() {
            return this.renderElement.isPainted();
        },
        applyTpl: function(e) {
            return Ext.isObject(e) && e.isTemplate ? e : new Ext.XTemplate(e);
        },
        applyData: function(e) {
            if (Ext.isObject(e)) {
                return Ext.apply({}, e);
            } else if (!e) {
                e = {};
            }
            return e;
        },
        updateData: function(e) {
            var t = this;
            if (e) {
                var i = t.getTpl(), n = t.getTplWriteMode();
                if (i) {
                    i[n](t.getInnerHtmlElement(), e);
                }
                this.fireEvent("updatedata", t, e);
            }
        },
        applyRecord: function(e) {
            if (e && Ext.isObject(e) && e.isModel) {
                return e;
            }
            return null;
        },
        updateRecord: function(e, t) {
            var i = this;
            if (t) {
                t.unjoin(i);
            }
            if (!e) {
                i.updateData("");
            } else {
                e.join(i);
                i.updateData(e.getData(true));
            }
        },
        afterEdit: function() {
            this.updateRecord(this.getRecord());
        },
        afterErase: function() {
            this.setRecord(null);
        },
        applyItemId: function(e) {
            return e || this.getId();
        },
        isXType: function(e, t) {
            if (t) {
                return this.xtypes.indexOf(e) != -1;
            }
            return Boolean(this.xtypesMap[e]);
        },
        getXTypes: function() {
            return this.xtypesChain.join("/");
        },
        getDraggableBehavior: function() {
            var e = this.draggableBehavior;
            if (!e) {
                e = this.draggableBehavior = new Ext.behavior.Draggable(this);
            }
            return e;
        },
        applyDraggable: function(e) {
            this.getDraggableBehavior().setConfig(e);
        },
        getDraggable: function() {
            return this.getDraggableBehavior().getDraggable();
        },
        getTranslatableBehavior: function() {
            var e = this.translatableBehavior;
            if (!e) {
                e = this.translatableBehavior = new Ext.behavior.Translatable(this);
            }
            return e;
        },
        applyTranslatable: function(e) {
            this.getTranslatableBehavior().setConfig(e);
        },
        getTranslatable: function() {
            return this.getTranslatableBehavior().getTranslatable();
        },
        translateAxis: function(e, t, i) {
            var n, r;
            if (e === "x") {
                n = t;
            } else {
                r = t;
            }
            return this.translate(n, r, i);
        },
        translate: function() {
            var e = this.getTranslatable();
            if (!e) {
                this.setTranslatable(true);
                e = this.getTranslatable();
            }
            e.translate.apply(e, arguments);
        },
        setRendered: function(e) {
            var t = this.rendered;
            if (e !== t) {
                this.rendered = e;
                return true;
            }
            return false;
        },
        setSize: function(e, t) {
            if (e != undefined) {
                this.setWidth(e);
            }
            if (t != undefined) {
                this.setHeight(t);
            }
        },
        doAddListener: function(e, t, i, n, r) {
            if (n && "element" in n) {
                if (this.referenceList.indexOf(n.element) === -1) {
                    Ext.Logger.error("Adding event listener with an invalid element reference of '" + n.element + "' for this component. Available values are: '" + this.referenceList.join("', '") + "'", this);
                }
                return this[n.element].doAddListener(e, t, i || this, n, r);
            }
            if (e == "painted" || e == "resize") {
                return this.element.doAddListener(e, t, i || this, n, r);
            }
            return this.callParent(arguments);
        },
        doRemoveListener: function(e, t, i, n, r) {
            if (n && "element" in n) {
                if (this.referenceList.indexOf(n.element) === -1) {
                    Ext.Logger.error("Removing event listener with an invalid element reference of '" + n.element + "' for this component. Available values are: '" + this.referenceList.join('", "') + "'", this);
                }
                this[n.element].doRemoveListener(e, t, i || this, n, r);
            }
            if (e == "painted" || e == "resize") {
                return this.element.doRemoveListener(e, t, i, n, r);
            }
            return this.callParent(arguments);
        },
        showBy: function(e, t) {
            var i = this, n = Ext.Viewport, r = i.getParent();
            i.setVisibility(false);
            if (r !== n) {
                n.add(i);
            }
            i.show();
            i.on({
                hide: "onShowByErased",
                destroy: "onShowByErased",
                single: true,
                scope: i
            });
            n.on("resize", "alignTo", i, {
                args: [ e, t ]
            });
            i.alignTo(e, t);
            i.setVisibility(true);
        },
        onShowByErased: function() {
            Ext.Viewport.un("resize", "alignTo", this);
        },
        alignTo: function(e, t) {
            var i = e.isComponent ? e.renderElement : e, n = this.renderElement, r = i.getPageBox(), s = this.getParent().element.getPageBox(), a = n.getPageBox(), o = r.height, l = r.width, u = a.height, c = a.width;
            s.bottom -= 5;
            s.height -= 10;
            s.left += 5;
            s.right -= 5;
            s.top += 5;
            s.width -= 10;
            if (!t || t === "auto") {
                if (s.bottom - r.bottom < u) {
                    if (r.top - s.top < u) {
                        if (r.left - s.left < c) {
                            t = "cl-cr?";
                        } else {
                            t = "cr-cl?";
                        }
                    } else {
                        t = "bc-tc?";
                    }
                } else {
                    t = "tc-bc?";
                }
            }
            var f = t.match(this.alignmentRegex);
            if (!f) {
                Ext.Logger.error("Invalid alignment value of '" + t + "'");
            }
            var d = f[1].split(""), h = f[2].split(""), g = f[3] === "?", p = d[0], m = d[1] || p, x = h[0], E = h[1] || x, y = r.top, v = r.left, b = o / 2, S = l / 2, C = c / 2, w = u / 2, T, I;
            switch (p) {
              case "t":
                switch (x) {
                  case "c":
                    y += b;
                    break;

                  case "b":
                    y += o;
                }
                break;

              case "b":
                switch (x) {
                  case "c":
                    y -= u - b;
                    break;

                  case "t":
                    y -= u;
                    break;

                  case "b":
                    y -= u - o;
                }
                break;

              case "c":
                switch (x) {
                  case "t":
                    y -= w;
                    break;

                  case "c":
                    y -= w - b;
                    break;

                  case "b":
                    y -= w - o;
                }
                break;
            }
            switch (m) {
              case "l":
                switch (E) {
                  case "c":
                    v += b;
                    break;

                  case "r":
                    v += l;
                }
                break;

              case "r":
                switch (E) {
                  case "r":
                    v -= c - l;
                    break;

                  case "c":
                    v -= c - C;
                    break;

                  case "l":
                    v -= c;
                }
                break;

              case "c":
                switch (E) {
                  case "l":
                    v -= C;
                    break;

                  case "c":
                    v -= C - S;
                    break;

                  case "r":
                    v -= C - l;
                }
                break;
            }
            if (g) {
                T = s.left + s.width - c;
                I = s.top + s.height - u;
                v = Math.max(s.left, Math.min(T, v));
                y = Math.max(s.top, Math.min(I, y));
            }
            this.setLeft(v);
            this.setTop(y);
        },
        up: function(e) {
            var t = this.parent;
            if (e) {
                for (;t; t = t.parent) {
                    if (Ext.ComponentQuery.is(t, e)) {
                        return t;
                    }
                }
            }
            return t;
        },
        getBubbleTarget: function() {
            return this.getParent();
        },
        destroy: function() {
            this.destroy = Ext.emptyFn;
            var e = this.getParent(), t = this.referenceList, i, n, r;
            this.isDestroying = true;
            Ext.destroy(this.getTranslatable(), this.getPlugins());
            if (e) {
                e.remove(this, false);
            }
            for (i = 0, n = t.length; i < n; i++) {
                r = t[i];
                this[r].destroy();
                delete this[r];
            }
            Ext.destroy(this.innerHtmlElement);
            this.setRecord(null);
            this.callSuper();
            Ext.ComponentManager.unregister(this);
        },
        onClassExtended: function(e, t) {
            var i = this, n = i.prototype.config, r = t.config || {}, s;
            for (s in n) {
                if (s in t) {
                    r[s] = t[s];
                    delete t[s];
                    Ext.Logger.deprecate(s + " is deprecated as a property directly on the Component. " + 'Please put it inside the config object, and retrieve it using "this.config.' + s + '"');
                }
            }
            t.config = r;
        }
    }, function() {
        var e = Ext.emptyFn;
        this.override({
            constructor: function(t) {
                var i;
                if (t) {
                    if (t.enabled) {
                        Ext.Logger.deprecate("'enabled' config is deprecated, please use 'disabled' config instead", this);
                        t.disabled = !t.enabled;
                    }
                    if ((t.scroll || this.config.scroll || this.scrollable || this.config.scrollable) && !this.isContainer) {
                        Ext.Logger.deprecate("You are no longer able to scroll a component. Please use a Ext.Container instead.", this);
                        delete t.scrollable;
                        delete t.scroll;
                    }
                    if ((t.hideOnMaskTap || this.config.hideOnMaskTap) && !this.isContainer) {
                        Ext.Logger.deprecate("You are no longer able use hideOnMaskTap on a component. Please use a Ext.Container instead.", this);
                        delete t.hideOnMaskTap;
                    }
                    if ((t.modal || this.config.modal) && !this.isContainer) {
                        Ext.Logger.deprecate("You are no longer able use modal on a component. Please use a Ext.Container instead.", this);
                        delete t.modal;
                    }
                    if (t.dock) {
                        Ext.Logger.deprecate("'dock' config for docked items is deprecated, please use 'docked' instead");
                        t.docked = t.dock;
                        delete t.dock;
                    }
                    if (t.enterAnimation) {
                        Ext.Logger.deprecate("'enterAnimation' config for Components is deprecated, please use 'showAnimation' instead");
                        t.showAnimation = t.enterAnimation;
                        delete t.enterAnimation;
                    }
                    if (t.exitAnimation) {
                        Ext.Logger.deprecate("'exitAnimation' config for Components is deprecated, please use 'hideAnimation' instead");
                        t.hideAnimation = t.exitAnimation;
                        delete t.exitAnimation;
                    }
                    if (t.componentCls) {
                        Ext.Logger.deprecate("'componentCls' config is deprecated, please use 'cls' config instead", this);
                        t.cls = t.componentCls;
                    }
                    if (t.floating) {
                        Ext.Logger.deprecate("'floating' config is deprecated, please set 'left', 'right', " + "'top' or 'bottom' config instead", this);
                        t.left = t.left || 0;
                    }
                    for (i in t) {
                        if (t.hasOwnProperty(i) && i !== "xtype" && i !== "xclass" && !this.hasConfig(i)) {
                            this[i] = t[i];
                        }
                    }
                    if (t.layoutOnOrientationChange) {
                        Ext.Logger.deprecate("'layoutOnOrientationChange' has been fully removed and no longer used");
                        delete t.layoutOnOrientationChange;
                    }
                    if (t.monitorOrientation) {
                        Ext.Logger.deprecate("'monitorOrientation' has been removed. If you need to monitor the orientation, please use the 'resize' event.");
                        delete t.monitorOrientation;
                    }
                    if (t.stopMaskTapEvent) {
                        Ext.Logger.deprecate("'stopMaskTapEvent' has been removed.");
                        delete t.stopMaskTapEvent;
                    }
                }
                this.callParent(arguments);
                if (this.onRender !== e) {
                    Ext.Logger.deprecate("onRender() is deprecated, please put your code inside initialize() instead", this);
                    this.onRender();
                }
                if (this.afterRender !== e) {
                    Ext.Logger.deprecate("afterRender() is deprecated, please put your code inside initialize() instead", this);
                    this.afterRender();
                }
                if (this.initEvents !== e) {
                    Ext.Logger.deprecate("initEvents() is deprecated, please put your code inside initialize() instead", this);
                    this.initEvents();
                }
                if (this.initComponent !== e) {
                    Ext.Logger.deprecate("initComponent() is deprecated, please put your code inside initialize() instead", this);
                    this.initComponent();
                }
                if (this.setOrientation !== e) {
                    Ext.Logger.deprecate("setOrientation() is deprecated", this);
                    this.setOrientation();
                }
            },
            onRender: e,
            afterRender: e,
            initEvents: e,
            initComponent: e,
            setOrientation: e,
            show: function() {
                if (this.renderElement.dom) {
                    var e = this.renderElement.dom.parentNode;
                    if (e && e.nodeType == 11) {
                        Ext.Logger.deprecate("Call show() on a component that doesn't currently belong to any container. " + "Please add it to the the Viewport first, i.e: Ext.Viewport.add(component);", this);
                        Ext.Viewport.add(this);
                    }
                }
                return this.callParent(arguments);
            },
            doAddListener: function(e, t, i, n, r) {
                switch (e) {
                  case "render":
                    Ext.Logger.warn("The render event on Components is deprecated. Please use the painted event. " + "Please refer to: http://bit.ly/xgv3K1 for more details.", this);
                    return this;
                    break;
                }
                return this.callOverridden(arguments);
            },
            addListener: function(e) {
                if (arguments.length === 1 && Ext.isObject(e) && ("el" in e || "body" in e)) {
                    Ext.Logger.error("Adding component element listeners using the old format is no longer supported. " + "Please refer to: http://bit.ly/xHCyfa for more details.", this);
                }
                return this.callOverridden(arguments);
            },
            getEl: function() {
                Ext.Logger.deprecate("getEl() is deprecated, please access the Component's element from " + "the 'element' property instead", this);
                return this.renderElement;
            },
            setFloating: function(e) {
                var t = this.isFloating();
                if (e && !t) {
                    this.setTop(0);
                } else if (t) {
                    this.resetFloating();
                }
            },
            setScrollable: function() {
                Ext.Logger.deprecate("Ext.Component cannot be scrollable. Please use Ext.Container#setScrollable on a Ext.Container.", this);
                return false;
            }
        });
        Ext.deprecateClassMembers(this, {
            el: "element",
            body: "element",
            outer: "renderElement",
            ownerCt: "parent",
            update: "setHtml"
        });
    });
})(Ext.baseCSSPrefix);

Ext.define("Ext.event.publisher.ComponentDelegation", {
    extend: "Ext.event.publisher.Publisher",
    requires: [ "Ext.Component", "Ext.ComponentQuery" ],
    targetType: "component",
    optimizedSelectorRegex: /^#([\w\-]+)((?:[\s]*)>(?:[\s]*)|(?:\s*))([\w\-]+)$/i,
    handledEvents: [ "*" ],
    getSubscribers: function(e, t) {
        var i = this.subscribers, n = i[e];
        if (!n && t) {
            n = i[e] = {
                type: {
                    $length: 0
                },
                selector: [],
                $length: 0
            };
        }
        return n;
    },
    subscribe: function(e, t) {
        if (this.idSelectorRegex.test(e)) {
            return false;
        }
        var i = e.match(this.optimizedSelectorRegex), n = this.getSubscribers(t, true), r = n.type, s = n.selector, a, o, l, u, c;
        if (i !== null) {
            a = i[1];
            o = i[2].indexOf(">") === -1;
            l = i[3];
            u = r[l];
            if (!u) {
                r[l] = u = {
                    descendents: {
                        $length: 0
                    },
                    children: {
                        $length: 0
                    },
                    $length: 0
                };
            }
            c = o ? u.descendents : u.children;
            if (c.hasOwnProperty(a)) {
                c[a]++;
                return true;
            }
            c[a] = 1;
            c.$length++;
            u.$length++;
            r.$length++;
        } else {
            if (s.hasOwnProperty(e)) {
                s[e]++;
                return true;
            }
            s[e] = 1;
            s.push(e);
        }
        n.$length++;
        return true;
    },
    unsubscribe: function(e, t, i) {
        var n = this.getSubscribers(t);
        if (!n) {
            return false;
        }
        var r = e.match(this.optimizedSelectorRegex), s = n.type, a = n.selector, o, l, u, c, f;
        i = Boolean(i);
        if (r !== null) {
            o = r[1];
            l = r[2].indexOf(">") === -1;
            u = r[3];
            c = s[u];
            if (!c) {
                return true;
            }
            f = l ? c.descendents : c.children;
            if (!f.hasOwnProperty(o) || !i && --f[o] > 0) {
                return true;
            }
            delete f[o];
            f.$length--;
            c.$length--;
            s.$length--;
        } else {
            if (!a.hasOwnProperty(e) || !i && --a[e] > 0) {
                return true;
            }
            delete a[e];
            Ext.Array.remove(a, e);
        }
        if (--n.$length === 0) {
            delete this.subscribers[t];
        }
        return true;
    },
    notify: function(e, t) {
        var i = this.getSubscribers(t), n, r;
        if (!i || i.$length === 0) {
            return false;
        }
        n = e.substr(1);
        r = Ext.ComponentManager.get(n);
        if (r) {
            this.dispatcher.doAddListener(this.targetType, e, t, "publish", this, {
                args: [ t, r ]
            }, "before");
        }
    },
    matchesSelector: function(e, t) {
        return Ext.ComponentQuery.is(e, t);
    },
    dispatch: function(e, t, i, n) {
        this.dispatcher.doDispatchEvent(this.targetType, e, t, i, null, n);
    },
    publish: function(e, t) {
        var i = this.getSubscribers(e);
        if (!i) {
            return;
        }
        var n = arguments[arguments.length - 1], r = i.type, s = i.selector, a = Array.prototype.slice.call(arguments, 2, -2), o = t.xtypesChain, l, u, c, f, d, h, g, p, m, x, E, y;
        for (p = 0, m = o.length; p < m; p++) {
            x = o[p];
            i = r[x];
            if (i && i.$length > 0) {
                l = i.descendents;
                if (l.$length > 0) {
                    if (!f) {
                        f = t.getAncestorIds();
                    }
                    for (E = 0, y = f.length; E < y; E++) {
                        d = f[E];
                        if (l.hasOwnProperty(d)) {
                            this.dispatch("#" + d + " " + x, e, a, n);
                        }
                    }
                }
                u = i.children;
                if (u.$length > 0) {
                    if (!c) {
                        if (f) {
                            c = f[0];
                        } else {
                            h = t.getParent();
                            if (h) {
                                c = h.getId();
                            }
                        }
                    }
                    if (c) {
                        if (u.hasOwnProperty(c)) {
                            this.dispatch("#" + c + " > " + x, e, a, n);
                        }
                    }
                }
            }
        }
        m = s.length;
        if (m > 0) {
            for (p = 0; p < m; p++) {
                g = s[p];
                if (this.matchesSelector(t, g)) {
                    this.dispatch(g, e, a, n);
                }
            }
        }
    }
});

Ext.define("Ext.event.publisher.ComponentPaint", {
    extend: "Ext.event.publisher.Publisher",
    targetType: "component",
    handledEvents: [ "erased" ],
    eventNames: {
        painted: "painted",
        erased: "erased"
    },
    constructor: function() {
        this.callParent(arguments);
        this.hiddenQueue = {};
        this.renderedQueue = {};
    },
    getSubscribers: function(e, t) {
        var i = this.subscribers;
        if (!i.hasOwnProperty(e)) {
            if (!t) {
                return null;
            }
            i[e] = {
                $length: 0
            };
        }
        return i[e];
    },
    setDispatcher: function(e) {
        var t = this.targetType;
        e.doAddListener(t, "*", "renderedchange", "onBeforeComponentRenderedChange", this, null, "before");
        e.doAddListener(t, "*", "hiddenchange", "onBeforeComponentHiddenChange", this, null, "before");
        e.doAddListener(t, "*", "renderedchange", "onComponentRenderedChange", this, null, "after");
        e.doAddListener(t, "*", "hiddenchange", "onComponentHiddenChange", this, null, "after");
        return this.callParent(arguments);
    },
    subscribe: function(e, t) {
        var i = e.match(this.idSelectorRegex), n, r;
        if (!i) {
            return false;
        }
        r = i[1];
        n = this.getSubscribers(t, true);
        if (n.hasOwnProperty(r)) {
            n[r]++;
            return true;
        }
        n[r] = 1;
        n.$length++;
        return true;
    },
    unsubscribe: function(e, t, i) {
        var n = e.match(this.idSelectorRegex), r, s;
        if (!n || !(r = this.getSubscribers(t))) {
            return false;
        }
        s = n[1];
        if (!r.hasOwnProperty(s) || !i && --r[s] > 0) {
            return true;
        }
        delete r[s];
        if (--r.$length === 0) {
            delete this.subscribers[t];
        }
        return true;
    },
    onBeforeComponentRenderedChange: function(e, t, i) {
        var n = this.eventNames, r = i ? n.painted : n.erased, s = this.getSubscribers(r), a;
        if (s && s.$length > 0) {
            this.renderedQueue[t.getId()] = a = [];
            this.publish(s, t, r, a);
        }
    },
    onBeforeComponentHiddenChange: function(e, t) {
        var i = this.eventNames, n = t ? i.erased : i.painted, r = this.getSubscribers(n), s;
        if (r && r.$length > 0) {
            this.hiddenQueue[e.getId()] = s = [];
            this.publish(r, e, n, s);
        }
    },
    onComponentRenderedChange: function(e, t) {
        var i = this.renderedQueue, n = t.getId(), r;
        if (!i.hasOwnProperty(n)) {
            return;
        }
        r = i[n];
        delete i[n];
        if (r.length > 0) {
            this.dispatchQueue(r);
        }
    },
    onComponentHiddenChange: function(e) {
        var t = this.hiddenQueue, i = e.getId(), n;
        if (!t.hasOwnProperty(i)) {
            return;
        }
        n = t[i];
        delete t[i];
        if (n.length > 0) {
            this.dispatchQueue(n);
        }
    },
    dispatchQueue: function(e) {
        var t = this.dispatcher, i = this.targetType, n = this.eventNames, r = e.slice(), s = r.length, a, o, l, u, c;
        e.length = 0;
        if (s > 0) {
            for (a = 0; a < s; a++) {
                o = r[a];
                l = o.component;
                u = o.eventName;
                c = l.isPainted();
                if (u === n.painted && c || u === n.erased && !c) {
                    t.doDispatchEvent(i, "#" + o.id, u, [ l ]);
                }
            }
            r.length = 0;
        }
    },
    publish: function(e, t, i, n) {
        var r = t.getId(), s = false, a, o, l, u, c;
        if (e[r]) {
            a = this.eventNames;
            c = t.isPainted();
            if (i === a.painted && !c || i === a.erased && c) {
                s = true;
            } else {
                return this;
            }
        }
        if (t.isContainer) {
            o = t.getItems().items;
            for (l = 0, u = o.length; l < u; l++) {
                this.publish(e, o[l], i, n);
            }
        } else if (t.isDecorator) {
            this.publish(e, t.getComponent(), i, n);
        }
        if (s) {
            n.push({
                id: r,
                eventName: i,
                component: t
            });
        }
    }
});

(function() {
    var e = 0, t = [ "ms", "moz", "webkit", "o" ], i = t.length, n, r;
    for (n = 0; n < i && !window.requestAnimationFrame; ++n) {
        r = t[n];
        window.requestAnimationFrame = window[r + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[r + "CancelAnimationFrame"] || window[r + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(t, i) {
            var n = new Date().getTime(), r = Math.max(0, 16 - (n - e)), s = window.setTimeout(function() {
                t(n + r);
            }, r);
            e = n + r;
            return s;
        };
    }
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(e) {
            clearTimeout(e);
        };
    }
})();

Ext.define("Ext.TaskQueue", {
    singleton: true,
    pending: false,
    mode: true,
    constructor: function() {
        this.readQueue = [];
        this.writeQueue = [];
        this.run = Ext.Function.bind(this.run, this);
    },
    requestRead: function(e, t, i) {
        this.request(true);
        this.readQueue.push(arguments);
    },
    requestWrite: function(e, t, i) {
        this.request(false);
        this.writeQueue.push(arguments);
    },
    request: function(e) {
        if (!this.pending) {
            this.pending = true;
            this.mode = e;
            requestAnimationFrame(this.run);
        }
    },
    run: function() {
        this.pending = false;
        var e = this.readQueue, t = this.writeQueue, i = null, n;
        if (this.mode) {
            n = e;
            if (t.length > 0) {
                i = false;
            }
        } else {
            n = t;
            if (e.length > 0) {
                i = true;
            }
        }
        var r = n.slice(), s, a, o, l, u;
        n.length = 0;
        for (s = 0, a = r.length; s < a; s++) {
            o = r[s];
            l = o[0];
            u = o[1];
            if (typeof l == "string") {
                l = u[l];
            }
            if (o.length > 2) {
                l.apply(u, o[2]);
            } else {
                l.call(u);
            }
        }
        r.length = 0;
        if (i !== null) {
            this.request(i);
        }
    }
});

Ext.define("Ext.util.paintmonitor.Abstract", {
    config: {
        element: null,
        callback: Ext.emptyFn,
        scope: null,
        args: []
    },
    eventName: "",
    monitorClass: "",
    constructor: function(e) {
        this.onElementPainted = Ext.Function.bind(this.onElementPainted, this);
        this.initConfig(e);
    },
    bindListeners: function(e) {
        this.monitorElement[e ? "addEventListener" : "removeEventListener"](this.eventName, this.onElementPainted, true);
    },
    applyElement: function(e) {
        if (e) {
            return Ext.get(e);
        }
    },
    updateElement: function(e) {
        this.monitorElement = Ext.Element.create({
            classList: [ "x-paint-monitor", this.monitorClass ]
        }, true);
        e.appendChild(this.monitorElement);
        e.addCls("x-paint-monitored");
        this.bindListeners(true);
    },
    onElementPainted: function() {},
    destroy: function() {
        var e = this.monitorElement, t = e.parentNode, i = this.getElement();
        this.bindListeners(false);
        delete this.monitorElement;
        if (i && !i.isDestroyed) {
            i.removeCls("x-paint-monitored");
            delete this._element;
        }
        if (t) {
            t.removeChild(e);
        }
        this.callSuper();
    }
});

Ext.define("Ext.util.paintmonitor.CssAnimation", {
    extend: "Ext.util.paintmonitor.Abstract",
    eventName: "webkitAnimationEnd",
    monitorClass: "cssanimation",
    onElementPainted: function(e) {
        if (e.animationName === "x-paint-monitor-helper") {
            this.getCallback().apply(this.getScope(), this.getArgs());
        }
    }
});

Ext.define("Ext.util.paintmonitor.OverflowChange", {
    extend: "Ext.util.paintmonitor.Abstract",
    eventName: "overflowchanged",
    monitorClass: "overflowchange",
    onElementPainted: function(e) {
        this.getCallback().apply(this.getScope(), this.getArgs());
    }
});

Ext.define("Ext.util.PaintMonitor", {
    requires: [ "Ext.util.paintmonitor.CssAnimation", "Ext.util.paintmonitor.OverflowChange" ],
    constructor: function(e) {
        if (Ext.browser.engineVersion.gtEq("536") && !Ext.os.is.BlackBerry) {
            return new Ext.util.paintmonitor.OverflowChange(e);
        } else {
            return new Ext.util.paintmonitor.CssAnimation(e);
        }
    }
});

Ext.define("Ext.event.publisher.ElementPaint", {
    extend: "Ext.event.publisher.Publisher",
    requires: [ "Ext.util.PaintMonitor", "Ext.TaskQueue" ],
    targetType: "element",
    handledEvents: [ "painted" ],
    constructor: function() {
        this.monitors = {};
        this.callSuper(arguments);
    },
    subscribe: function(e) {
        var t = e.match(this.idSelectorRegex), i = this.subscribers, n, r;
        if (!t) {
            return false;
        }
        n = t[1];
        if (i.hasOwnProperty(n)) {
            i[n]++;
            return true;
        }
        i[n] = 1;
        r = Ext.get(n);
        this.monitors[n] = new Ext.util.PaintMonitor({
            element: r,
            callback: this.onElementPainted,
            scope: this,
            args: [ e, r ]
        });
        return true;
    },
    unsubscribe: function(e, t, i) {
        var n = e.match(this.idSelectorRegex), r = this.subscribers, s;
        if (!n) {
            return false;
        }
        s = n[1];
        if (!r.hasOwnProperty(s) || !i && --r[s] > 0) {
            return true;
        }
        delete r[s];
        this.monitors[s].destroy();
        delete this.monitors[s];
        return true;
    },
    onElementPainted: function(e, t) {
        Ext.TaskQueue.requestRead("dispatch", this, [ e, "painted", [ t ] ]);
    }
});

Ext.define("Ext.mixin.Templatable", {
    extend: "Ext.mixin.Mixin",
    mixinConfig: {
        id: "templatable"
    },
    referenceAttributeName: "reference",
    referenceSelector: "[reference]",
    getElementConfig: function() {
        return {
            reference: "element"
        };
    },
    getElementTemplate: function() {
        var e = document.createDocumentFragment();
        e.appendChild(Ext.Element.create(this.getElementConfig(), true));
        return e;
    },
    initElement: function() {
        var e = this.self.prototype;
        e.elementTemplate = this.getElementTemplate();
        e.initElement = e.doInitElement;
        this.initElement.apply(this, arguments);
    },
    linkElement: function(e, t) {
        this.link(e, t);
    },
    doInitElement: function() {
        var e = this.referenceAttributeName, t, i, n, r, s, a;
        t = this.elementTemplate.cloneNode(true);
        i = t.querySelectorAll(this.referenceSelector);
        for (n = 0, r = i.length; n < r; n++) {
            s = i[n];
            a = s.getAttribute(e);
            s.removeAttribute(e);
            this.linkElement(a, s);
        }
    }
});

Ext.define("Ext.util.sizemonitor.Abstract", {
    mixins: [ "Ext.mixin.Templatable" ],
    requires: [ "Ext.TaskQueue" ],
    config: {
        element: null,
        callback: Ext.emptyFn,
        scope: null,
        args: []
    },
    width: 0,
    height: 0,
    contentWidth: 0,
    contentHeight: 0,
    constructor: function(e) {
        this.refresh = Ext.Function.bind(this.refresh, this);
        this.info = {
            width: 0,
            height: 0,
            contentWidth: 0,
            contentHeight: 0,
            flag: 0
        };
        this.initElement();
        this.initConfig(e);
        this.bindListeners(true);
    },
    bindListeners: Ext.emptyFn,
    applyElement: function(e) {
        if (e) {
            return Ext.get(e);
        }
    },
    updateElement: function(e) {
        e.append(this.detectorsContainer);
        e.addCls("x-size-monitored");
    },
    applyArgs: function(e) {
        return e.concat([ this.info ]);
    },
    refreshMonitors: Ext.emptyFn,
    forceRefresh: function() {
        Ext.TaskQueue.requestRead("refresh", this);
    },
    getContentBounds: function() {
        return this.detectorsContainer.getBoundingClientRect();
    },
    refreshSize: function() {
        var e = this.getElement();
        if (!e || e.isDestroyed) {
            return false;
        }
        var t = e.dom.getBoundingClientRect(), i = t.width, n = t.height, r = this.getContentBounds(), s = r.width, a = r.height, o = this.contentWidth, l = this.contentHeight, u = this.info, c = false, f;
        this.width = i;
        this.height = n;
        this.contentWidth = s;
        this.contentHeight = a;
        f = (o !== s ? 1 : 0) + (l !== a ? 2 : 0);
        if (f > 0) {
            u.width = i;
            u.height = n;
            u.contentWidth = s;
            u.contentHeight = a;
            u.flag = f;
            c = true;
            this.getCallback().apply(this.getScope(), this.getArgs());
        }
        return c;
    },
    refresh: function(e) {
        if (this.refreshSize() || e) {
            Ext.TaskQueue.requestWrite("refreshMonitors", this);
        }
    },
    destroy: function() {
        var e = this.getElement();
        this.bindListeners(false);
        if (e && !e.isDestroyed) {
            e.removeCls("x-size-monitored");
        }
        delete this._element;
        this.callSuper();
    }
});

Ext.define("Ext.util.sizemonitor.Scroll", {
    extend: "Ext.util.sizemonitor.Abstract",
    getElementConfig: function() {
        return {
            reference: "detectorsContainer",
            classList: [ "x-size-monitors", "scroll" ],
            children: [ {
                reference: "expandMonitor",
                className: "expand"
            }, {
                reference: "shrinkMonitor",
                className: "shrink"
            } ]
        };
    },
    constructor: function(e) {
        this.onScroll = Ext.Function.bind(this.onScroll, this);
        this.callSuper(arguments);
    },
    bindListeners: function(e) {
        var t = e ? "addEventListener" : "removeEventListener";
        this.expandMonitor[t]("scroll", this.onScroll, true);
        this.shrinkMonitor[t]("scroll", this.onScroll, true);
    },
    forceRefresh: function() {
        Ext.TaskQueue.requestRead("refresh", this, [ true ]);
    },
    onScroll: function() {
        Ext.TaskQueue.requestRead("refresh", this);
    },
    refreshMonitors: function() {
        var e = this.expandMonitor, t = this.shrinkMonitor, i = 1e6;
        if (e && !e.isDestroyed) {
            e.scrollLeft = i;
            e.scrollTop = i;
        }
        if (t && !t.isDestroyed) {
            t.scrollLeft = i;
            t.scrollTop = i;
        }
    }
});

Ext.define("Ext.util.sizemonitor.OverflowChange", {
    extend: "Ext.util.sizemonitor.Abstract",
    constructor: function(e) {
        this.onExpand = Ext.Function.bind(this.onExpand, this);
        this.onShrink = Ext.Function.bind(this.onShrink, this);
        this.callSuper(arguments);
    },
    getElementConfig: function() {
        return {
            reference: "detectorsContainer",
            classList: [ "x-size-monitors", "overflowchanged" ],
            children: [ {
                reference: "expandMonitor",
                className: "expand",
                children: [ {
                    reference: "expandHelper"
                } ]
            }, {
                reference: "shrinkMonitor",
                className: "shrink",
                children: [ {
                    reference: "shrinkHelper"
                } ]
            } ]
        };
    },
    bindListeners: function(e) {
        var t = e ? "addEventListener" : "removeEventListener";
        this.expandMonitor[t]("overflowchanged", this.onExpand, true);
        this.shrinkMonitor[t]("overflowchanged", this.onShrink, true);
    },
    onExpand: function(e) {
        if (e.horizontalOverflow && e.verticalOverflow) {
            return;
        }
        Ext.TaskQueue.requestRead("refresh", this);
    },
    onShrink: function(e) {
        if (!e.horizontalOverflow && !e.verticalOverflow) {
            return;
        }
        Ext.TaskQueue.requestRead("refresh", this);
    },
    refreshMonitors: function() {
        var e = this.expandHelper, t = this.shrinkHelper, i = this.getContentBounds(), n = i.width, r = i.height, s;
        if (e && !e.isDestroyed) {
            s = e.style;
            s.width = n + 1 + "px";
            s.height = r + 1 + "px";
        }
        if (t && !t.isDestroyed) {
            s = t.style;
            s.width = n + "px";
            s.height = r + "px";
        }
        Ext.TaskQueue.requestRead("refresh", this);
    }
});

Ext.define("Ext.util.SizeMonitor", {
    requires: [ "Ext.util.sizemonitor.Scroll", "Ext.util.sizemonitor.OverflowChange" ],
    constructor: function(e) {
        if (Ext.browser.engineVersion.gtEq("535")) {
            return new Ext.util.sizemonitor.OverflowChange(e);
        } else {
            return new Ext.util.sizemonitor.Scroll(e);
        }
    }
});

Ext.define("Ext.event.publisher.ElementSize", {
    extend: "Ext.event.publisher.Publisher",
    requires: [ "Ext.util.SizeMonitor" ],
    targetType: "element",
    handledEvents: [ "resize" ],
    constructor: function() {
        this.monitors = {};
        this.callSuper(arguments);
    },
    subscribe: function(e) {
        var t = e.match(this.idSelectorRegex), i = this.subscribers, n, r, s;
        if (!t) {
            return false;
        }
        n = t[1];
        if (i.hasOwnProperty(n)) {
            i[n]++;
            return true;
        }
        i[n] = 1;
        r = Ext.get(n);
        this.monitors[n] = s = new Ext.util.SizeMonitor({
            element: r,
            callback: this.onElementResize,
            scope: this,
            args: [ e, r ]
        });
        this.dispatcher.addListener("element", e, "painted", "forceRefresh", s);
        return true;
    },
    unsubscribe: function(e, t, i) {
        var n = e.match(this.idSelectorRegex), r = this.subscribers, s = this.monitors, a, o;
        if (!n) {
            return false;
        }
        a = n[1];
        if (!r.hasOwnProperty(a) || !i && --r[a] > 0) {
            return true;
        }
        delete r[a];
        o = s[a];
        this.dispatcher.removeListener("element", e, "painted", "forceRefresh", o);
        o.destroy();
        delete s[a];
        return true;
    },
    onElementResize: function(e, t, i) {
        Ext.TaskQueue.requestRead("dispatch", this, [ e, "resize", [ t, i ] ]);
    }
});

Ext.define("Ext.chart.series.ItemPublisher", {
    extend: "Ext.event.publisher.Publisher",
    targetType: "series",
    handledEvents: [ "itemmousemove", "itemmouseup", "itemmousedown", "itemmouseover", "itemmouseout", "itemclick", "itemdoubleclick", "itemtap", "itemtapstart", "itemtapend", "itemtapcancel", "itemtaphold", "itemdoubletap", "itemsingletap", "itemtouchstart", "itemtouchmove", "itemtouchend", "itemdragstart", "itemdrag", "itemdragend", "itempinchstart", "itempinch", "itempinchend", "itemswipe" ],
    delegationRegex: /^item([a-z]+)$/i,
    getSubscribers: function(e) {
        var t = this.subscribers;
        if (!t.hasOwnProperty(e)) {
            t[e] = {};
        }
        return t[e];
    },
    subscribe: function(e, t) {
        var i = e.match(this.idSelectorRegex), n = this.dispatcher, r = this.targetType, s, a, o;
        if (!i) {
            return false;
        }
        o = i[1];
        a = Ext.ComponentManager.get(o);
        if (!a) {
            return false;
        }
        if (!a.getChart()) {
            n.addListener(r, e, "chartattached", "attachChart", this, [ a, t ], "before");
        } else {
            this.attachChart(a.getChart(), [ a, t ]);
        }
        return true;
    },
    unsubscribe: function(e, t, i) {
        var n = e.match(this.idSelectorRegex), r = this.dispatcher, s = this.targetType, a, o, l;
        if (!n) {
            return false;
        }
        l = n[1];
        o = Ext.ComponentManager.get(l);
        if (!o) {
            return false;
        }
        a = this.getSubscribers(e, false);
        if (!a) {
            return false;
        }
        a.$length--;
        if (a.hasOwnProperty(t)) {
            a[t]--;
            if (o.getChart()) {
                this.detachChart(o.getChart(), [ o, t, a ]);
            }
        }
        return true;
    },
    relayMethod: function(e, t, i) {
        var n = i[0], r = i[1], s = this.dispatcher, a = this.targetType, o = n.getEventXY(e), l = o[0], u = o[1], c = this.getSubscribers(n.getId())[r], f, d;
        if (c) {
            for (f = 0, d = c.length; f < d; f++) {
                var h = c[f], g = h.getItemForPoint(l, u);
                if (g) {
                    s.doDispatchEvent(a, "#" + h.getId(), r, [ h, g, e ]);
                    return;
                }
            }
        }
    },
    detachChart: function(e, t) {
        var i = this.dispatcher, n = this.targetType, r = t[0], s = t[1], a = t[2], o = s.match(this.delegationRegex);
        if (o) {
            var l = o[1];
            if (a.hasOwnProperty(s)) {
                Ext.remove(a[s], r);
                if (a[s].length === 0) {
                    e.element.un(l, "relayMethod", this, [ e, r, s ]);
                }
            }
            i.removeListener(n, "#" + r.getId(), "chartdetached", "detachChart", this, [ r, s, a ], "after");
        }
    },
    attachChart: function(e, t) {
        var i = this.dispatcher, n = this.targetType, r = t[0], s = t[1], a = this.getSubscribers(e.getId()), o = s.match(this.delegationRegex);
        if (o) {
            var l = o[1];
            if (!a.hasOwnProperty(s)) {
                a[s] = [];
                i.addListener(n, "#" + r.getId(), "chartdetached", "detachChart", this, [ r, s, a ], "after");
                e.element.on(l, "relayMethod", this, [ e, s ]);
            }
            a[s].push(r);
            return true;
        } else {
            return false;
        }
    }
}, function() {});

Ext.define("Ext.log.Base", {
    config: {},
    constructor: function(e) {
        this.initConfig(e);
        return this;
    }
});

(function() {
    var e = Ext.define("Ext.log.Logger", {
        extend: "Ext.log.Base",
        statics: {
            defaultPriority: "info",
            priorities: {
                verbose: 0,
                info: 1,
                deprecate: 2,
                warn: 3,
                error: 4
            }
        },
        config: {
            enabled: true,
            minPriority: "deprecate",
            writers: {}
        },
        log: function(t, i, n) {
            if (!this.getEnabled()) {
                return this;
            }
            var r = e, s = r.priorities, a = s[i], o = this.log.caller, l = "", u = this.getWriters(), c, f, d;
            if (!i) {
                i = "info";
            }
            if (s[this.getMinPriority()] > a) {
                return this;
            }
            if (!n) {
                n = 1;
            }
            if (Ext.isArray(t)) {
                t = t.join(" ");
            } else {
                t = String(t);
            }
            if (typeof n == "number") {
                f = n;
                do {
                    f--;
                    o = o.caller;
                    if (!o) {
                        break;
                    }
                    if (!d) {
                        d = o.caller;
                    }
                    if (f <= 0 && o.displayName) {
                        break;
                    }
                } while (o !== d);
                l = Ext.getDisplayName(o);
            } else {
                o = o.caller;
                l = Ext.getDisplayName(n) + "#" + o.$name;
            }
            c = {
                time: Ext.Date.now(),
                priority: a,
                priorityName: i,
                message: t,
                caller: o,
                callerDisplayName: l
            };
            for (f in u) {
                if (u.hasOwnProperty(f)) {
                    u[f].write(Ext.merge({}, c));
                }
            }
            return this;
        }
    }, function() {
        Ext.Object.each(this.priorities, function(e) {
            this.override(e, function(t, i) {
                if (!i) {
                    i = 1;
                }
                if (typeof i == "number") {
                    i += 1;
                }
                this.log(t, e, i);
            });
        }, this);
    });
})();

Ext.define("Ext.log.formatter.Formatter", {
    extend: "Ext.log.Base",
    config: {
        messageFormat: "{message}"
    },
    format: function(e) {
        return this.substitute(this.getMessageFormat(), e);
    },
    substitute: function(e, t) {
        var i, n;
        for (i in t) {
            if (t.hasOwnProperty(i)) {
                n = t[i];
                e = e.replace(new RegExp("\\{" + i + "\\}", "g"), n);
            }
        }
        return e;
    }
});

Ext.define("Ext.log.writer.Writer", {
    extend: "Ext.log.Base",
    requires: [ "Ext.log.formatter.Formatter" ],
    config: {
        formatter: null,
        filters: {}
    },
    constructor: function() {
        this.activeFilters = [];
        return this.callParent(arguments);
    },
    updateFilters: function(e) {
        var t = this.activeFilters, i, n;
        t.length = 0;
        for (i in e) {
            if (e.hasOwnProperty(i)) {
                n = e[i];
                t.push(n);
            }
        }
    },
    write: function(e) {
        var t = this.activeFilters, i = this.getFormatter(), n, r, s;
        for (n = 0, r = t.length; n < r; n++) {
            s = t[n];
            if (!t[n].accept(e)) {
                return this;
            }
        }
        if (i) {
            e.message = i.format(e);
        }
        this.doWrite(e);
        return this;
    },
    doWrite: Ext.emptyFn
});

Ext.define("Ext.log.writer.Console", {
    extend: "Ext.log.writer.Writer",
    config: {
        throwOnErrors: true,
        throwOnWarnings: false
    },
    doWrite: function(e) {
        var t = e.message, i = e.priorityName, n;
        if (i === "error" && this.getThrowOnErrors()) {
            throw new Error(t);
        }
        if (typeof console !== "undefined") {
            n = i;
            if (n === "deprecate") {
                n = "warn";
            }
            if (n === "warn" && this.getThrowOnWarnings()) {
                throw new Error(t);
            }
            if (!(n in console)) {
                n = "log";
            }
            console[n](t);
        }
    }
});

Ext.define("Ext.log.formatter.Default", {
    extend: "Ext.log.formatter.Formatter",
    config: {
        messageFormat: "[{priorityName}][{callerDisplayName}] {message}"
    },
    format: function(e) {
        var e = Ext.merge({}, e, {
            priorityName: e.priorityName.toUpperCase()
        });
        return this.callParent([ e ]);
    }
});

Ext.define("Ext.fx.State", {
    isAnimatable: {
        "background-color": true,
        "background-image": true,
        "background-position": true,
        "border-bottom-color": true,
        "border-bottom-width": true,
        "border-color": true,
        "border-left-color": true,
        "border-left-width": true,
        "border-right-color": true,
        "border-right-width": true,
        "border-spacing": true,
        "border-top-color": true,
        "border-top-width": true,
        "border-width": true,
        bottom: true,
        color: true,
        crop: true,
        "font-size": true,
        "font-weight": true,
        height: true,
        left: true,
        "letter-spacing": true,
        "line-height": true,
        "margin-bottom": true,
        "margin-left": true,
        "margin-right": true,
        "margin-top": true,
        "max-height": true,
        "max-width": true,
        "min-height": true,
        "min-width": true,
        opacity: true,
        "outline-color": true,
        "outline-offset": true,
        "outline-width": true,
        "padding-bottom": true,
        "padding-left": true,
        "padding-right": true,
        "padding-top": true,
        right: true,
        "text-indent": true,
        "text-shadow": true,
        top: true,
        "vertical-align": true,
        visibility: true,
        width: true,
        "word-spacing": true,
        "z-index": true,
        zoom: true,
        transform: true
    },
    constructor: function(e) {
        this.data = {};
        this.set(e);
    },
    setConfig: function(e) {
        this.set(e);
        return this;
    },
    setRaw: function(e) {
        this.data = e;
        return this;
    },
    clear: function() {
        return this.setRaw({});
    },
    setTransform: function(e, t) {
        var i = this.data, n = Ext.isArray(t), r = i.transform, s, a;
        if (!r) {
            r = i.transform = {
                translateX: 0,
                translateY: 0,
                translateZ: 0,
                scaleX: 1,
                scaleY: 1,
                scaleZ: 1,
                rotate: 0,
                rotateX: 0,
                rotateY: 0,
                rotateZ: 0,
                skewX: 0,
                skewY: 0
            };
        }
        if (typeof e == "string") {
            switch (e) {
              case "translate":
                if (n) {
                    s = t.length;
                    if (s == 0) {
                        break;
                    }
                    r.translateX = t[0];
                    if (s == 1) {
                        break;
                    }
                    r.translateY = t[1];
                    if (s == 2) {
                        break;
                    }
                    r.translateZ = t[2];
                } else {
                    r.translateX = t;
                }
                break;

              case "rotate":
                if (n) {
                    s = t.length;
                    if (s == 0) {
                        break;
                    }
                    r.rotateX = t[0];
                    if (s == 1) {
                        break;
                    }
                    r.rotateY = t[1];
                    if (s == 2) {
                        break;
                    }
                    r.rotateZ = t[2];
                } else {
                    r.rotate = t;
                }
                break;

              case "scale":
                if (n) {
                    s = t.length;
                    if (s == 0) {
                        break;
                    }
                    r.scaleX = t[0];
                    if (s == 1) {
                        break;
                    }
                    r.scaleY = t[1];
                    if (s == 2) {
                        break;
                    }
                    r.scaleZ = t[2];
                } else {
                    r.scaleX = t;
                    r.scaleY = t;
                }
                break;

              case "skew":
                if (n) {
                    s = t.length;
                    if (s == 0) {
                        break;
                    }
                    r.skewX = t[0];
                    if (s == 1) {
                        break;
                    }
                    r.skewY = t[1];
                } else {
                    r.skewX = t;
                }
                break;

              default:
                r[e] = t;
            }
        } else {
            for (a in e) {
                if (e.hasOwnProperty(a)) {
                    t = e[a];
                    this.setTransform(a, t);
                }
            }
        }
    },
    set: function(e, t) {
        var i = this.data, n;
        if (typeof e != "string") {
            for (n in e) {
                t = e[n];
                if (n === "transform") {
                    this.setTransform(t);
                } else {
                    i[n] = t;
                }
            }
        } else {
            if (e === "transform") {
                this.setTransform(t);
            } else {
                i[e] = t;
            }
        }
        return this;
    },
    unset: function(e) {
        var t = this.data;
        if (t.hasOwnProperty(e)) {
            delete t[e];
        }
        return this;
    },
    getData: function() {
        return this.data;
    }
});

Ext.define("Ext.fx.animation.Abstract", {
    extend: "Ext.Evented",
    isAnimation: true,
    requires: [ "Ext.fx.State" ],
    config: {
        name: "",
        element: null,
        before: null,
        from: {},
        to: {},
        after: null,
        states: {},
        duration: 300,
        easing: "linear",
        iteration: 1,
        direction: "normal",
        delay: 0,
        onBeforeStart: null,
        onEnd: null,
        onBeforeEnd: null,
        scope: null,
        reverse: null,
        preserveEndState: false,
        replacePrevious: true
    },
    STATE_FROM: "0%",
    STATE_TO: "100%",
    DIRECTION_UP: "up",
    DIRECTION_DOWN: "down",
    DIRECTION_LEFT: "left",
    DIRECTION_RIGHT: "right",
    stateNameRegex: /^(?:[\d\.]+)%$/,
    constructor: function() {
        this.states = {};
        this.callParent(arguments);
        return this;
    },
    applyElement: function(e) {
        return Ext.get(e);
    },
    applyBefore: function(e, t) {
        if (e) {
            return Ext.factory(e, Ext.fx.State, t);
        }
    },
    applyAfter: function(e, t) {
        if (e) {
            return Ext.factory(e, Ext.fx.State, t);
        }
    },
    setFrom: function(e) {
        return this.setState(this.STATE_FROM, e);
    },
    setTo: function(e) {
        return this.setState(this.STATE_TO, e);
    },
    getFrom: function() {
        return this.getState(this.STATE_FROM);
    },
    getTo: function() {
        return this.getState(this.STATE_TO);
    },
    setStates: function(e) {
        var t = this.stateNameRegex, i;
        for (i in e) {
            if (t.test(i)) {
                this.setState(i, e[i]);
            }
        }
        return this;
    },
    getStates: function() {
        return this.states;
    },
    stop: function() {
        this.fireEvent("stop", this);
    },
    destroy: function() {
        this.stop();
        this.callParent();
    },
    setState: function(e, t) {
        var i = this.getStates(), n;
        n = Ext.factory(t, Ext.fx.State, i[e]);
        if (n) {
            i[e] = n;
        } else if (e === this.STATE_TO) {
            Ext.Logger.error("Setting and invalid '100%' / 'to' state of: " + t);
        }
        return this;
    },
    getState: function(e) {
        return this.getStates()[e];
    },
    getData: function() {
        var e = this.getStates(), t = {}, i = this.getBefore(), n = this.getAfter(), r = e[this.STATE_FROM], s = e[this.STATE_TO], a = r.getData(), o = s.getData(), l, u, c;
        for (u in e) {
            if (e.hasOwnProperty(u)) {
                c = e[u];
                l = c.getData();
                t[u] = l;
            }
        }
        if (Ext.os.is.Android2) {
            t["0.0001%"] = a;
        }
        return {
            before: i ? i.getData() : {},
            after: n ? n.getData() : {},
            states: t,
            from: a,
            to: o,
            duration: this.getDuration(),
            iteration: this.getIteration(),
            direction: this.getDirection(),
            easing: this.getEasing(),
            delay: this.getDelay(),
            onEnd: this.getOnEnd(),
            onBeforeEnd: this.getOnBeforeEnd(),
            onBeforeStart: this.getOnBeforeStart(),
            scope: this.getScope(),
            preserveEndState: this.getPreserveEndState(),
            replacePrevious: this.getReplacePrevious()
        };
    }
});

Ext.define("Ext.fx.animation.Slide", {
    extend: "Ext.fx.animation.Abstract",
    alternateClassName: "Ext.fx.animation.SlideIn",
    alias: [ "animation.slide", "animation.slideIn" ],
    config: {
        direction: "left",
        out: false,
        offset: 0,
        easing: "auto",
        containerBox: "auto",
        elementBox: "auto",
        isElementBoxFit: true,
        useCssTransform: true
    },
    reverseDirectionMap: {
        up: "down",
        down: "up",
        left: "right",
        right: "left"
    },
    applyEasing: function(e) {
        if (e === "auto") {
            return "ease-" + (this.getOut() ? "in" : "out");
        }
        return e;
    },
    getContainerBox: function() {
        var e = this._containerBox;
        if (e === "auto") {
            e = this.getElement().getParent().getPageBox();
        }
        return e;
    },
    getElementBox: function() {
        var e = this._elementBox;
        if (this.getIsElementBoxFit()) {
            return this.getContainerBox();
        }
        if (e === "auto") {
            e = this.getElement().getPageBox();
        }
        return e;
    },
    getData: function() {
        var e = this.getElementBox(), t = this.getContainerBox(), i = e ? e : t, n = this.getFrom(), r = this.getTo(), s = this.getOut(), a = this.getOffset(), o = this.getDirection(), l = this.getUseCssTransform(), u = this.getReverse(), c = 0, f = 0, d, h, g, p;
        if (u) {
            o = this.reverseDirectionMap[o];
        }
        switch (o) {
          case this.DIRECTION_UP:
            if (s) {
                f = t.top - i.top - i.height - a;
            } else {
                f = t.bottom - i.bottom + i.height + a;
            }
            break;

          case this.DIRECTION_DOWN:
            if (s) {
                f = t.bottom - i.bottom + i.height + a;
            } else {
                f = t.top - i.height - i.top - a;
            }
            break;

          case this.DIRECTION_RIGHT:
            if (s) {
                c = t.right - i.right + i.width + a;
            } else {
                c = t.left - i.left - i.width - a;
            }
            break;

          case this.DIRECTION_LEFT:
            if (s) {
                c = t.left - i.left - i.width - a;
            } else {
                c = t.right - i.right + i.width + a;
            }
            break;
        }
        d = s ? 0 : c;
        h = s ? 0 : f;
        if (l) {
            n.setTransform({
                translateX: d,
                translateY: h
            });
        } else {
            n.set("left", d);
            n.set("top", h);
        }
        g = s ? c : 0;
        p = s ? f : 0;
        if (l) {
            r.setTransform({
                translateX: g,
                translateY: p
            });
        } else {
            r.set("left", g);
            r.set("top", p);
        }
        return this.callParent(arguments);
    }
});

Ext.define("Ext.fx.animation.SlideOut", {
    extend: "Ext.fx.animation.Slide",
    alias: [ "animation.slideOut" ],
    config: {
        out: true
    }
});

Ext.define("Ext.fx.animation.Fade", {
    extend: "Ext.fx.animation.Abstract",
    alternateClassName: "Ext.fx.animation.FadeIn",
    alias: [ "animation.fade", "animation.fadeIn" ],
    config: {
        out: false,
        before: {
            display: null,
            opacity: 0
        },
        after: {
            opacity: null
        },
        reverse: null
    },
    updateOut: function(e) {
        var t = this.getTo(), i = this.getFrom();
        if (e) {
            i.set("opacity", 1);
            t.set("opacity", 0);
        } else {
            i.set("opacity", 0);
            t.set("opacity", 1);
        }
    }
});

Ext.define("Ext.fx.animation.FadeOut", {
    extend: "Ext.fx.animation.Fade",
    alias: "animation.fadeOut",
    config: {
        out: true,
        before: {}
    }
});

Ext.define("Ext.fx.animation.Flip", {
    extend: "Ext.fx.animation.Abstract",
    alias: "animation.flip",
    config: {
        easing: "ease-in",
        direction: "right",
        half: false,
        out: null
    },
    getData: function() {
        var e = this.getFrom(), t = this.getTo(), i = this.getDirection(), n = this.getOut(), r = this.getHalf(), s = r ? 90 : 180, a = 1, o = 1, l = 0, u = 0, c = 0, f = 0;
        if (n) {
            o = .8;
        } else {
            a = .8;
        }
        switch (i) {
          case this.DIRECTION_UP:
            if (n) {
                c = s;
            } else {
                l = -s;
            }
            break;

          case this.DIRECTION_DOWN:
            if (n) {
                c = -s;
            } else {
                l = s;
            }
            break;

          case this.DIRECTION_RIGHT:
            if (n) {
                f = -s;
            } else {
                u = s;
            }
            break;

          case this.DIRECTION_LEFT:
            if (n) {
                f = -s;
            } else {
                u = s;
            }
            break;
        }
        e.setTransform({
            rotateX: l,
            rotateY: u,
            scale: a
        });
        t.setTransform({
            rotateX: c,
            rotateY: f,
            scale: o
        });
        return this.callParent(arguments);
    }
});

Ext.define("Ext.fx.animation.Pop", {
    extend: "Ext.fx.animation.Abstract",
    alias: [ "animation.pop", "animation.popIn" ],
    alternateClassName: "Ext.fx.animation.PopIn",
    config: {
        out: false,
        before: {
            display: null,
            opacity: 0
        },
        after: {
            opacity: null
        }
    },
    getData: function() {
        var e = this.getTo(), t = this.getFrom(), i = this.getOut();
        if (i) {
            t.set("opacity", 1);
            t.setTransform({
                scale: 1
            });
            e.set("opacity", 0);
            e.setTransform({
                scale: 0
            });
        } else {
            t.set("opacity", 0);
            t.setTransform({
                scale: 0
            });
            e.set("opacity", 1);
            e.setTransform({
                scale: 1
            });
        }
        return this.callParent(arguments);
    }
});

Ext.define("Ext.fx.animation.PopOut", {
    extend: "Ext.fx.animation.Pop",
    alias: "animation.popOut",
    config: {
        out: true,
        before: {}
    }
});

Ext.define("Ext.fx.Animation", {
    requires: [ "Ext.fx.animation.Slide", "Ext.fx.animation.SlideOut", "Ext.fx.animation.Fade", "Ext.fx.animation.FadeOut", "Ext.fx.animation.Flip", "Ext.fx.animation.Pop", "Ext.fx.animation.PopOut" ],
    constructor: function(e) {
        var t = Ext.fx.animation.Abstract, i;
        if (typeof e == "string") {
            i = e;
            e = {};
        } else if (e && e.type) {
            i = e.type;
        }
        if (i) {
            if (Ext.os.is.Android2) {
                if (i == "pop") {
                    i = "fade";
                }
                if (i == "popIn") {
                    i = "fadeIn";
                }
                if (i == "popOut") {
                    i = "fadeOut";
                }
            }
            t = Ext.ClassManager.getByAlias("animation." + i);
            if (!t) {
                Ext.Logger.error("Invalid animation type of: '" + i + "'");
            }
        }
        return Ext.factory(e, t);
    }
});

Ext.define("Ext.fx.runner.Css", {
    extend: "Ext.Evented",
    requires: [ "Ext.fx.Animation" ],
    prefixedProperties: {
        transform: true,
        "transform-origin": true,
        perspective: true,
        "transform-style": true,
        transition: true,
        "transition-property": true,
        "transition-duration": true,
        "transition-timing-function": true,
        "transition-delay": true,
        animation: true,
        "animation-name": true,
        "animation-duration": true,
        "animation-iteration-count": true,
        "animation-direction": true,
        "animation-timing-function": true,
        "animation-delay": true
    },
    lengthProperties: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        width: true,
        height: true,
        "max-height": true,
        "max-width": true,
        "min-height": true,
        "min-width": true,
        "margin-bottom": true,
        "margin-left": true,
        "margin-right": true,
        "margin-top": true,
        "padding-bottom": true,
        "padding-left": true,
        "padding-right": true,
        "padding-top": true,
        "border-bottom-width": true,
        "border-left-width": true,
        "border-right-width": true,
        "border-spacing": true,
        "border-top-width": true,
        "border-width": true,
        "outline-width": true,
        "letter-spacing": true,
        "line-height": true,
        "text-indent": true,
        "word-spacing": true,
        "font-size": true,
        translate: true,
        translateX: true,
        translateY: true,
        translateZ: true,
        translate3d: true
    },
    durationProperties: {
        "transition-duration": true,
        "transition-delay": true,
        "animation-duration": true,
        "animation-delay": true
    },
    angleProperties: {
        rotate: true,
        rotateX: true,
        rotateY: true,
        rotateZ: true,
        skew: true,
        skewX: true,
        skewY: true
    },
    lengthUnitRegex: /([a-z%]*)$/,
    DEFAULT_UNIT_LENGTH: "px",
    DEFAULT_UNIT_ANGLE: "deg",
    DEFAULT_UNIT_DURATION: "ms",
    formattedNameCache: {},
    constructor: function() {
        var e = Ext.feature.has.Css3dTransforms;
        if (e) {
            this.transformMethods = [ "translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "scaleX", "scaleY", "scaleZ" ];
        } else {
            this.transformMethods = [ "translateX", "translateY", "rotate", "skewX", "skewY", "scaleX", "scaleY" ];
        }
        this.vendorPrefix = Ext.browser.getStyleDashPrefix();
        this.ruleStylesCache = {};
        return this;
    },
    getStyleSheet: function() {
        var e = this.styleSheet, t, i;
        if (!e) {
            t = document.createElement("style");
            t.type = "text/css";
            (document.head || document.getElementsByTagName("head")[0]).appendChild(t);
            i = document.styleSheets;
            this.styleSheet = e = i[i.length - 1];
        }
        return e;
    },
    applyRules: function(e) {
        var t = this.getStyleSheet(), i = this.ruleStylesCache, n = t.cssRules, r, s, a, o, l, u, c;
        for (r in e) {
            s = e[r];
            a = i[r];
            if (a === undefined) {
                l = n.length;
                t.insertRule(r + "{}", l);
                a = i[r] = n.item(l).style;
            }
            o = a.$cache;
            if (!o) {
                o = a.$cache = {};
            }
            for (u in s) {
                c = this.formatValue(s[u], u);
                u = this.formatName(u);
                if (o[u] !== c) {
                    o[u] = c;
                    if (c === null) {
                        a.removeProperty(u);
                    } else {
                        a.setProperty(u, c, "important");
                    }
                }
            }
        }
        return this;
    },
    applyStyles: function(e) {
        var t, i, n, r, s, a;
        for (t in e) {
            i = document.getElementById(t);
            if (!i) {
                return this;
            }
            n = i.style;
            r = e[t];
            for (s in r) {
                a = this.formatValue(r[s], s);
                s = this.formatName(s);
                if (a === null) {
                    n.removeProperty(s);
                } else {
                    n.setProperty(s, a, "important");
                }
            }
        }
        return this;
    },
    formatName: function(e) {
        var t = this.formattedNameCache, i = t[e];
        if (!i) {
            if (this.prefixedProperties[e]) {
                i = this.vendorPrefix + e;
            } else {
                i = e;
            }
            t[e] = i;
        }
        return i;
    },
    formatValue: function(e, t) {
        var i = typeof e, n = this.DEFAULT_UNIT_LENGTH, r, s, a, o, l, u, c;
        if (i == "string") {
            if (this.lengthProperties[t]) {
                c = e.match(this.lengthUnitRegex)[1];
                if (c.length > 0) {
                    if (c !== n) {
                        Ext.Logger.error("Length unit: '" + c + "' in value: '" + e + "' of property: '" + t + "' is not " + "valid for animation. Only 'px' is allowed");
                    }
                } else {
                    return e + n;
                }
            }
            return e;
        } else if (i == "number") {
            if (e == 0) {
                return "0";
            }
            if (this.lengthProperties[t]) {
                return e + n;
            }
            if (this.angleProperties[t]) {
                return e + this.DEFAULT_UNIT_ANGLE;
            }
            if (this.durationProperties[t]) {
                return e + this.DEFAULT_UNIT_DURATION;
            }
        } else if (t === "transform") {
            r = this.transformMethods;
            l = [];
            for (a = 0, o = r.length; a < o; a++) {
                s = r[a];
                l.push(s + "(" + this.formatValue(e[s], s) + ")");
            }
            return l.join(" ");
        } else if (Ext.isArray(e)) {
            u = [];
            for (a = 0, o = e.length; a < o; a++) {
                u.push(this.formatValue(e[a], t));
            }
            return u.length > 0 ? u.join(", ") : "none";
        }
        return e;
    }
});

Ext.define("Ext.fx.runner.CssTransition", {
    extend: "Ext.fx.runner.Css",
    listenersAttached: false,
    constructor: function() {
        this.runningAnimationsData = {};
        return this.callParent(arguments);
    },
    attachListeners: function() {
        this.listenersAttached = true;
        this.getEventDispatcher().addListener("element", "*", "transitionend", "onTransitionEnd", this);
    },
    onTransitionEnd: function(e) {
        var t = e.target, i = t.id;
        if (i && this.runningAnimationsData.hasOwnProperty(i)) {
            this.refreshRunningAnimationsData(Ext.get(t), [ e.browserEvent.propertyName ]);
        }
    },
    onAnimationEnd: function(e, t, i, n, r) {
        var s = e.getId(), a = this.runningAnimationsData[s], o = {}, l = {}, u, c, f, d, h;
        i.un("stop", "onAnimationStop", this);
        if (a) {
            u = a.nameMap;
        }
        o[s] = l;
        if (t.onBeforeEnd) {
            t.onBeforeEnd.call(t.scope || this, e, n);
        }
        i.fireEvent("animationbeforeend", i, e, n);
        this.fireEvent("animationbeforeend", this, i, e, n);
        if (r || !n && !t.preserveEndState) {
            c = t.toPropertyNames;
            for (f = 0, d = c.length; f < d; f++) {
                h = c[f];
                if (u && !u.hasOwnProperty(h)) {
                    l[h] = null;
                }
            }
        }
        if (t.after) {
            Ext.merge(l, t.after);
        }
        this.applyStyles(o);
        if (t.onEnd) {
            t.onEnd.call(t.scope || this, e, n);
        }
        i.fireEvent("animationend", i, e, n);
        this.fireEvent("animationend", this, i, e, n);
    },
    onAllAnimationsEnd: function(e) {
        var t = e.getId(), i = {};
        delete this.runningAnimationsData[t];
        i[t] = {
            "transition-property": null,
            "transition-duration": null,
            "transition-timing-function": null,
            "transition-delay": null
        };
        this.applyStyles(i);
        this.fireEvent("animationallend", this, e);
    },
    hasRunningAnimations: function(e) {
        var t = e.getId(), i = this.runningAnimationsData;
        return i.hasOwnProperty(t) && i[t].sessions.length > 0;
    },
    refreshRunningAnimationsData: function(e, t, i, n) {
        var r = e.getId(), s = this.runningAnimationsData, a = s[r];
        if (!a) {
            return;
        }
        var o = a.nameMap, l = a.nameList, u = a.sessions, c, f, d, h, g, p, m, x, E = false;
        i = Boolean(i);
        n = Boolean(n);
        if (!u) {
            return this;
        }
        c = u.length;
        if (c === 0) {
            return this;
        }
        if (n) {
            a.nameMap = {};
            l.length = 0;
            for (g = 0; g < c; g++) {
                p = u[g];
                this.onAnimationEnd(e, p.data, p.animation, i, n);
            }
            u.length = 0;
        } else {
            for (g = 0; g < c; g++) {
                p = u[g];
                m = p.map;
                x = p.list;
                for (f = 0, d = t.length; f < d; f++) {
                    h = t[f];
                    if (m[h]) {
                        delete m[h];
                        Ext.Array.remove(x, h);
                        p.length--;
                        if (--o[h] == 0) {
                            delete o[h];
                            Ext.Array.remove(l, h);
                        }
                    }
                }
                if (p.length == 0) {
                    u.splice(g, 1);
                    g--;
                    c--;
                    E = true;
                    this.onAnimationEnd(e, p.data, p.animation, i);
                }
            }
        }
        if (!n && !i && u.length == 0 && E) {
            this.onAllAnimationsEnd(e);
        }
    },
    getRunningData: function(e) {
        var t = this.runningAnimationsData;
        if (!t.hasOwnProperty(e)) {
            t[e] = {
                nameMap: {},
                nameList: [],
                sessions: []
            };
        }
        return t[e];
    },
    getTestElement: function() {
        var e = this.testElement, t, i, n;
        if (!e) {
            t = document.createElement("iframe");
            n = t.style;
            n.setProperty("visibility", "hidden", "important");
            n.setProperty("width", "0px", "important");
            n.setProperty("height", "0px", "important");
            n.setProperty("position", "absolute", "important");
            n.setProperty("border", "0px", "important");
            n.setProperty("zIndex", "-1000", "important");
            document.body.appendChild(t);
            i = t.contentDocument;
            i.open();
            i.writeln("</body>");
            i.close();
            this.testElement = e = i.createElement("div");
            e.style.setProperty("position", "absolute", "!important");
            i.body.appendChild(e);
            this.testElementComputedStyle = window.getComputedStyle(e);
        }
        return e;
    },
    getCssStyleValue: function(e, t) {
        var i = this.getTestElement(), n = this.testElementComputedStyle, r = i.style;
        r.setProperty(e, t);
        t = n.getPropertyValue(e);
        r.removeProperty(e);
        return t;
    },
    run: function(e) {
        var t = this, i = this.lengthProperties, n = {}, r = {}, s = {}, a, o, l, u, c, f, d, h, g, p, m, x, E, y, v, b, S, C, w, T, I, A, P, M, D, O, L;
        if (!this.listenersAttached) {
            this.attachListeners();
        }
        e = Ext.Array.from(e);
        for (m = 0, E = e.length; m < E; m++) {
            y = e[m];
            y = Ext.factory(y, Ext.fx.Animation);
            a = y.getElement();
            S = window.getComputedStyle(a.dom);
            o = a.getId();
            s = Ext.merge({}, y.getData());
            if (y.onBeforeStart) {
                y.onBeforeStart.call(y.scope || this, a);
            }
            y.fireEvent("animationstart", y);
            this.fireEvent("animationstart", this, y);
            s[o] = s;
            c = s.before;
            l = s.from;
            u = s.to;
            s.fromPropertyNames = f = [];
            s.toPropertyNames = d = [];
            for (w in u) {
                if (u.hasOwnProperty(w)) {
                    u[w] = T = this.formatValue(u[w], w);
                    C = this.formatName(w);
                    P = i.hasOwnProperty(w);
                    if (!P) {
                        T = this.getCssStyleValue(C, T);
                    }
                    if (l.hasOwnProperty(w)) {
                        l[w] = A = this.formatValue(l[w], w);
                        if (!P) {
                            A = this.getCssStyleValue(C, A);
                        }
                        if (T !== A) {
                            f.push(C);
                            d.push(C);
                        }
                    } else {
                        I = S.getPropertyValue(C);
                        if (T !== I) {
                            d.push(C);
                        }
                    }
                }
            }
            v = d.length;
            if (v === 0) {
                this.onAnimationEnd(a, s, y);
                continue;
            }
            p = this.getRunningData(o);
            O = p.sessions;
            if (O.length > 0) {
                this.refreshRunningAnimationsData(a, Ext.Array.merge(f, d), true, s.replacePrevious);
            }
            M = p.nameMap;
            D = p.nameList;
            b = {};
            for (x = 0; x < v; x++) {
                w = d[x];
                b[w] = true;
                if (!M.hasOwnProperty(w)) {
                    M[w] = 1;
                    D.push(w);
                } else {
                    M[w]++;
                }
            }
            L = {
                element: a,
                map: b,
                list: d.slice(),
                length: v,
                data: s,
                animation: y
            };
            O.push(L);
            y.on("stop", "onAnimationStop", this);
            n[o] = l = Ext.apply(Ext.Object.chain(c), l);
            if (D.length > 0) {
                f = Ext.Array.difference(D, f);
                d = Ext.Array.merge(f, d);
                l["transition-property"] = f;
            }
            r[o] = u = Ext.Object.chain(u);
            u["transition-property"] = d;
            u["transition-duration"] = s.duration;
            u["transition-timing-function"] = s.easing;
            u["transition-delay"] = s.delay;
            y.startTime = Date.now();
        }
        g = this.$className;
        this.applyStyles(n);
        h = function(e) {
            if (e.data === g && e.source === window) {
                window.removeEventListener("message", h, false);
                t.applyStyles(r);
            }
        };
        window.addEventListener("message", h, false);
        window.postMessage(g, "*");
    },
    onAnimationStop: function(e) {
        var t = this.runningAnimationsData, i, n, r, s, a, o;
        for (i in t) {
            if (t.hasOwnProperty(i)) {
                n = t[i];
                r = n.sessions;
                for (s = 0, a = r.length; s < a; s++) {
                    o = r[s];
                    if (o.animation === e) {
                        this.refreshRunningAnimationsData(o.element, o.list.slice(), false);
                    }
                }
            }
        }
    }
});

Ext.define("Ext.fx.Runner", {
    requires: [ "Ext.fx.runner.CssTransition" ],
    constructor: function() {
        return new Ext.fx.runner.CssTransition();
    }
});

Ext.define("Ext.layout.wrapper.Inner", {
    config: {
        sizeState: null,
        container: null
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    getElement: function() {
        return this.getContainer().bodyElement;
    },
    setInnerWrapper: Ext.emptyFn,
    getInnerWrapper: Ext.emptyFn
});

Ext.define("Ext.layout.wrapper.BoxDock", {
    config: {
        direction: "horizontal",
        element: {
            className: "x-dock"
        },
        bodyElement: {
            className: "x-dock-body"
        },
        innerWrapper: null,
        sizeState: false,
        container: null
    },
    positionMap: {
        top: "start",
        left: "start",
        bottom: "end",
        right: "end"
    },
    constructor: function(e) {
        this.items = {
            start: [],
            end: []
        };
        this.itemsCount = 0;
        this.initConfig(e);
    },
    addItems: function(e) {
        var t, i, n;
        for (t = 0, i = e.length; t < i; t++) {
            n = e[t];
            this.addItem(n);
        }
    },
    addItem: function(e) {
        var t = e.getDocked(), i = this.positionMap[t], n = e.$dockWrapper, r = this.getContainer(), s = r.indexOf(e), a = e.element, o = this.items, l = o[i], u, c, f, d, h;
        if (n) {
            n.removeItem(e);
        }
        e.$dockWrapper = this;
        e.addCls("x-dock-item");
        e.addCls("x-docked-" + t);
        for (u = 0, c = l.length; u < c; u++) {
            f = l[u];
            h = r.indexOf(f);
            if (h > s) {
                d = f.element;
                l.splice(u, 0, e);
                break;
            }
        }
        if (!d) {
            l.push(e);
            d = this.getBodyElement();
        }
        this.itemsCount++;
        if (i === "start") {
            a.insertBefore(d);
        } else {
            a.insertAfter(d);
        }
    },
    removeItem: function(e) {
        var t = e.getDocked(), i = this.items[this.positionMap[t]];
        Ext.Array.remove(i, e);
        e.element.detach();
        delete e.$dockWrapper;
        e.removeCls("x-dock-item");
        e.removeCls("x-docked-" + t);
        if (--this.itemsCount === 0) {
            this.destroy();
        }
    },
    getItemsSlice: function(e) {
        var t = this.getContainer(), i = this.items, n = [], r, s, a, o;
        for (r = i.start, s = 0, a = r.length; s < a; s++) {
            o = r[s];
            if (t.indexOf(o) > e) {
                n.push(o);
            }
        }
        for (r = i.end, s = 0, a = r.length; s < a; s++) {
            o = r[s];
            if (t.indexOf(o) > e) {
                n.push(o);
            }
        }
        return n;
    },
    applyElement: function(e) {
        return Ext.Element.create(e);
    },
    updateElement: function(e) {
        e.addCls("x-dock-" + this.getDirection());
    },
    applyBodyElement: function(e) {
        return Ext.Element.create(e);
    },
    updateBodyElement: function(e) {
        this.getElement().append(e);
    },
    updateInnerWrapper: function(e, t) {
        var i = this.getBodyElement();
        if (t && t.$outerWrapper === this) {
            t.getElement().detach();
            delete t.$outerWrapper;
        }
        if (e) {
            e.setSizeState(this.getSizeState());
            e.$outerWrapper = this;
            i.append(e.getElement());
        }
    },
    updateSizeState: function(e) {
        var t = this.getInnerWrapper();
        this.getElement().setSizeState(e);
        if (t) {
            t.setSizeState(e);
        }
    },
    destroy: function() {
        var e = this.getInnerWrapper(), t = this.$outerWrapper, i;
        if (e) {
            if (t) {
                t.setInnerWrapper(e);
            } else {
                i = e.getElement();
                if (!i.isDestroyed) {
                    i.replace(this.getElement());
                }
                delete e.$outerWrapper;
            }
        }
        delete this.$outerWrapper;
        this.setInnerWrapper(null);
        this.unlink("_bodyElement", "_element");
        this.callSuper();
    }
});

Ext.define("Ext.layout.Abstract", {
    mixins: [ "Ext.mixin.Observable" ],
    isLayout: true,
    constructor: function(e) {
        this.initialConfig = e;
    },
    setContainer: function(e) {
        this.container = e;
        this.initConfig(this.initialConfig);
        return this;
    },
    onItemAdd: function() {},
    onItemRemove: function() {},
    onItemMove: function() {},
    onItemCenteredChange: function() {},
    onItemFloatingChange: function() {},
    onItemDockedChange: function() {},
    onItemInnerStateChange: function() {}
});

Ext.define("Ext.Mask", {
    extend: "Ext.Component",
    xtype: "mask",
    config: {
        baseCls: Ext.baseCSSPrefix + "mask",
        transparent: false,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    },
    initialize: function() {
        this.callSuper();
        this.element.on("*", "onEvent", this);
    },
    onEvent: function(e) {
        var t = arguments[arguments.length - 1];
        if (t.info.eventName === "tap") {
            this.fireEvent("tap", this, e);
            return false;
        }
        if (e && e.stopEvent) {
            e.stopEvent();
        }
        return false;
    },
    updateTransparent: function(e) {
        this[e ? "addCls" : "removeCls"](this.getBaseCls() + "-transparent");
    }
});

Ext.define("Ext.mixin.Bindable", {
    extend: "Ext.mixin.Mixin",
    mixinConfig: {
        id: "bindable"
    },
    bind: function(e, t, i, n) {
        if (!i) {
            i = t;
        }
        var r = e[t], s;
        e[t] = s = function() {
            var e = s.$binding, t = e.bindingScope, i = Array.prototype.slice.call(arguments);
            i.push(arguments);
            if (!e.preventDefault && t[e.bindingMethod].apply(t, i) !== false) {
                return e.boundFn.apply(this, arguments);
            }
        };
        s.$binding = {
            preventDefault: !!n,
            boundFn: r,
            bindingMethod: i,
            bindingScope: this
        };
        return this;
    },
    unbind: function(e, t, i) {
        if (!i) {
            i = t;
        }
        var n = e[t], r = n.$binding, s, a;
        while (r) {
            s = r.boundFn;
            if (r.bindingMethod === i && r.bindingScope === this) {
                if (a) {
                    a.boundFn = s;
                } else {
                    e[t] = s;
                }
                return this;
            }
            a = r;
            r = r.boundFn;
        }
        return this;
    }
});

Ext.define("Ext.fx.layout.card.Abstract", {
    extend: "Ext.Evented",
    isAnimation: true,
    config: {
        direction: "left",
        duration: null,
        reverse: null,
        layout: null
    },
    updateLayout: function() {
        this.enable();
    },
    enable: function() {
        var e = this.getLayout();
        if (e) {
            e.onBefore("activeitemchange", "onActiveItemChange", this);
        }
    },
    disable: function() {
        var e = this.getLayout();
        if (this.isAnimating) {
            this.stopAnimation();
        }
        if (e) {
            e.unBefore("activeitemchange", "onActiveItemChange", this);
        }
    },
    onActiveItemChange: Ext.emptyFn,
    destroy: function() {
        var e = this.getLayout();
        if (this.isAnimating) {
            this.stopAnimation();
        }
        if (e) {
            e.unBefore("activeitemchange", "onActiveItemChange", this);
        }
        this.setLayout(null);
        if (this.observableId) {
            this.fireEvent("destroy", this);
            this.clearListeners();
            this.clearManagedListeners();
        }
    }
});

Ext.define("Ext.util.Filter", {
    isFilter: true,
    config: {
        property: null,
        value: null,
        filterFn: Ext.emptyFn,
        anyMatch: false,
        exactMatch: false,
        caseSensitive: false,
        root: null,
        id: undefined,
        scope: null
    },
    applyId: function(e) {
        if (!e) {
            if (this.getProperty()) {
                e = this.getProperty() + "-" + String(this.getValue());
            }
            if (!e) {
                e = Ext.id(null, "ext-filter-");
            }
        }
        return e;
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    applyFilterFn: function(e) {
        if (e === Ext.emptyFn) {
            e = this.getInitialConfig("filter");
            if (e) {
                return e;
            }
            var t = this.getValue();
            if (!this.getProperty() && !t && t !== 0) {
                Ext.Logger.error("A Filter requires either a property and value, or a filterFn to be set");
                return Ext.emptyFn;
            } else {
                return this.createFilterFn();
            }
        }
        return e;
    },
    createFilterFn: function() {
        var e = this, t = e.createValueMatcher();
        return function(i) {
            var n = e.getRoot(), r = e.getProperty();
            if (n) {
                i = i[n];
            }
            return t.test(i[r]);
        };
    },
    createValueMatcher: function() {
        var e = this, t = e.getValue(), i = e.getAnyMatch(), n = e.getExactMatch(), r = e.getCaseSensitive(), s = Ext.String.escapeRegex;
        if (t === null || t === undefined || !t.exec) {
            t = String(t);
            if (i === true) {
                t = s(t);
            } else {
                t = "^" + s(t);
                if (n === true) {
                    t += "$";
                }
            }
            t = new RegExp(t, r ? "" : "i");
        }
        return t;
    }
});

Ext.define("Ext.util.Sorter", {
    isSorter: true,
    config: {
        property: null,
        sorterFn: null,
        root: null,
        transform: null,
        direction: "ASC",
        id: undefined
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    applySorterFn: function(e) {
        if (!e && !this.getProperty()) {
            Ext.Logger.error("A Sorter requires either a property or a sorterFn.");
        }
        return e;
    },
    applyProperty: function(e) {
        if (!e && !this.getSorterFn()) {
            Ext.Logger.error("A Sorter requires either a property or a sorterFn.");
        }
        return e;
    },
    applyId: function(e) {
        if (!e) {
            e = this.getProperty();
            if (!e) {
                e = Ext.id(null, "ext-sorter-");
            }
        }
        return e;
    },
    createSortFunction: function(e) {
        var t = this, i = t.getDirection().toUpperCase() == "DESC" ? -1 : 1;
        return function(n, r) {
            return i * e.call(t, n, r);
        };
    },
    defaultSortFn: function(e, t) {
        var i = this, n = i._transform, r = i._root, s, a, o = i._property;
        if (r !== null) {
            e = e[r];
            t = t[r];
        }
        s = e[o];
        a = t[o];
        if (n) {
            s = n(s);
            a = n(a);
        }
        return s > a ? 1 : s < a ? -1 : 0;
    },
    updateDirection: function() {
        this.updateSortFn();
    },
    updateSortFn: function() {
        this.sort = this.createSortFunction(this.getSorterFn() || this.defaultSortFn);
    },
    toggle: function() {
        this.setDirection(Ext.String.toggle(this.getDirection(), "ASC", "DESC"));
    }
});

Ext.define("Ext.fx.easing.EaseOut", {
    extend: "Ext.fx.easing.Linear",
    alias: "easing.ease-out",
    config: {
        exponent: 4,
        duration: 1500
    },
    getValue: function() {
        var e = Ext.Date.now() - this.getStartTime(), t = this.getDuration(), i = this.getStartValue(), n = this.getEndValue(), r = this.distance, s = e / t, a = 1 - s, o = 1 - Math.pow(a, this.getExponent()), l = i + o * r;
        if (e >= t) {
            this.isEnded = true;
            return n;
        }
        return l;
    }
});

Ext.define("Ext.fx.easing.Momentum", {
    extend: "Ext.fx.easing.Abstract",
    config: {
        acceleration: 30,
        friction: 0,
        startVelocity: 0
    },
    alpha: 0,
    updateFriction: function(e) {
        var t = Math.log(1 - e / 10);
        this.theta = t;
        this.alpha = t / this.getAcceleration();
    },
    updateStartVelocity: function(e) {
        this.velocity = e * this.getAcceleration();
    },
    updateAcceleration: function(e) {
        this.velocity = this.getStartVelocity() * e;
        this.alpha = this.theta / e;
    },
    getValue: function() {
        return this.getStartValue() - this.velocity * (1 - this.getFrictionFactor()) / this.theta;
    },
    getFrictionFactor: function() {
        var e = Ext.Date.now() - this.getStartTime();
        return Math.exp(e * this.alpha);
    },
    getVelocity: function() {
        return this.getFrictionFactor() * this.velocity;
    }
});

Ext.define("Ext.fx.easing.Bounce", {
    extend: "Ext.fx.easing.Abstract",
    config: {
        springTension: .3,
        acceleration: 30,
        startVelocity: 0
    },
    getValue: function() {
        var e = Ext.Date.now() - this.getStartTime(), t = e / this.getAcceleration(), i = t * Math.pow(Math.E, -this.getSpringTension() * t);
        return this.getStartValue() + this.getStartVelocity() * i;
    }
});

Ext.define("Ext.scroll.indicator.Abstract", {
    extend: "Ext.Component",
    config: {
        baseCls: "x-scroll-indicator",
        axis: "x",
        value: 0,
        length: null,
        minLength: 6,
        hidden: true,
        ui: "dark"
    },
    cachedConfig: {
        ratio: 1,
        barCls: "x-scroll-bar",
        active: true
    },
    barElement: null,
    barLength: 0,
    gapLength: 0,
    getElementConfig: function() {
        return {
            reference: "barElement",
            children: [ this.callParent() ]
        };
    },
    applyRatio: function(e) {
        if (isNaN(e)) {
            e = 1;
        }
        return e;
    },
    refresh: function() {
        var e = this.barElement, t = e.dom, i = this.getRatio(), n = this.getAxis(), r = n === "x" ? t.offsetWidth : t.offsetHeight, s = r * i;
        this.barLength = r;
        this.gapLength = r - s;
        this.setLength(s);
        this.updateValue(this.getValue());
    },
    updateBarCls: function(e) {
        this.barElement.addCls(e);
    },
    updateAxis: function(e) {
        this.element.addCls(this.getBaseCls(), null, e);
        this.barElement.addCls(this.getBarCls(), null, e);
    },
    updateValue: function(e) {
        this.setOffset(this.gapLength * e);
    },
    updateActive: function(e) {
        this.barElement[e ? "addCls" : "removeCls"]("active");
    },
    doSetHidden: function(e) {
        var t = this.element.dom.style;
        if (e) {
            t.opacity = "0";
        } else {
            t.opacity = "";
        }
    },
    applyLength: function(e) {
        return Math.max(this.getMinLength(), e);
    },
    updateLength: function(e) {
        if (!this.isDestroyed) {
            var t = this.getAxis(), i = this.element;
            if (t === "x") {
                i.setWidth(e);
            } else {
                i.setHeight(e);
            }
        }
    },
    setOffset: function(e) {
        var t = this.getAxis(), i = this.element;
        if (t === "x") {
            i.setLeft(e);
        } else {
            i.setTop(e);
        }
    }
});

Ext.define("Ext.LoadMask", {
    extend: "Ext.Mask",
    xtype: "loadmask",
    config: {
        message: "Loading...",
        messageCls: Ext.baseCSSPrefix + "mask-message",
        indicator: true
    },
    getTemplate: function() {
        var e = Ext.baseCSSPrefix;
        return [ {
            reference: "innerElement",
            cls: e + "mask-inner",
            children: [ {
                reference: "indicatorElement",
                cls: e + "loading-spinner-outer",
                children: [ {
                    cls: e + "loading-spinner",
                    children: [ {
                        tag: "span",
                        cls: e + "loading-top"
                    }, {
                        tag: "span",
                        cls: e + "loading-right"
                    }, {
                        tag: "span",
                        cls: e + "loading-bottom"
                    }, {
                        tag: "span",
                        cls: e + "loading-left"
                    } ]
                } ]
            }, {
                reference: "messageElement"
            } ]
        } ];
    },
    updateMessage: function(e) {
        var t = Ext.baseCSSPrefix + "has-message";
        if (e) {
            this.addCls(t);
        } else {
            this.removeCls(t);
        }
        this.messageElement.setHtml(e);
    },
    updateMessageCls: function(e, t) {
        this.messageElement.replaceCls(t, e);
    },
    updateIndicator: function(e) {
        this[e ? "removeCls" : "addCls"](Ext.baseCSSPrefix + "indicator-hidden");
    }
}, function() {
    this.override({
        constructor: function(e, t) {
            if (typeof t !== "undefined") {
                e = t;
                Ext.Logger.deprecate("You no longer need to pass an element to create a Ext.LoadMask. " + "It is a component and can be shown using the Ext.Container.masked configuration.", this);
            }
            if (e) {
                if (e.hasOwnProperty("msg")) {
                    e.message = e.msg;
                    Ext.Logger.deprecate("'msg' config is deprecated, please use 'message' config instead", this);
                    delete e.msg;
                }
                if (e.hasOwnProperty("msgCls")) {
                    e.messageCls = e.msgCls;
                    Ext.Logger.deprecate("'msgCls' config is deprecated, please use 'messageCls' config instead", this);
                    delete e.msgCls;
                }
                if (e.hasOwnProperty("store")) {
                    Ext.Logger.deprecate("'store' config has been removed. You can no longer bind a store to a Ext.LoadMask", this);
                    delete e.store;
                }
            }
            this.callParent([ e ]);
        },
        bindStore: function() {
            Ext.Logger.deprecate("You can no longer bind a store to a Ext.LoadMask", this);
        }
    });
});

Ext.define("Ext.util.Wrapper", {
    mixins: [ "Ext.mixin.Bindable" ],
    constructor: function(e, t) {
        var i = this.link("element", Ext.Element.create(e));
        if (t) {
            i.insertBefore(t);
            this.wrap(t);
        }
    },
    bindSize: function(e) {
        var t = this.wrappedElement, i;
        this.boundSizeName = e;
        this.boundMethodName = i = e === "width" ? "setWidth" : "setHeight";
        this.bind(t, i, "onBoundSizeChange");
        t[i].call(t, t.getStyleValue(e));
    },
    onBoundSizeChange: function(e, t) {
        var i = this.element;
        if (typeof e === "string" && e.substr(-1) === "%") {
            t[0] = "100%";
        } else {
            e = "";
        }
        i[this.boundMethodName].call(i, e);
    },
    wrap: function(e) {
        var t = this.element, i;
        this.wrappedElement = e;
        i = t.dom;
        while (i.firstElementChild !== null) {
            i = i.firstElementChild;
        }
        i.appendChild(e.dom);
    },
    destroy: function() {
        var e = this.element, t = e.dom, i = this.wrappedElement, n = this.boundMethodName, r = t.parentNode, s;
        if (n) {
            this.unbind(i, n, "onBoundSizeChange");
            s = e.getStyle(this.boundSizeName);
            if (s) {
                i[n].call(i, s);
            }
        }
        if (r) {
            if (!i.isDestroyed) {
                r.replaceChild(t.firstElementChild, t);
            }
            delete this.wrappedElement;
        }
        this.callSuper();
    }
});

Ext.define("Ext.layout.Default", {
    extend: "Ext.layout.Abstract",
    isAuto: true,
    alias: [ "layout.default", "layout.auto" ],
    requires: [ "Ext.util.Wrapper", "Ext.layout.wrapper.BoxDock", "Ext.layout.wrapper.Inner" ],
    config: {
        animation: null
    },
    centerWrapperClass: "x-center",
    dockWrapperClass: "x-dock",
    positionMap: {
        top: "start",
        left: "start",
        middle: "center",
        bottom: "end",
        right: "end"
    },
    positionDirectionMap: {
        top: "vertical",
        bottom: "vertical",
        left: "horizontal",
        right: "horizontal"
    },
    setContainer: function(e) {
        var t = {
            delegate: "> component"
        };
        this.dockedItems = [];
        this.callSuper(arguments);
        e.on("centeredchange", "onItemCenteredChange", this, t, "before").on("floatingchange", "onItemFloatingChange", this, t, "before").on("dockedchange", "onBeforeItemDockedChange", this, t, "before").on("afterdockedchange", "onAfterItemDockedChange", this, t);
    },
    monitorSizeStateChange: function() {
        this.monitorSizeStateChange = Ext.emptyFn;
        this.container.on("sizestatechange", "onContainerSizeStateChange", this);
    },
    monitorSizeFlagsChange: function() {
        this.monitorSizeFlagsChange = Ext.emptyFn;
        this.container.on("sizeflagschange", "onContainerSizeFlagsChange", this);
    },
    onItemAdd: function(e) {
        var t = e.getDocked();
        if (t !== null) {
            this.dockItem(e);
        } else if (e.isCentered()) {
            this.onItemCenteredChange(e, true);
        } else if (e.isFloating()) {
            this.onItemFloatingChange(e, true);
        } else {
            this.onItemInnerStateChange(e, true);
        }
    },
    onItemInnerStateChange: function(e, t, i) {
        if (t) {
            this.insertInnerItem(e, this.container.innerIndexOf(e));
        } else {
            this.removeInnerItem(e);
        }
    },
    insertInnerItem: function(e, t) {
        var i = this.container, n = i.innerElement.dom, r = e.element.dom, s = i.getInnerAt(t + 1), a = s ? s.element.dom : null;
        n.insertBefore(r, a);
        return this;
    },
    insertBodyItem: function(e) {
        var t = this.container.setUseBodyElement(true), i = t.bodyElement.dom;
        if (e.getZIndex() === null) {
            e.setZIndex((t.indexOf(e) + 1) * 2);
        }
        i.insertBefore(e.element.dom, i.firstChild);
        return this;
    },
    removeInnerItem: function(e) {
        e.element.detach();
    },
    removeBodyItem: function(e) {
        e.setZIndex(null);
        e.element.detach();
    },
    onItemRemove: function(e, t, i) {
        var n = e.getDocked();
        if (n) {
            this.undockItem(e);
        } else if (e.isCentered()) {
            this.onItemCenteredChange(e, false);
        } else if (e.isFloating()) {
            this.onItemFloatingChange(e, false);
        } else {
            this.onItemInnerStateChange(e, false, i);
        }
    },
    onItemMove: function(e, t, i) {
        if (e.isCentered() || e.isFloating()) {
            e.setZIndex((t + 1) * 2);
        } else if (e.isInnerItem()) {
            this.insertInnerItem(e, this.container.innerIndexOf(e));
        } else {
            this.undockItem(e);
            this.dockItem(e);
        }
    },
    onItemCenteredChange: function(e, t) {
        var i = "$centerWrapper";
        if (t) {
            this.insertBodyItem(e);
            e.link(i, new Ext.util.Wrapper({
                className: this.centerWrapperClass
            }, e.element));
        } else {
            e.unlink(i);
            this.removeBodyItem(e);
        }
    },
    onItemFloatingChange: function(e, t) {
        if (t) {
            this.insertBodyItem(e);
        } else {
            this.removeBodyItem(e);
        }
    },
    onBeforeItemDockedChange: function(e, t, i) {
        if (i) {
            this.undockItem(e);
        }
    },
    onAfterItemDockedChange: function(e, t, i) {
        if (t) {
            this.dockItem(e);
        }
    },
    onAfterDockedChange: function(e, t, i) {
        var n = e.getParent();
        if (n && t) {
            n.getLayout().onAfterItemDockedChange(e, t, i);
        }
    },
    onContainerSizeStateChange: function() {
        var e = this.getDockWrapper();
        if (e) {
            e.setSizeState(this.container.getSizeState());
        }
    },
    onContainerSizeFlagsChange: function() {
        var e = this.dockedItems, t, i, n;
        for (t = 0, i = e.length; t < i; t++) {
            n = e[t];
            this.refreshDockedItemLayoutSizeFlags(n);
        }
    },
    refreshDockedItemLayoutSizeFlags: function(e) {
        var t = this.container, i = this.positionDirectionMap[e.getDocked()], n = i === "horizontal" ? t.LAYOUT_HEIGHT : t.LAYOUT_WIDTH, r = t.getSizeFlags() & n;
        e.setLayoutSizeFlags(r);
    },
    dockItem: function(e) {
        var t = Ext.layout.wrapper.BoxDock, i = this.dockedItems, n = i.length, r = this.container, s = r.indexOf(e), a = this.positionDirectionMap, o = a[e.getDocked()], l = this.dockInnerWrapper, u, c, f, d, h, g, p, m, x, E, y;
        this.monitorSizeStateChange();
        this.monitorSizeFlagsChange();
        if (!l) {
            l = this.link("dockInnerWrapper", new Ext.layout.wrapper.Inner({
                container: this.container
            }));
        }
        if (n === 0) {
            i.push(e);
            E = new t({
                container: this.container,
                direction: o
            });
            E.addItem(e);
            E.getElement().replace(l.getElement());
            E.setInnerWrapper(l);
            r.onInitialized("onContainerSizeStateChange", this);
        } else {
            for (c = 0; c < n; c++) {
                f = i[c];
                d = r.indexOf(f);
                if (d > s) {
                    p = h || i[0];
                    i.splice(c, 0, e);
                    break;
                }
                h = f;
            }
            if (!p) {
                p = i[n - 1];
                i.push(e);
            }
            m = p.getDocked();
            x = p.$dockWrapper;
            u = a[m];
            if (o === u) {
                x.addItem(e);
            } else {
                g = x.getItemsSlice(s);
                E = new t({
                    container: this.container,
                    direction: o
                });
                if (g.length > 0) {
                    if (g.length === x.itemsCount) {
                        y = x;
                        E.setSizeState(y.getSizeState());
                        E.getElement().replace(y.getElement());
                    } else {
                        y = new t({
                            container: this.container,
                            direction: u
                        });
                        y.setInnerWrapper(x.getInnerWrapper());
                        y.addItems(g);
                        x.setInnerWrapper(E);
                    }
                    E.setInnerWrapper(y);
                } else {
                    E.setInnerWrapper(x.getInnerWrapper());
                    x.setInnerWrapper(E);
                }
                E.addItem(e);
            }
        }
        r.onInitialized("refreshDockedItemLayoutSizeFlags", this, [ e ]);
    },
    getDockWrapper: function() {
        var e = this.dockedItems;
        if (e.length > 0) {
            return e[0].$dockWrapper;
        }
        return null;
    },
    undockItem: function(e) {
        var t = this.dockedItems;
        if (e.$dockWrapper) {
            e.$dockWrapper.removeItem(e);
        }
        Ext.Array.remove(t, e);
        e.setLayoutSizeFlags(0);
    },
    destroy: function() {
        this.dockedItems.length = 0;
        delete this.dockedItems;
        this.callSuper();
    }
});

Ext.define("Ext.layout.Box", {
    extend: "Ext.layout.Default",
    config: {
        orient: "horizontal",
        align: "start",
        pack: "start"
    },
    alias: "layout.tablebox",
    layoutBaseClass: "x-layout-tablebox",
    itemClass: "x-layout-tablebox-item",
    setContainer: function(e) {
        this.callSuper(arguments);
        e.innerElement.addCls(this.layoutBaseClass);
        e.on("flexchange", "onItemFlexChange", this, {
            delegate: "> component"
        });
    },
    onItemInnerStateChange: function(e, t) {
        this.callSuper(arguments);
        e.toggleCls(this.itemClass, t);
    },
    onItemFlexChange: function() {}
});

Ext.define("Ext.layout.Fit", {
    extend: "Ext.layout.Default",
    isFit: true,
    alias: "layout.fit",
    layoutClass: "x-layout-fit",
    itemClass: "x-layout-fit-item",
    setContainer: function(e) {
        this.callSuper(arguments);
        e.innerElement.addCls(this.layoutClass);
        this.onContainerSizeFlagsChange();
        this.monitorSizeFlagsChange();
    },
    onContainerSizeFlagsChange: function() {
        var e = this.container, t = e.getSizeFlags(), i = Boolean(t & e.LAYOUT_STRETCHED), n = e.innerItems, r, s, a;
        this.callSuper();
        for (r = 0, s = n.length; r < s; r++) {
            a = n[r];
            a.setLayoutSizeFlags(t);
        }
        e.innerElement.toggleCls("x-stretched", i);
    },
    onItemInnerStateChange: function(e, t) {
        this.callSuper(arguments);
        e.toggleCls(this.itemClass, t);
        e.setLayoutSizeFlags(t ? this.container.getSizeFlags() : 0);
    }
});

Ext.define("Ext.layout.Float", {
    extend: "Ext.layout.Default",
    alias: "layout.float",
    config: {
        direction: "left"
    },
    layoutClass: "layout-float",
    itemClass: "layout-float-item",
    setContainer: function(e) {
        this.callSuper(arguments);
        e.innerElement.addCls(this.layoutClass);
    },
    onItemInnerStateChange: function(e, t) {
        this.callSuper(arguments);
        e.toggleCls(this.itemClass, t);
    },
    updateDirection: function(e, t) {
        var i = "direction-";
        this.container.innerElement.swapCls(i + e, i + t);
    }
});

Ext.define("Ext.layout.wrapper.Dock", {
    requires: [ "Ext.util.Wrapper" ],
    config: {
        direction: "horizontal",
        element: {
            className: "x-dock"
        },
        bodyElement: {
            className: "x-dock-body"
        },
        innerWrapper: null,
        sizeState: false,
        container: null
    },
    positionMap: {
        top: "start",
        left: "start",
        bottom: "end",
        right: "end"
    },
    constructor: function(e) {
        this.items = {
            start: [],
            end: []
        };
        this.itemsCount = 0;
        this.initConfig(e);
    },
    addItems: function(e) {
        var t, i, n;
        for (t = 0, i = e.length; t < i; t++) {
            n = e[t];
            this.addItem(n);
        }
    },
    addItem: function(e) {
        var t = e.getDocked(), i = this.positionMap[t], n = e.$dockWrapper, r = this.getContainer(), s = r.indexOf(e), a = this.items, o = a[i], l, u, c, f, d, h, g;
        if (n) {
            n.removeItem(e);
        }
        e.$dockWrapper = this;
        l = e.link("$dockItemWrapper", new Ext.util.Wrapper({
            className: "x-dock-item"
        }));
        e.addCls("x-docked-" + t);
        u = l.element;
        for (c = 0, f = o.length; c < f; c++) {
            d = o[c];
            g = r.indexOf(d);
            if (g > s) {
                h = d.element;
                o.splice(c, 0, e);
                break;
            }
        }
        if (!h) {
            o.push(e);
            h = this.getBodyElement();
        }
        this.itemsCount++;
        if (i === "start") {
            u.insertBefore(h);
        } else {
            u.insertAfter(h);
        }
        l.wrap(e.element);
        l.bindSize(this.getDirection() === "horizontal" ? "width" : "height");
    },
    removeItem: function(e) {
        var t = e.getDocked(), i = this.items[this.positionMap[t]];
        e.removeCls("x-docked-" + t);
        Ext.Array.remove(i, e);
        e.unlink("$dockItemWrapper");
        e.element.detach();
        delete e.$dockWrapper;
        if (--this.itemsCount === 0) {
            this.destroy();
        }
    },
    getItemsSlice: function(e) {
        var t = this.getContainer(), i = this.items, n = [], r, s, a, o;
        for (r = i.start, s = 0, a = r.length; s < a; s++) {
            o = r[s];
            if (t.indexOf(o) > e) {
                n.push(o);
            }
        }
        for (r = i.end, s = 0, a = r.length; s < a; s++) {
            o = r[s];
            if (t.indexOf(o) > e) {
                n.push(o);
            }
        }
        return n;
    },
    applyElement: function(e) {
        return Ext.Element.create(e);
    },
    updateElement: function(e) {
        e.addCls("x-dock-" + this.getDirection());
    },
    applyBodyElement: function(e) {
        return Ext.Element.create(e);
    },
    updateBodyElement: function(e) {
        this.getElement().append(e);
    },
    updateInnerWrapper: function(e, t) {
        var i = this.getBodyElement();
        if (t && t.$outerWrapper === this) {
            i.remove(t.getElement());
            delete t.$outerWrapper;
        }
        if (e) {
            e.setSizeState(this.getSizeState());
            e.$outerWrapper = this;
            i.append(e.getElement());
        }
    },
    updateSizeState: function(e) {
        var t = this.getInnerWrapper();
        this.getElement().setSizeState(e);
        if (t) {
            t.setSizeState(e);
        }
    },
    destroy: function() {
        var e = this.getInnerWrapper(), t = this.$outerWrapper;
        if (e) {
            if (t) {
                t.setInnerWrapper(e);
            } else {
                e.getElement().replace(this.getElement());
                delete e.$outerWrapper;
            }
        }
        delete this.$outerWrapper;
        this.setInnerWrapper(null);
        this.unlink("_bodyElement", "_element");
        this.callSuper();
    }
});

Ext.define("Ext.layout.FlexBox", {
    extend: "Ext.layout.Box",
    alias: "layout.box",
    config: {
        align: "stretch"
    },
    layoutBaseClass: "x-layout-box",
    itemClass: "x-layout-box-item",
    setContainer: function(e) {
        this.callSuper(arguments);
        this.monitorSizeFlagsChange();
    },
    applyOrient: function(e) {
        if (e !== "horizontal" && e !== "vertical") {
            Ext.Logger.error("Invalid box orient of: '" + e + "', must be either 'horizontal' or 'vertical'");
        }
        return e;
    },
    updateOrient: function(e, t) {
        var i = this.container, n = {
            delegate: "> component"
        };
        if (e === "horizontal") {
            this.sizePropertyName = "width";
        } else {
            this.sizePropertyName = "height";
        }
        i.innerElement.swapCls("x-" + e, "x-" + t);
        if (t) {
            i.un(t === "horizontal" ? "widthchange" : "heightchange", "onItemSizeChange", this, n);
            this.redrawContainer();
        }
        i.on(e === "horizontal" ? "widthchange" : "heightchange", "onItemSizeChange", this, n);
    },
    onItemInnerStateChange: function(e, t) {
        this.callSuper(arguments);
        var i, n;
        e.toggleCls(this.itemClass, t);
        if (t) {
            i = e.getFlex();
            n = e.get(this.sizePropertyName);
            if (i) {
                this.doItemFlexChange(e, i);
            } else if (n) {
                this.doItemSizeChange(e, n);
            }
        }
        this.refreshItemSizeState(e);
    },
    refreshItemSizeState: function(e) {
        var t = e.isInnerItem(), i = this.container, n = i.LAYOUT_HEIGHT, r = i.LAYOUT_WIDTH, s = this.sizePropertyName, a = 0, o = i.getSizeFlags();
        if (t) {
            a |= i.LAYOUT_STRETCHED;
            if (this.getAlign() === "stretch") {
                a |= o & (s === "width" ? n : r);
            }
            if (e.getFlex()) {
                a |= o & (s === "width" ? r : n);
            }
        }
        e.setLayoutSizeFlags(a);
    },
    refreshAllItemSizedStates: function() {
        var e = this.container.innerItems, t, i, n;
        for (t = 0, i = e.length; t < i; t++) {
            n = e[t];
            this.refreshItemSizeState(n);
        }
    },
    onContainerSizeFlagsChange: function() {
        this.refreshAllItemSizedStates();
        this.callSuper(arguments);
    },
    onItemSizeChange: function(e, t) {
        if (e.isInnerItem()) {
            this.doItemSizeChange(e, t);
        }
    },
    doItemSizeChange: function(e, t) {
        if (t) {
            e.setFlex(null);
            this.redrawContainer();
        }
    },
    onItemFlexChange: function(e, t) {
        if (e.isInnerItem()) {
            this.doItemFlexChange(e, t);
            this.refreshItemSizeState(e);
        }
    },
    doItemFlexChange: function(e, t) {
        this.setItemFlex(e, t);
        if (t) {
            e.set(this.sizePropertyName, null);
        } else {
            this.redrawContainer();
        }
    },
    redrawContainer: function() {
        var e = this.container, t = e.element.dom.parentNode;
        if (t && t.nodeType !== 11) {
            e.innerElement.redraw();
        }
    },
    setItemFlex: function(e, t) {
        var i = e.element;
        i.toggleCls("x-flexed", !!t);
        i.setStyle("-webkit-box-flex", t);
    },
    convertPosition: function(e) {
        var t = this.positionMap;
        if (t.hasOwnProperty(e)) {
            return t[e];
        }
        return e;
    },
    applyAlign: function(e) {
        return this.convertPosition(e);
    },
    updateAlign: function(e, t) {
        var i = this.container;
        i.innerElement.swapCls(e, t, true, "x-align");
        if (t !== undefined) {
            this.refreshAllItemSizedStates();
        }
    },
    applyPack: function(e) {
        return this.convertPosition(e);
    },
    updatePack: function(e, t) {
        this.container.innerElement.swapCls(e, t, true, "x-pack");
    }
});

Ext.define("Ext.layout.HBox", {
    extend: "Ext.layout.FlexBox",
    alias: "layout.hbox"
});

Ext.define("Ext.layout.VBox", {
    extend: "Ext.layout.FlexBox",
    alias: "layout.vbox",
    config: {
        orient: "vertical"
    }
});

Ext.define("Ext.fx.layout.card.Scroll", {
    extend: "Ext.fx.layout.card.Abstract",
    requires: [ "Ext.fx.easing.Linear" ],
    alias: "fx.layout.card.scroll",
    config: {
        duration: 150
    },
    constructor: function(e) {
        this.initConfig(e);
        this.doAnimationFrame = Ext.Function.bind(this.doAnimationFrame, this);
    },
    getEasing: function() {
        var e = this.easing;
        if (!e) {
            this.easing = e = new Ext.fx.easing.Linear();
        }
        return e;
    },
    updateDuration: function(e) {
        this.getEasing().setDuration(e);
    },
    onActiveItemChange: function(e, t, i, n, r) {
        var s = this.getDirection(), a = this.getEasing(), o, l, u, c, f, d;
        if (t && i) {
            if (this.isAnimating) {
                this.stopAnimation();
            }
            t.setWidth("100%");
            t.setHeight("100%");
            o = this.getLayout().container.innerElement;
            c = o.getWidth();
            f = o.getHeight();
            l = t.renderElement;
            u = i.renderElement;
            this.oldItem = i;
            this.newItem = t;
            this.currentEventController = r;
            this.containerElement = o;
            this.isReverse = d = this.getReverse();
            t.show();
            if (s == "right") {
                s = "left";
                this.isReverse = d = !d;
            } else if (s == "down") {
                s = "up";
                this.isReverse = d = !d;
            }
            if (s == "left") {
                if (d) {
                    a.setConfig({
                        startValue: c,
                        endValue: 0
                    });
                    o.dom.scrollLeft = c;
                    u.setLeft(c);
                } else {
                    a.setConfig({
                        startValue: 0,
                        endValue: c
                    });
                    l.setLeft(c);
                }
            } else {
                if (d) {
                    a.setConfig({
                        startValue: f,
                        endValue: 0
                    });
                    o.dom.scrollTop = f;
                    u.setTop(f);
                } else {
                    a.setConfig({
                        startValue: 0,
                        endValue: f
                    });
                    l.setTop(f);
                }
            }
            this.startAnimation();
            r.pause();
        }
    },
    startAnimation: function() {
        this.isAnimating = true;
        this.getEasing().setStartTime(Date.now());
        this.timer = setInterval(this.doAnimationFrame, 20);
        this.doAnimationFrame();
    },
    doAnimationFrame: function() {
        var e = this.getEasing(), t = this.getDirection(), i = "scrollTop", n;
        if (t == "left" || t == "right") {
            i = "scrollLeft";
        }
        if (e.isEnded) {
            this.stopAnimation();
        } else {
            n = e.getValue();
            this.containerElement.dom[i] = n;
        }
    },
    stopAnimation: function() {
        var e = this, t = e.getDirection(), i = "setTop", n = e.oldItem, r = e.newItem;
        if (t == "left" || t == "right") {
            i = "setLeft";
        }
        e.currentEventController.resume();
        if (e.isReverse && n && n.renderElement && n.renderElement.dom) {
            n.renderElement[i](null);
        } else if (r && r.renderElement && r.renderElement.dom) {
            r.renderElement[i](null);
        }
        clearInterval(e.timer);
        e.isAnimating = false;
        e.fireEvent("animationend", e);
    }
});

Ext.define("Ext.util.AbstractMixedCollection", {
    requires: [ "Ext.util.Filter" ],
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    constructor: function(e, t) {
        var i = this;
        i.items = [];
        i.map = {};
        i.keys = [];
        i.length = 0;
        i.allowFunctions = e === true;
        if (t) {
            i.getKey = t;
        }
        i.mixins.observable.constructor.call(i);
    },
    allowFunctions: false,
    add: function(e, t) {
        var i = this, n = t, r = e, s;
        if (arguments.length == 1) {
            n = r;
            r = i.getKey(n);
        }
        if (typeof r != "undefined" && r !== null) {
            s = i.map[r];
            if (typeof s != "undefined") {
                return i.replace(r, n);
            }
            i.map[r] = n;
        }
        i.length++;
        i.items.push(n);
        i.keys.push(r);
        i.fireEvent("add", i.length - 1, n, r);
        return n;
    },
    getKey: function(e) {
        return e.id;
    },
    replace: function(e, t) {
        var i = this, n, r;
        if (arguments.length == 1) {
            t = arguments[0];
            e = i.getKey(t);
        }
        n = i.map[e];
        if (typeof e == "undefined" || e === null || typeof n == "undefined") {
            return i.add(e, t);
        }
        r = i.indexOfKey(e);
        i.items[r] = t;
        i.map[e] = t;
        i.fireEvent("replace", e, n, t);
        return t;
    },
    addAll: function(e) {
        var t = this, i = 0, n, r, s;
        if (arguments.length > 1 || Ext.isArray(e)) {
            n = arguments.length > 1 ? arguments : e;
            for (r = n.length; i < r; i++) {
                t.add(n[i]);
            }
        } else {
            for (s in e) {
                if (e.hasOwnProperty(s)) {
                    if (t.allowFunctions || typeof e[s] != "function") {
                        t.add(s, e[s]);
                    }
                }
            }
        }
    },
    each: function(e, t) {
        var i = [].concat(this.items), n = 0, r = i.length, s;
        for (;n < r; n++) {
            s = i[n];
            if (e.call(t || s, s, n, r) === false) {
                break;
            }
        }
    },
    eachKey: function(e, t) {
        var i = this.keys, n = this.items, r = 0, s = i.length;
        for (;r < s; r++) {
            e.call(t || window, i[r], n[r], r, s);
        }
    },
    findBy: function(e, t) {
        var i = this.keys, n = this.items, r = 0, s = n.length;
        for (;r < s; r++) {
            if (e.call(t || window, n[r], i[r])) {
                return n[r];
            }
        }
        return null;
    },
    insert: function(e, t, i) {
        var n = this, r = t, s = i;
        if (arguments.length == 2) {
            s = r;
            r = n.getKey(s);
        }
        if (n.containsKey(r)) {
            n.suspendEvents();
            n.removeAtKey(r);
            n.resumeEvents();
        }
        if (e >= n.length) {
            return n.add(r, s);
        }
        n.length++;
        Ext.Array.splice(n.items, e, 0, s);
        if (typeof r != "undefined" && r !== null) {
            n.map[r] = s;
        }
        Ext.Array.splice(n.keys, e, 0, r);
        n.fireEvent("add", e, s, r);
        return s;
    },
    remove: function(e) {
        return this.removeAt(this.indexOf(e));
    },
    removeAll: function(e) {
        Ext.each(e || [], function(e) {
            this.remove(e);
        }, this);
        return this;
    },
    removeAt: function(e) {
        var t = this, i, n;
        if (e < t.length && e >= 0) {
            t.length--;
            i = t.items[e];
            Ext.Array.erase(t.items, e, 1);
            n = t.keys[e];
            if (typeof n != "undefined") {
                delete t.map[n];
            }
            Ext.Array.erase(t.keys, e, 1);
            t.fireEvent("remove", i, n);
            return i;
        }
        return false;
    },
    removeAtKey: function(e) {
        return this.removeAt(this.indexOfKey(e));
    },
    getCount: function() {
        return this.length;
    },
    indexOf: function(e) {
        return Ext.Array.indexOf(this.items, e);
    },
    indexOfKey: function(e) {
        return Ext.Array.indexOf(this.keys, e);
    },
    get: function(e) {
        var t = this, i = t.map[e], n = i !== undefined ? i : typeof e == "number" ? t.items[e] : undefined;
        return typeof n != "function" || t.allowFunctions ? n : null;
    },
    getAt: function(e) {
        return this.items[e];
    },
    getByKey: function(e) {
        return this.map[e];
    },
    contains: function(e) {
        return Ext.Array.contains(this.items, e);
    },
    containsKey: function(e) {
        return typeof this.map[e] != "undefined";
    },
    clear: function() {
        var e = this;
        e.length = 0;
        e.items = [];
        e.keys = [];
        e.map = {};
        e.fireEvent("clear");
    },
    first: function() {
        return this.items[0];
    },
    last: function() {
        return this.items[this.length - 1];
    },
    sum: function(e, t, i, n) {
        var r = this.extractValues(e, t), s = r.length, a = 0, o;
        i = i || 0;
        n = n || n === 0 ? n : s - 1;
        for (o = i; o <= n; o++) {
            a += r[o];
        }
        return a;
    },
    collect: function(e, t, i) {
        var n = this.extractValues(e, t), r = n.length, s = {}, a = [], o, l, u;
        for (u = 0; u < r; u++) {
            o = n[u];
            l = String(o);
            if ((i || !Ext.isEmpty(o)) && !s[l]) {
                s[l] = true;
                a.push(o);
            }
        }
        return a;
    },
    extractValues: function(e, t) {
        var i = this.items;
        if (t) {
            i = Ext.Array.pluck(i, t);
        }
        return Ext.Array.pluck(i, e);
    },
    getRange: function(e, t) {
        var i = this, n = i.items, r = [], s;
        if (n.length < 1) {
            return r;
        }
        e = e || 0;
        t = Math.min(typeof t == "undefined" ? i.length - 1 : t, i.length - 1);
        if (e <= t) {
            for (s = e; s <= t; s++) {
                r[r.length] = n[s];
            }
        } else {
            for (s = e; s >= t; s--) {
                r[r.length] = n[s];
            }
        }
        return r;
    },
    filter: function(e, t, i, n) {
        var r = [], s;
        if (Ext.isString(e)) {
            r.push(Ext.create("Ext.util.Filter", {
                property: e,
                value: t,
                anyMatch: i,
                caseSensitive: n
            }));
        } else if (Ext.isArray(e) || e instanceof Ext.util.Filter) {
            r = r.concat(e);
        }
        s = function(e) {
            var t = true, i = r.length, n;
            for (n = 0; n < i; n++) {
                var s = r[n], a = s.getFilterFn(), o = s.getScope();
                t = t && a.call(o, e);
            }
            return t;
        };
        return this.filterBy(s);
    },
    filterBy: function(e, t) {
        var i = this, n = new this.self(), r = i.keys, s = i.items, a = s.length, o;
        n.getKey = i.getKey;
        for (o = 0; o < a; o++) {
            if (e.call(t || i, s[o], r[o])) {
                n.add(r[o], s[o]);
            }
        }
        return n;
    },
    findIndex: function(e, t, i, n, r) {
        if (Ext.isEmpty(t, false)) {
            return -1;
        }
        t = this.createValueMatcher(t, n, r);
        return this.findIndexBy(function(i) {
            return i && t.test(i[e]);
        }, null, i);
    },
    findIndexBy: function(e, t, i) {
        var n = this, r = n.keys, s = n.items, a = i || 0, o = s.length;
        for (;a < o; a++) {
            if (e.call(t || n, s[a], r[a])) {
                return a;
            }
        }
        return -1;
    },
    createValueMatcher: function(e, t, i, n) {
        if (!e.exec) {
            var r = Ext.String.escapeRegex;
            e = String(e);
            if (t === true) {
                e = r(e);
            } else {
                e = "^" + r(e);
                if (n === true) {
                    e += "$";
                }
            }
            e = new RegExp(e, i ? "" : "i");
        }
        return e;
    },
    clone: function() {
        var e = this, t = new this.self(), i = e.keys, n = e.items, r = 0, s = n.length;
        for (;r < s; r++) {
            t.add(i[r], n[r]);
        }
        t.getKey = e.getKey;
        return t;
    }
});

Ext.define("Ext.util.Sortable", {
    extend: "Ext.mixin.Mixin",
    isSortable: true,
    mixinConfig: {
        hooks: {
            destroy: "destroy"
        }
    },
    defaultSortDirection: "ASC",
    requires: [ "Ext.util.Sorter" ],
    initSortable: function() {
        var e = this, t = e.sorters;
        e.sorters = Ext.create("Ext.util.AbstractMixedCollection", false, function(e) {
            return e.id || e.property;
        });
        if (t) {
            e.sorters.addAll(e.decodeSorters(t));
        }
    },
    sort: function(e, t, i, n) {
        var r = this, s, a, o;
        if (Ext.isArray(e)) {
            n = i;
            i = t;
            o = e;
        } else if (Ext.isObject(e)) {
            n = i;
            i = t;
            o = [ e ];
        } else if (Ext.isString(e)) {
            s = r.sorters.get(e);
            if (!s) {
                s = {
                    property: e,
                    direction: t
                };
                o = [ s ];
            } else if (t === undefined) {
                s.toggle();
            } else {
                s.setDirection(t);
            }
        }
        if (o && o.length) {
            o = r.decodeSorters(o);
            if (Ext.isString(i)) {
                if (i === "prepend") {
                    e = r.sorters.clone().items;
                    r.sorters.clear();
                    r.sorters.addAll(o);
                    r.sorters.addAll(e);
                } else {
                    r.sorters.addAll(o);
                }
            } else {
                r.sorters.clear();
                r.sorters.addAll(o);
            }
            if (n !== false) {
                r.onBeforeSort(o);
            }
        }
        if (n !== false) {
            e = r.sorters.items;
            if (e.length) {
                a = function(t, i) {
                    var n = e[0].sort(t, i), r = e.length, s;
                    for (s = 1; s < r; s++) {
                        n = n || e[s].sort.call(this, t, i);
                    }
                    return n;
                };
                r.doSort(a);
            }
        }
        return e;
    },
    onBeforeSort: Ext.emptyFn,
    decodeSorters: function(e) {
        if (!Ext.isArray(e)) {
            if (e === undefined) {
                e = [];
            } else {
                e = [ e ];
            }
        }
        var t = e.length, i = Ext.util.Sorter, n = this.model ? this.model.prototype.fields : null, r, s, a;
        for (a = 0; a < t; a++) {
            s = e[a];
            if (!(s instanceof i)) {
                if (Ext.isString(s)) {
                    s = {
                        property: s
                    };
                }
                Ext.applyIf(s, {
                    root: this.sortRoot,
                    direction: "ASC"
                });
                if (s.fn) {
                    s.sorterFn = s.fn;
                }
                if (typeof s == "function") {
                    s = {
                        sorterFn: s
                    };
                }
                if (n && !s.transform) {
                    r = n.get(s.property);
                    s.transform = r ? r.sortType : undefined;
                }
                e[a] = Ext.create("Ext.util.Sorter", s);
            }
        }
        return e;
    },
    getSorters: function() {
        return this.sorters.items;
    },
    destroy: function() {
        this.callSuper();
        Ext.destroy(this.sorters);
    }
});

Ext.define("Ext.util.MixedCollection", {
    extend: "Ext.util.AbstractMixedCollection",
    mixins: {
        sortable: "Ext.util.Sortable"
    },
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        e.mixins.sortable.initSortable.call(e);
    },
    doSort: function(e) {
        this.sortBy(e);
    },
    _sort: function(e, t, i) {
        var n = this, r, s, a = String(t).toUpperCase() == "DESC" ? -1 : 1, o = [], l = n.keys, u = n.items;
        i = i || function(e, t) {
            return e - t;
        };
        for (r = 0, s = u.length; r < s; r++) {
            o[o.length] = {
                key: l[r],
                value: u[r],
                index: r
            };
        }
        Ext.Array.sort(o, function(t, n) {
            var r = i(t[e], n[e]) * a;
            if (r === 0) {
                r = t.index < n.index ? -1 : 1;
            }
            return r;
        });
        for (r = 0, s = o.length; r < s; r++) {
            u[r] = o[r].value;
            l[r] = o[r].key;
        }
        n.fireEvent("sort", n);
    },
    sortBy: function(e) {
        var t = this, i = t.items, n = t.keys, r = i.length, s = [], a;
        for (a = 0; a < r; a++) {
            s[a] = {
                key: n[a],
                value: i[a],
                index: a
            };
        }
        Ext.Array.sort(s, function(t, i) {
            var n = e(t.value, i.value);
            if (n === 0) {
                n = t.index < i.index ? -1 : 1;
            }
            return n;
        });
        for (a = 0; a < r; a++) {
            i[a] = s[a].value;
            n[a] = s[a].key;
        }
        t.fireEvent("sort", t, i, n);
    },
    reorder: function(e) {
        var t = this, i = t.items, n = 0, r = i.length, s = [], a = [], o;
        t.suspendEvents();
        for (o in e) {
            s[e[o]] = i[o];
        }
        for (n = 0; n < r; n++) {
            if (e[n] == undefined) {
                a.push(i[n]);
            }
        }
        for (n = 0; n < r; n++) {
            if (s[n] == undefined) {
                s[n] = a.shift();
            }
        }
        t.clear();
        t.addAll(s);
        t.resumeEvents();
        t.fireEvent("sort", t);
    },
    sortByKey: function(e, t) {
        this._sort("key", e, t || function(e, t) {
            var i = String(e).toUpperCase(), n = String(t).toUpperCase();
            return i > n ? 1 : i < n ? -1 : 0;
        });
    }
});

Ext.define("Ext.ItemCollection", {
    extend: "Ext.util.MixedCollection",
    getKey: function(e) {
        return e.getItemId();
    },
    has: function(e) {
        return this.map.hasOwnProperty(e.getId());
    }
});

Ext.define("Ext.fx.layout.card.Style", {
    extend: "Ext.fx.layout.card.Abstract",
    requires: [ "Ext.fx.Animation" ],
    config: {
        inAnimation: {
            before: {
                visibility: null
            },
            preserveEndState: false,
            replacePrevious: true
        },
        outAnimation: {
            preserveEndState: false,
            replacePrevious: true
        }
    },
    constructor: function(e) {
        var t, i;
        this.initConfig(e);
        this.endAnimationCounter = 0;
        t = this.getInAnimation();
        i = this.getOutAnimation();
        t.on("animationend", "incrementEnd", this);
        i.on("animationend", "incrementEnd", this);
    },
    updateDirection: function(e) {
        this.getInAnimation().setDirection(e);
        this.getOutAnimation().setDirection(e);
    },
    updateDuration: function(e) {
        this.getInAnimation().setDuration(e);
        this.getOutAnimation().setDuration(e);
    },
    updateReverse: function(e) {
        this.getInAnimation().setReverse(e);
        this.getOutAnimation().setReverse(e);
    },
    incrementEnd: function() {
        this.endAnimationCounter++;
        if (this.endAnimationCounter > 1) {
            this.endAnimationCounter = 0;
            this.fireEvent("animationend", this);
        }
    },
    applyInAnimation: function(e, t) {
        return Ext.factory(e, Ext.fx.Animation, t);
    },
    applyOutAnimation: function(e, t) {
        return Ext.factory(e, Ext.fx.Animation, t);
    },
    updateInAnimation: function(e) {
        e.setScope(this);
    },
    updateOutAnimation: function(e) {
        e.setScope(this);
    },
    onActiveItemChange: function(e, t, i, n, r) {
        var s = this.getInAnimation(), a = this.getOutAnimation(), o, l;
        if (t && i && i.isPainted()) {
            o = t.renderElement;
            l = i.renderElement;
            s.setElement(o);
            a.setElement(l);
            a.setOnBeforeEnd(function(e, t) {
                if (t || Ext.Animator.hasRunningAnimations(e)) {
                    r.firingArguments[1] = null;
                    r.firingArguments[2] = null;
                }
            });
            a.setOnEnd(function() {
                r.resume();
            });
            o.dom.style.setProperty("visibility", "hidden", "!important");
            t.show();
            Ext.Animator.run([ a, s ]);
            r.pause();
        }
    },
    destroy: function() {
        Ext.destroy(this.getInAnimation(), this.getOutAnimation());
        this.callParent(arguments);
    }
});

Ext.define("Ext.fx.layout.card.Slide", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.slide",
    config: {
        inAnimation: {
            type: "slide",
            easing: "ease-out"
        },
        outAnimation: {
            type: "slide",
            easing: "ease-out",
            out: true
        }
    },
    updateReverse: function(e) {
        this.getInAnimation().setReverse(e);
        this.getOutAnimation().setReverse(e);
    }
});

Ext.define("Ext.fx.layout.card.Cover", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.cover",
    config: {
        reverse: null,
        inAnimation: {
            before: {
                "z-index": 100
            },
            after: {
                "z-index": 0
            },
            type: "slide",
            easing: "ease-out"
        },
        outAnimation: {
            easing: "ease-out",
            from: {
                opacity: .99
            },
            to: {
                opacity: 1
            },
            out: true
        }
    },
    updateReverse: function(e) {
        this.getInAnimation().setReverse(e);
        this.getOutAnimation().setReverse(e);
    }
});

Ext.define("Ext.fx.layout.card.Reveal", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.reveal",
    config: {
        inAnimation: {
            easing: "ease-out",
            from: {
                opacity: .99
            },
            to: {
                opacity: 1
            }
        },
        outAnimation: {
            before: {
                "z-index": 100
            },
            after: {
                "z-index": 0
            },
            type: "slide",
            easing: "ease-out",
            out: true
        }
    },
    updateReverse: function(e) {
        this.getInAnimation().setReverse(e);
        this.getOutAnimation().setReverse(e);
    }
});

Ext.define("Ext.fx.layout.card.Fade", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.fade",
    config: {
        reverse: null,
        inAnimation: {
            type: "fade",
            easing: "ease-out"
        },
        outAnimation: {
            type: "fade",
            easing: "ease-out",
            out: true
        }
    }
});

Ext.define("Ext.fx.layout.card.Flip", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.flip",
    config: {
        duration: 500,
        inAnimation: {
            type: "flip",
            half: true,
            easing: "ease-out",
            before: {
                "backface-visibility": "hidden"
            },
            after: {
                "backface-visibility": null
            }
        },
        outAnimation: {
            type: "flip",
            half: true,
            easing: "ease-in",
            before: {
                "backface-visibility": "hidden"
            },
            after: {
                "backface-visibility": null
            },
            out: true
        }
    },
    updateDuration: function(e) {
        var t = e / 2, i = this.getInAnimation(), n = this.getOutAnimation();
        i.setDelay(t);
        i.setDuration(t);
        n.setDuration(t);
    }
});

Ext.define("Ext.fx.layout.card.Pop", {
    extend: "Ext.fx.layout.card.Style",
    alias: "fx.layout.card.pop",
    config: {
        duration: 500,
        inAnimation: {
            type: "pop",
            easing: "ease-out"
        },
        outAnimation: {
            type: "pop",
            easing: "ease-in",
            out: true
        }
    },
    updateDuration: function(e) {
        var t = e / 2, i = this.getInAnimation(), n = this.getOutAnimation();
        i.setDelay(t);
        i.setDuration(t);
        n.setDuration(t);
    }
});

Ext.define("Ext.fx.layout.Card", {
    requires: [ "Ext.fx.layout.card.Slide", "Ext.fx.layout.card.Cover", "Ext.fx.layout.card.Reveal", "Ext.fx.layout.card.Fade", "Ext.fx.layout.card.Flip", "Ext.fx.layout.card.Pop", "Ext.fx.layout.card.Scroll" ],
    constructor: function(e) {
        var t = Ext.fx.layout.card.Abstract, i;
        if (!e) {
            return null;
        }
        if (typeof e == "string") {
            i = e;
            e = {};
        } else if (e.type) {
            i = e.type;
        }
        e.elementBox = false;
        if (i) {
            if (Ext.os.is.Android2) {
                if (i != "fade") {
                    i = "scroll";
                }
            }
            t = Ext.ClassManager.getByAlias("fx.layout.card." + i);
            if (!t) {
                Ext.Logger.error("Unknown card animation type: '" + i + "'");
            }
        }
        return Ext.factory(e, t);
    }
});

Ext.define("Ext.layout.Card", {
    extend: "Ext.layout.Default",
    alias: "layout.card",
    isCard: true,
    layoutClass: "x-layout-card",
    itemClass: "x-layout-card-item",
    requires: [ "Ext.fx.layout.Card" ],
    applyAnimation: function(e) {
        return new Ext.fx.layout.Card(e);
    },
    updateAnimation: function(e, t) {
        if (e && e.isAnimation) {
            e.setLayout(this);
        }
        if (t) {
            t.destroy();
        }
    },
    setContainer: function(e) {
        this.callSuper(arguments);
        e.innerElement.addCls(this.layoutClass);
        e.onInitialized("onContainerInitialized", this);
    },
    onContainerInitialized: function() {
        var e = this.container, t = e.getActiveItem();
        if (t) {
            t.show();
        }
        e.on("activeitemchange", "onContainerActiveItemChange", this);
    },
    onContainerActiveItemChange: function(e) {
        this.relayEvent(arguments, "doActiveItemChange");
    },
    onItemInnerStateChange: function(e, t, i) {
        this.callSuper(arguments);
        var n = this.container, r = n.getActiveItem();
        e.toggleCls(this.itemClass, t);
        e.setLayoutSizeFlags(t ? n.LAYOUT_BOTH : 0);
        if (t) {
            if (r !== n.innerIndexOf(e) && r !== e && e !== n.pendingActiveItem) {
                e.hide();
            }
        } else {
            if (!i && !e.isDestroyed && e.isDestroying !== true) {
                e.show();
            }
        }
    },
    doActiveItemChange: function(e, t, i) {
        if (i) {
            i.hide();
        }
        if (t) {
            t.show();
        }
    },
    destroy: function() {
        this.callParent(arguments);
        Ext.destroy(this.getAnimation());
    }
});

Ext.define("Ext.fx.easing.BoundMomentum", {
    extend: "Ext.fx.easing.Abstract",
    requires: [ "Ext.fx.easing.Momentum", "Ext.fx.easing.Bounce" ],
    config: {
        momentum: null,
        bounce: null,
        minMomentumValue: 0,
        maxMomentumValue: 0,
        minVelocity: .01,
        startVelocity: 0
    },
    applyMomentum: function(e, t) {
        return Ext.factory(e, Ext.fx.easing.Momentum, t);
    },
    applyBounce: function(e, t) {
        return Ext.factory(e, Ext.fx.easing.Bounce, t);
    },
    updateStartTime: function(e) {
        this.getMomentum().setStartTime(e);
        this.callParent(arguments);
    },
    updateStartVelocity: function(e) {
        this.getMomentum().setStartVelocity(e);
    },
    updateStartValue: function(e) {
        this.getMomentum().setStartValue(e);
    },
    reset: function() {
        this.lastValue = null;
        this.isBouncingBack = false;
        this.isOutOfBound = false;
        return this.callParent(arguments);
    },
    getValue: function() {
        var e = this.getMomentum(), t = this.getBounce(), i = e.getStartVelocity(), n = i > 0 ? 1 : -1, r = this.getMinMomentumValue(), s = this.getMaxMomentumValue(), a = n == 1 ? s : r, o = this.lastValue, l, u;
        if (i === 0) {
            return this.getStartValue();
        }
        if (!this.isOutOfBound) {
            l = e.getValue();
            u = e.getVelocity();
            if (Math.abs(u) < this.getMinVelocity()) {
                this.isEnded = true;
            }
            if (l >= r && l <= s) {
                return l;
            }
            this.isOutOfBound = true;
            t.setStartTime(Ext.Date.now()).setStartVelocity(u).setStartValue(a);
        }
        l = t.getValue();
        if (!this.isEnded) {
            if (!this.isBouncingBack) {
                if (o !== null) {
                    if (n == 1 && l < o || n == -1 && l > o) {
                        this.isBouncingBack = true;
                    }
                }
            } else {
                if (Math.round(l) == a) {
                    this.isEnded = true;
                }
            }
        }
        this.lastValue = l;
        return l;
    }
});

Ext.define("Ext.scroll.Scroller", {
    extend: "Ext.Evented",
    requires: [ "Ext.fx.easing.BoundMomentum", "Ext.fx.easing.EaseOut", "Ext.util.Translatable" ],
    config: {
        element: null,
        direction: "auto",
        fps: "auto",
        disabled: null,
        directionLock: false,
        momentumEasing: {
            momentum: {
                acceleration: 30,
                friction: .5
            },
            bounce: {
                acceleration: 30,
                springTension: .3
            },
            minVelocity: 1
        },
        bounceEasing: {
            duration: 400
        },
        outOfBoundRestrictFactor: .5,
        startMomentumResetTime: 300,
        maxAbsoluteVelocity: 6,
        containerSize: "auto",
        size: "auto",
        autoRefresh: true,
        initialOffset: {
            x: 0,
            y: 0
        },
        slotSnapSize: {
            x: 0,
            y: 0
        },
        slotSnapOffset: {
            x: 0,
            y: 0
        },
        slotSnapEasing: {
            duration: 150
        },
        translatable: {
            translationMethod: "auto",
            useWrapper: false
        }
    },
    cls: Ext.baseCSSPrefix + "scroll-scroller",
    containerCls: Ext.baseCSSPrefix + "scroll-container",
    dragStartTime: 0,
    dragEndTime: 0,
    isDragging: false,
    isAnimating: false,
    constructor: function(e) {
        var t = e && e.element;
        if (Ext.os.is.Android4 && !Ext.browser.is.Chrome) {
            this.onDrag = Ext.Function.createThrottled(this.onDrag, 20, this);
        }
        this.listeners = {
            scope: this,
            touchstart: "onTouchStart",
            touchend: "onTouchEnd",
            dragstart: "onDragStart",
            drag: "onDrag",
            dragend: "onDragEnd"
        };
        this.minPosition = {
            x: 0,
            y: 0
        };
        this.startPosition = {
            x: 0,
            y: 0
        };
        this.position = {
            x: 0,
            y: 0
        };
        this.velocity = {
            x: 0,
            y: 0
        };
        this.isAxisEnabledFlags = {
            x: false,
            y: false
        };
        this.flickStartPosition = {
            x: 0,
            y: 0
        };
        this.flickStartTime = {
            x: 0,
            y: 0
        };
        this.lastDragPosition = {
            x: 0,
            y: 0
        };
        this.dragDirection = {
            x: 0,
            y: 0
        };
        this.initialConfig = e;
        if (t) {
            this.setElement(t);
        }
        return this;
    },
    applyElement: function(e) {
        if (!e) {
            return;
        }
        return Ext.get(e);
    },
    updateElement: function(e) {
        this.initialize();
        e.addCls(this.cls);
        if (!this.getDisabled()) {
            this.attachListeneners();
        }
        this.onConfigUpdate([ "containerSize", "size" ], "refreshMaxPosition");
        this.on("maxpositionchange", "snapToBoundary");
        this.on("minpositionchange", "snapToBoundary");
        return this;
    },
    applyTranslatable: function(e, t) {
        return Ext.factory(e, Ext.util.Translatable, t);
    },
    updateTranslatable: function(e) {
        e.setConfig({
            element: this.getElement(),
            listeners: {
                animationframe: "onAnimationFrame",
                animationend: "onAnimationEnd",
                scope: this
            }
        });
    },
    updateFps: function(e) {
        if (e !== "auto") {
            this.getTranslatable().setFps(e);
        }
    },
    attachListeneners: function() {
        this.getContainer().on(this.listeners);
    },
    detachListeners: function() {
        this.getContainer().un(this.listeners);
    },
    updateDisabled: function(e) {
        if (e) {
            this.detachListeners();
        } else {
            this.attachListeneners();
        }
    },
    updateInitialOffset: function(e) {
        if (typeof e == "number") {
            e = {
                x: e,
                y: e
            };
        }
        var t = this.position, i, n;
        t.x = i = e.x;
        t.y = n = e.y;
        this.getTranslatable().translate(-i, -n);
    },
    applyDirection: function(e) {
        var t = this.getMinPosition(), i = this.getMaxPosition(), n, r;
        this.givenDirection = e;
        if (e === "auto") {
            n = i.x > t.x;
            r = i.y > t.y;
            if (n && r) {
                e = "both";
            } else if (n) {
                e = "horizontal";
            } else {
                e = "vertical";
            }
        }
        return e;
    },
    updateDirection: function(e) {
        var t = this.isAxisEnabledFlags;
        t.x = e === "both" || e === "horizontal";
        t.y = e === "both" || e === "vertical";
    },
    isAxisEnabled: function(e) {
        this.getDirection();
        return this.isAxisEnabledFlags[e];
    },
    applyMomentumEasing: function(e) {
        var t = Ext.fx.easing.BoundMomentum;
        return {
            x: Ext.factory(e, t),
            y: Ext.factory(e, t)
        };
    },
    applyBounceEasing: function(e) {
        var t = Ext.fx.easing.EaseOut;
        return {
            x: Ext.factory(e, t),
            y: Ext.factory(e, t)
        };
    },
    updateBounceEasing: function(e) {
        this.getTranslatable().setEasingX(e.x).setEasingY(e.y);
    },
    applySlotSnapEasing: function(e) {
        var t = Ext.fx.easing.EaseOut;
        return {
            x: Ext.factory(e, t),
            y: Ext.factory(e, t)
        };
    },
    getMinPosition: function() {
        var e = this.minPosition;
        if (!e) {
            this.minPosition = e = {
                x: 0,
                y: 0
            };
            this.fireEvent("minpositionchange", this, e);
        }
        return e;
    },
    getMaxPosition: function() {
        var e = this.maxPosition, t, i;
        if (!e) {
            t = this.getSize();
            i = this.getContainerSize();
            this.maxPosition = e = {
                x: Math.max(0, t.x - i.x),
                y: Math.max(0, t.y - i.y)
            };
            this.fireEvent("maxpositionchange", this, e);
        }
        return e;
    },
    refreshMaxPosition: function() {
        this.maxPosition = null;
        this.getMaxPosition();
    },
    applyContainerSize: function(e) {
        var t = this.getContainer().dom, i, n;
        if (!t) {
            return;
        }
        this.givenContainerSize = e;
        if (e === "auto") {
            i = t.offsetWidth;
            n = t.offsetHeight;
        } else {
            i = e.x;
            n = e.y;
        }
        return {
            x: i,
            y: n
        };
    },
    applySize: function(e) {
        var t = this.getElement().dom, i, n;
        if (!t) {
            return;
        }
        this.givenSize = e;
        if (e === "auto") {
            i = t.offsetWidth;
            n = t.offsetHeight;
        } else if (typeof e == "number") {
            i = e;
            n = e;
        } else {
            i = e.x;
            n = e.y;
        }
        return {
            x: i,
            y: n
        };
    },
    updateAutoRefresh: function(e) {
        this.getElement().toggleListener(e, "resize", "onElementResize", this);
        this.getContainer().toggleListener(e, "resize", "onContainerResize", this);
    },
    applySlotSnapSize: function(e) {
        if (typeof e == "number") {
            return {
                x: e,
                y: e
            };
        }
        return e;
    },
    applySlotSnapOffset: function(e) {
        if (typeof e == "number") {
            return {
                x: e,
                y: e
            };
        }
        return e;
    },
    getContainer: function() {
        var e = this.container;
        if (!e) {
            this.container = e = this.getElement().getParent();
            if (!e) {
                Ext.Logger.error("Making an element scrollable that doesn't have any container");
            }
            e.addCls(this.containerCls);
        }
        return e;
    },
    refresh: function() {
        this.stopAnimation();
        this.getTranslatable().refresh();
        this.setSize(this.givenSize);
        this.setContainerSize(this.givenContainerSize);
        this.setDirection(this.givenDirection);
        this.fireEvent("refresh", this);
        return this;
    },
    onElementResize: function(e, t) {
        this.setSize({
            x: t.width,
            y: t.height
        });
        this.refresh();
    },
    onContainerResize: function(e, t) {
        this.setContainerSize({
            x: t.width,
            y: t.height
        });
        this.refresh();
    },
    scrollTo: function(e, t, i) {
        if (this.isDestroyed) {
            return this;
        }
        if (typeof e != "number" && arguments.length === 1) {
            Ext.Logger.deprecate("Calling scrollTo() with an object argument is deprecated, " + "please pass x and y arguments instead", this);
            t = e.y;
            e = e.x;
        }
        var n = this.getTranslatable(), r = this.position, s = false, a, o;
        if (this.isAxisEnabled("x")) {
            if (typeof e != "number") {
                e = r.x;
            } else {
                if (r.x !== e) {
                    r.x = e;
                    s = true;
                }
            }
            a = -e;
        }
        if (this.isAxisEnabled("y")) {
            if (typeof t != "number") {
                t = r.y;
            } else {
                if (r.y !== t) {
                    r.y = t;
                    s = true;
                }
            }
            o = -t;
        }
        if (s) {
            if (i !== undefined && i !== false) {
                n.translateAnimated(a, o, i);
            } else {
                this.fireEvent("scroll", this, r.x, r.y);
                n.translate(a, o);
            }
        }
        return this;
    },
    scrollToTop: function(e) {
        var t = this.getInitialOffset();
        return this.scrollTo(t.x, t.y, e);
    },
    scrollToEnd: function(e) {
        var t = this.getSize(), i = this.getContainerSize();
        return this.scrollTo(t.x - i.x, t.y - i.y, e);
    },
    scrollBy: function(e, t, i) {
        var n = this.position;
        e = typeof e == "number" ? e + n.x : null;
        t = typeof t == "number" ? t + n.y : null;
        return this.scrollTo(e, t, i);
    },
    onTouchStart: function() {
        this.isTouching = true;
        this.stopAnimation();
    },
    onTouchEnd: function() {
        var e = this.position;
        this.isTouching = false;
        if (!this.isDragging && this.snapToSlot()) {
            this.fireEvent("scrollstart", this, e.x, e.y);
        }
    },
    onDragStart: function(e) {
        var t = this.getDirection(), i = e.absDeltaX, n = e.absDeltaY, r = this.getDirectionLock(), s = this.startPosition, a = this.flickStartPosition, o = this.flickStartTime, l = this.lastDragPosition, u = this.position, c = this.dragDirection, f = u.x, d = u.y, h = Ext.Date.now();
        this.isDragging = true;
        if (r && t !== "both") {
            if (t === "horizontal" && i > n || t === "vertical" && n > i) {
                e.stopPropagation();
            } else {
                this.isDragging = false;
                return;
            }
        }
        l.x = f;
        l.y = d;
        a.x = f;
        a.y = d;
        s.x = f;
        s.y = d;
        o.x = h;
        o.y = h;
        c.x = 0;
        c.y = 0;
        this.dragStartTime = h;
        this.isDragging = true;
        this.fireEvent("scrollstart", this, f, d);
    },
    onAxisDrag: function(e, t) {
        if (!this.isAxisEnabled(e)) {
            return;
        }
        var i = this.flickStartPosition, n = this.flickStartTime, r = this.lastDragPosition, s = this.dragDirection, a = this.position[e], o = this.getMinPosition()[e], l = this.getMaxPosition()[e], u = this.startPosition[e], c = r[e], f = u - t, d = s[e], h = this.getOutOfBoundRestrictFactor(), g = this.getStartMomentumResetTime(), p = Ext.Date.now(), m;
        if (f < o) {
            f *= h;
        } else if (f > l) {
            m = f - l;
            f = l + m * h;
        }
        if (f > c) {
            s[e] = 1;
        } else if (f < c) {
            s[e] = -1;
        }
        if (d !== 0 && s[e] !== d || p - n[e] > g) {
            i[e] = a;
            n[e] = p;
        }
        r[e] = f;
    },
    onDrag: function(e) {
        if (!this.isDragging) {
            return;
        }
        var t = this.lastDragPosition;
        this.onAxisDrag("x", e.deltaX);
        this.onAxisDrag("y", e.deltaY);
        this.scrollTo(t.x, t.y);
    },
    onDragEnd: function(e) {
        var t, i;
        if (!this.isDragging) {
            return;
        }
        this.dragEndTime = Ext.Date.now();
        this.onDrag(e);
        this.isDragging = false;
        t = this.getAnimationEasing("x");
        i = this.getAnimationEasing("y");
        if (t || i) {
            this.getTranslatable().animate(t, i);
        } else {
            this.onScrollEnd();
        }
    },
    getAnimationEasing: function(e) {
        if (!this.isAxisEnabled(e)) {
            return null;
        }
        var t = this.position[e], i = this.flickStartPosition[e], n = this.flickStartTime[e], r = this.getMinPosition()[e], s = this.getMaxPosition()[e], a = this.getMaxAbsoluteVelocity(), o = null, l = this.dragEndTime, u, c, f;
        if (t < r) {
            o = r;
        } else if (t > s) {
            o = s;
        }
        if (o !== null) {
            u = this.getBounceEasing()[e];
            u.setConfig({
                startTime: l,
                startValue: -t,
                endValue: -o
            });
            return u;
        }
        f = l - n;
        if (f === 0) {
            return null;
        }
        c = (t - i) / (l - n);
        if (c === 0) {
            return null;
        }
        if (c < -a) {
            c = -a;
        } else if (c > a) {
            c = a;
        }
        u = this.getMomentumEasing()[e];
        u.setConfig({
            startTime: l,
            startValue: -t,
            startVelocity: -c,
            minMomentumValue: -s,
            maxMomentumValue: 0
        });
        return u;
    },
    onAnimationFrame: function(e, t, i) {
        var n = this.position;
        n.x = -t;
        n.y = -i;
        this.fireEvent("scroll", this, n.x, n.y);
    },
    onAnimationEnd: function() {
        this.snapToBoundary();
        this.onScrollEnd();
    },
    stopAnimation: function() {
        this.getTranslatable().stopAnimation();
    },
    onScrollEnd: function() {
        var e = this.position;
        if (this.isTouching || !this.snapToSlot()) {
            this.fireEvent("scrollend", this, e.x, e.y);
        }
    },
    snapToSlot: function() {
        var e = this.getSnapPosition("x"), t = this.getSnapPosition("y"), i = this.getSlotSnapEasing();
        if (e !== null || t !== null) {
            this.scrollTo(e, t, {
                easingX: i.x,
                easingY: i.y
            });
            return true;
        }
        return false;
    },
    getSnapPosition: function(e) {
        var t = this.getSlotSnapSize()[e], i = null, n, r, s, a;
        if (t !== 0 && this.isAxisEnabled(e)) {
            n = this.position[e];
            r = this.getSlotSnapOffset()[e];
            s = this.getMaxPosition()[e];
            a = (n - r) % t;
            if (a !== 0 && n !== s) {
                if (Math.abs(a) > t / 2) {
                    i = Math.min(s, n + (a > 0 ? t - a : a - t));
                } else {
                    i = n - a;
                }
            }
        }
        return i;
    },
    snapToBoundary: function() {
        var e = this.position, t = this.getMinPosition(), i = this.getMaxPosition(), n = t.x, r = t.y, s = i.x, a = i.y, o = Math.round(e.x), l = Math.round(e.y);
        if (o < n) {
            o = n;
        } else if (o > s) {
            o = s;
        }
        if (l < r) {
            l = r;
        } else if (l > a) {
            l = a;
        }
        this.scrollTo(o, l);
    },
    destroy: function() {
        var e = this.getElement(), t = this.sizeMonitors;
        if (t) {
            t.element.destroy();
            t.container.destroy();
        }
        if (e && !e.isDestroyed) {
            e.removeCls(this.cls);
            this.getContainer().removeCls(this.containerCls);
        }
        Ext.destroy(this.getTranslatable());
        this.callParent(arguments);
    }
}, function() {
    this.override({
        constructor: function(e) {
            var t, i, n, r, s, a;
            if (!e) {
                e = {};
            }
            if (typeof e == "string") {
                e = {
                    direction: e
                };
            }
            if (arguments.length == 2) {
                Ext.Logger.deprecate("Passing element as the first argument is deprecated, pass it as the " + "'element' property of the config object instead");
                t = e;
                e = arguments[1];
                if (!e) {
                    e = {};
                }
                e.element = t;
            }
            if (e.hasOwnProperty("acceleration")) {
                i = e.acceleration;
                delete e.acceleration;
                Ext.Logger.deprecate("'acceleration' config is deprecated, set momentumEasing.momentum.acceleration and momentumEasing.bounce.acceleration configs instead");
                Ext.merge(e, {
                    momentumEasing: {
                        momentum: {
                            acceleration: i
                        },
                        bounce: {
                            acceleration: i
                        }
                    }
                });
            }
            if (e.hasOwnProperty("snap")) {
                e.slotSnapOffset = e.snap;
                Ext.Logger.deprecate("'snap' config is deprecated, please use the 'slotSnapOffset' config instead");
            }
            if (e.hasOwnProperty("friction")) {
                r = e.friction;
                delete e.friction;
                Ext.Logger.deprecate("'friction' config is deprecated, set momentumEasing.momentum.friction config instead");
                Ext.merge(e, {
                    momentumEasing: {
                        momentum: {
                            friction: r
                        }
                    }
                });
            }
            if (e.hasOwnProperty("springTension")) {
                s = e.springTension;
                delete e.springTension;
                Ext.Logger.deprecate("'springTension' config is deprecated, set momentumEasing.momentum.springTension config instead");
                Ext.merge(e, {
                    momentumEasing: {
                        momentum: {
                            springTension: s
                        }
                    }
                });
            }
            if (e.hasOwnProperty("minVelocityForAnimation")) {
                a = e.minVelocityForAnimation;
                delete e.minVelocityForAnimation;
                Ext.Logger.deprecate("'minVelocityForAnimation' config is deprecated, set momentumEasing.minVelocity config instead");
                Ext.merge(e, {
                    momentumEasing: {
                        minVelocity: a
                    }
                });
            }
            this.callOverridden(arguments);
        },
        scrollToAnimated: function(e, t, i) {
            Ext.Logger.deprecate("scrollToAnimated() is deprecated, please use `scrollTo()` and pass 'animation' as " + "the third argument instead");
            return this.scrollTo.apply(this, arguments);
        },
        scrollBy: function(e, t, i) {
            if (Ext.isObject(e)) {
                Ext.Logger.deprecate("calling `scrollBy()` with an object of `x` and `y` properties is no longer supported. " + "Please pass `x` and `y` values as two separate arguments instead");
                t = e.y;
                e = e.x;
            }
            return this.callOverridden([ e, t, i ]);
        },
        setOffset: function(e) {
            return this.scrollToAnimated(-e.x, -e.y);
        }
    });
});

Ext.define("Ext.scroll.indicator.Default", {
    extend: "Ext.scroll.indicator.Abstract",
    config: {
        cls: "default"
    },
    setOffset: function(e) {
        var t = this.getAxis(), i = this.element.dom.style;
        if (t === "x") {
            i.webkitTransform = "translate3d(" + e + "px, 0, 0)";
        } else {
            i.webkitTransform = "translate3d(0, " + e + "px, 0)";
        }
    },
    updateValue: function(e) {
        var t = this.barLength, i = this.gapLength, n = this.getLength(), r, s, a;
        if (e <= 0) {
            s = 0;
            this.updateLength(this.applyLength(n + e * t));
        } else if (e >= 1) {
            a = Math.round((e - 1) * t);
            r = this.applyLength(n - a);
            a = n - r;
            this.updateLength(r);
            s = i + a;
        } else {
            s = i * e;
        }
        this.setOffset(s);
    }
});

Ext.define("Ext.scroll.indicator.ScrollPosition", {
    extend: "Ext.scroll.indicator.Abstract",
    config: {
        cls: "scrollposition"
    },
    getElementConfig: function() {
        var e = this.callParent(arguments);
        e.children.unshift({
            className: "x-scroll-bar-stretcher"
        });
        return e;
    },
    updateValue: function(e) {
        if (this.gapLength === 0) {
            if (e > 1) {
                e = e - 1;
            }
            this.setOffset(this.barLength * e);
        } else {
            this.setOffset(this.gapLength * e);
        }
    },
    updateLength: function() {
        var e = this.barLength, t = this.barElement.dom, i = this.element;
        this.callParent(arguments);
        if (this.getAxis() === "x") {
            t.scrollLeft = e;
            i.setLeft(e);
        } else {
            t.scrollTop = e;
            i.setTop(e);
        }
    },
    setOffset: function(e) {
        var t = this.barLength, i = this.getMinLength(), n = this.barElement.dom;
        e = Math.min(t - i, Math.max(e, i - this.getLength()));
        e = t - e;
        if (this.getAxis() === "x") {
            n.scrollLeft = e;
        } else {
            n.scrollTop = e;
        }
    }
});

Ext.define("Ext.scroll.indicator.CssTransform", {
    extend: "Ext.scroll.indicator.Abstract",
    config: {
        cls: "csstransform"
    },
    getElementConfig: function() {
        var e = this.callParent();
        e.children[0].children = [ {
            reference: "startElement"
        }, {
            reference: "middleElement"
        }, {
            reference: "endElement"
        } ];
        return e;
    },
    refresh: function() {
        var e = this.getAxis(), t = this.startElement.dom, i = this.endElement.dom, n = this.middleElement, r, s;
        if (e === "x") {
            r = t.offsetWidth;
            s = i.offsetWidth;
            n.setLeft(r);
        } else {
            r = t.offsetHeight;
            s = i.offsetHeight;
            n.setTop(r);
        }
        this.startElementLength = r;
        this.endElementLength = s;
        this.callParent();
    },
    updateLength: function(e) {
        var t = this.getAxis(), i = this.endElement.dom.style, n = this.middleElement.dom.style, r = this.endElementLength, s = e - r, a = s - this.startElementLength;
        if (t === "x") {
            i.webkitTransform = "translate3d(" + s + "px, 0, 0)";
            n.webkitTransform = "translate3d(0, 0, 0) scaleX(" + a + ")";
        } else {
            i.webkitTransform = "translate3d(0, " + s + "px, 0)";
            n.webkitTransform = "translate3d(0, 0, 0) scaleY(" + a + ")";
        }
    },
    updateValue: function(e) {
        var t = this.barLength, i = this.gapLength, n = this.getLength(), r, s, a;
        if (e <= 0) {
            s = 0;
            this.updateLength(this.applyLength(n + e * t));
        } else if (e >= 1) {
            a = Math.round((e - 1) * t);
            r = this.applyLength(n - a);
            a = n - r;
            this.updateLength(r);
            s = i + a;
        } else {
            s = i * e;
        }
        this.setOffset(s);
    },
    setOffset: function(e) {
        var t = this.getAxis(), i = this.element.dom.style;
        e = Math.round(e);
        if (t === "x") {
            i.webkitTransform = "translate3d(" + e + "px, 0, 0)";
        } else {
            i.webkitTransform = "translate3d(0, " + e + "px, 0)";
        }
    }
});

Ext.define("Ext.scroll.indicator.Throttled", {
    extend: "Ext.scroll.indicator.Default",
    config: {
        cls: "throttled"
    },
    constructor: function() {
        this.callParent(arguments);
        this.updateLength = Ext.Function.createThrottled(this.updateLength, 75, this);
        this.setOffset = Ext.Function.createThrottled(this.setOffset, 50, this);
    },
    doSetHidden: function(e) {
        if (e) {
            this.setOffset(-1e4);
        } else {
            delete this.lastLength;
            delete this.lastOffset;
            this.updateValue(this.getValue());
        }
    },
    updateLength: function(e) {
        e = Math.round(e);
        if (this.lastLength === e || this.lastOffset === -1e4) {
            return;
        }
        this.lastLength = e;
        Ext.TaskQueue.requestWrite("doUpdateLength", this, [ e ]);
    },
    doUpdateLength: function(e) {
        if (!this.isDestroyed) {
            var t = this.getAxis(), i = this.element;
            if (t === "x") {
                i.setWidth(e);
            } else {
                i.setHeight(e);
            }
        }
    },
    setOffset: function(e) {
        e = Math.round(e);
        if (this.lastOffset === e || this.lastOffset === -1e4) {
            return;
        }
        this.lastOffset = e;
        Ext.TaskQueue.requestWrite("doSetOffset", this, [ e ]);
    },
    doSetOffset: function(e) {
        if (!this.isDestroyed) {
            var t = this.getAxis(), i = this.element.dom.style;
            if (t === "x") {
                i.webkitTransform = "translate3d(" + e + "px, 0, 0)";
            } else {
                i.webkitTransform = "translate3d(0, " + e + "px, 0)";
            }
        }
    }
});

Ext.define("Ext.scroll.Indicator", {
    requires: [ "Ext.scroll.indicator.Default", "Ext.scroll.indicator.ScrollPosition", "Ext.scroll.indicator.CssTransform", "Ext.scroll.indicator.Throttled" ],
    alternateClassName: "Ext.util.Indicator",
    constructor: function(e) {
        if (Ext.os.is.Android2 || Ext.os.is.Android3) {
            return new Ext.scroll.indicator.ScrollPosition(e);
        } else if (Ext.os.is.iOS || Ext.browser.is.ChromeMobile) {
            return new Ext.scroll.indicator.CssTransform(e);
        } else if (Ext.os.is.Android4) {
            return new Ext.scroll.indicator.Throttled(e);
        } else {
            return new Ext.scroll.indicator.Default(e);
        }
    }
});

Ext.define("Ext.scroll.View", {
    extend: "Ext.Evented",
    alternateClassName: "Ext.util.ScrollView",
    requires: [ "Ext.scroll.Scroller", "Ext.scroll.Indicator" ],
    config: {
        indicatorsUi: "dark",
        element: null,
        scroller: {},
        indicators: {
            x: {
                axis: "x"
            },
            y: {
                axis: "y"
            }
        },
        indicatorsHidingDelay: 100,
        cls: Ext.baseCSSPrefix + "scroll-view"
    },
    processConfig: function(e) {
        if (!e) {
            return null;
        }
        if (typeof e == "string") {
            e = {
                direction: e
            };
        }
        e = Ext.merge({}, e);
        var t = e.scroller, i;
        if (!t) {
            e.scroller = t = {};
        }
        for (i in e) {
            if (e.hasOwnProperty(i)) {
                if (!this.hasConfig(i)) {
                    t[i] = e[i];
                    delete e[i];
                }
            }
        }
        return e;
    },
    constructor: function(e) {
        e = this.processConfig(e);
        this.useIndicators = {
            x: true,
            y: true
        };
        this.doHideIndicators = Ext.Function.bind(this.doHideIndicators, this);
        this.initConfig(e);
    },
    setConfig: function(e) {
        return this.callParent([ this.processConfig(e) ]);
    },
    updateIndicatorsUi: function(e) {
        var t = this.getIndicators();
        t.x.setUi(e);
        t.y.setUi(e);
    },
    applyScroller: function(e, t) {
        return Ext.factory(e, Ext.scroll.Scroller, t);
    },
    applyIndicators: function(e, t) {
        var i = Ext.scroll.Indicator, n = this.useIndicators;
        if (!e) {
            e = {};
        }
        if (!e.x) {
            n.x = false;
            e.x = {};
        }
        if (!e.y) {
            n.y = false;
            e.y = {};
        }
        return {
            x: Ext.factory(e.x, i, t && t.x),
            y: Ext.factory(e.y, i, t && t.y)
        };
    },
    updateIndicators: function(e) {
        this.indicatorsGrid = Ext.Element.create({
            className: "x-scroll-bar-grid-wrapper",
            children: [ {
                className: "x-scroll-bar-grid",
                children: [ {
                    children: [ {}, {
                        children: [ e.y.barElement ]
                    } ]
                }, {
                    children: [ {
                        children: [ e.x.barElement ]
                    }, {} ]
                } ]
            } ]
        });
    },
    updateScroller: function(e) {
        e.on({
            scope: this,
            scrollstart: "onScrollStart",
            scroll: "onScroll",
            scrollend: "onScrollEnd",
            refresh: "refreshIndicators"
        });
    },
    isAxisEnabled: function(e) {
        return this.getScroller().isAxisEnabled(e) && this.useIndicators[e];
    },
    applyElement: function(e) {
        if (e) {
            return Ext.get(e);
        }
    },
    updateElement: function(e) {
        var t = e.getFirstChild().getFirstChild(), i = this.getScroller();
        e.addCls(this.getCls());
        e.insertFirst(this.indicatorsGrid);
        i.setElement(t);
        this.refreshIndicators();
        return this;
    },
    showIndicators: function() {
        var e = this.getIndicators();
        if (this.hasOwnProperty("indicatorsHidingTimer")) {
            clearTimeout(this.indicatorsHidingTimer);
            delete this.indicatorsHidingTimer;
        }
        if (this.isAxisEnabled("x")) {
            e.x.show();
        }
        if (this.isAxisEnabled("y")) {
            e.y.show();
        }
    },
    hideIndicators: function() {
        var e = this.getIndicatorsHidingDelay();
        if (e > 0) {
            this.indicatorsHidingTimer = setTimeout(this.doHideIndicators, e);
        } else {
            this.doHideIndicators();
        }
    },
    doHideIndicators: function() {
        var e = this.getIndicators();
        if (this.isAxisEnabled("x")) {
            e.x.hide();
        }
        if (this.isAxisEnabled("y")) {
            e.y.hide();
        }
    },
    onScrollStart: function() {
        this.onScroll.apply(this, arguments);
        this.showIndicators();
    },
    onScrollEnd: function() {
        this.hideIndicators();
    },
    onScroll: function(e, t, i) {
        this.setIndicatorValue("x", t);
        this.setIndicatorValue("y", i);
        if (this.isBenchmarking) {
            this.framesCount++;
        }
    },
    isBenchmarking: false,
    framesCount: 0,
    getCurrentFps: function() {
        var e = Date.now(), t;
        if (!this.isBenchmarking) {
            this.isBenchmarking = true;
            t = 0;
        } else {
            t = Math.round(this.framesCount * 1e3 / (e - this.framesCountStartTime));
        }
        this.framesCountStartTime = e;
        this.framesCount = 0;
        return t;
    },
    setIndicatorValue: function(e, t) {
        if (!this.isAxisEnabled(e)) {
            return this;
        }
        var i = this.getScroller(), n = i.getMaxPosition()[e], r = i.getContainerSize()[e], s;
        if (n === 0) {
            s = t / r;
            if (t >= 0) {
                s += 1;
            }
        } else {
            if (t > n) {
                s = 1 + (t - n) / r;
            } else if (t < 0) {
                s = t / r;
            } else {
                s = t / n;
            }
        }
        this.getIndicators()[e].setValue(s);
    },
    refreshIndicator: function(e) {
        if (!this.isAxisEnabled(e)) {
            return this;
        }
        var t = this.getScroller(), i = this.getIndicators()[e], n = t.getContainerSize()[e], r = t.getSize()[e], s = n / r;
        i.setRatio(s);
        i.refresh();
    },
    refresh: function() {
        return this.getScroller().refresh();
    },
    refreshIndicators: function() {
        var e = this.getIndicators();
        e.x.setActive(this.isAxisEnabled("x"));
        e.y.setActive(this.isAxisEnabled("y"));
        this.refreshIndicator("x");
        this.refreshIndicator("y");
    },
    destroy: function() {
        var e = this.getElement(), t = this.getIndicators();
        Ext.destroy(this.getScroller(), this.indicatorsGrid);
        if (this.hasOwnProperty("indicatorsHidingTimer")) {
            clearTimeout(this.indicatorsHidingTimer);
            delete this.indicatorsHidingTimer;
        }
        if (e && !e.isDestroyed) {
            e.removeCls(this.getCls());
        }
        t.x.destroy();
        t.y.destroy();
        delete this.indicatorsGrid;
        this.callParent(arguments);
    }
});

Ext.define("Ext.behavior.Scrollable", {
    extend: "Ext.behavior.Behavior",
    requires: [ "Ext.scroll.View" ],
    constructor: function() {
        this.listeners = {
            painted: "onComponentPainted",
            scope: this
        };
        this.callParent(arguments);
    },
    onComponentPainted: function() {
        this.scrollView.refresh();
    },
    setConfig: function(e) {
        var t = this.scrollView, i = this.component, n;
        if (e) {
            if (!t) {
                this.scrollView = t = new Ext.scroll.View(e);
                t.on("destroy", "onScrollViewDestroy", this);
                i.setUseBodyElement(true);
                this.scrollerElement = n = i.innerElement;
                this.scrollContainer = n.wrap();
                t.setElement(i.bodyElement);
                if (i.isPainted()) {
                    this.onComponentPainted(i);
                }
                i.on(this.listeners);
            } else if (Ext.isString(e) || Ext.isObject(e)) {
                t.setConfig(e);
            }
        } else if (t) {
            t.destroy();
        }
        return this;
    },
    getScrollView: function() {
        return this.scrollView;
    },
    onScrollViewDestroy: function() {
        var e = this.component, t = this.scrollerElement;
        if (!t.isDestroyed) {
            this.scrollerElement.unwrap();
        }
        this.scrollContainer.destroy();
        if (!e.isDestroyed) {
            e.un(this.listeners);
        }
        delete this.scrollerElement;
        delete this.scrollView;
        delete this.scrollContainer;
    },
    onComponentDestroy: function() {
        var e = this.scrollView;
        if (e) {
            e.destroy();
        }
    }
});

Ext.define("Ext.Container", {
    extend: "Ext.Component",
    alternateClassName: "Ext.lib.Container",
    requires: [ "Ext.layout.*", "Ext.ItemCollection", "Ext.behavior.Scrollable", "Ext.Mask" ],
    xtype: "container",
    eventedConfig: {
        activeItem: 0,
        scrollable: null
    },
    config: {
        layout: null,
        control: {},
        defaults: null,
        items: null,
        autoDestroy: true,
        defaultType: null,
        useBodyElement: null,
        masked: null,
        modal: null,
        hideOnMaskTap: null
    },
    isContainer: true,
    constructor: function(e) {
        var t = this;
        t._items = t.items = new Ext.ItemCollection();
        t.innerItems = [];
        t.onItemAdd = t.onFirstItemAdd;
        t.callParent(arguments);
    },
    getElementConfig: function() {
        return {
            reference: "element",
            classList: [ "x-container", "x-unsized" ],
            children: [ {
                reference: "innerElement",
                className: "x-inner"
            } ]
        };
    },
    applyMasked: function(e) {
        var t = true, i;
        if (e === false) {
            e = true;
            t = false;
        }
        i = Ext.factory(e, Ext.Mask, this.getMasked());
        if (i) {
            this.add(i);
            i.setHidden(!t);
        }
        return i;
    },
    mask: function(e) {
        this.setMasked(e || true);
    },
    unmask: function() {
        this.setMasked(false);
    },
    setParent: function(e) {
        this.callSuper(arguments);
        if (e) {
            var t = this.getModal();
            if (t) {
                e.insertBefore(t, this);
                t.setZIndex(this.getZIndex() - 1);
            }
        }
    },
    applyModal: function(e, t) {
        var i = true;
        if (e === false) {
            e = true;
            i = false;
        }
        t = Ext.factory(e, Ext.Mask, t);
        if (t) {
            t.setVisibility(i);
        }
        return t;
    },
    updateModal: function(e) {
        var t = this.getParent();
        if (t) {
            if (e) {
                t.insertBefore(e, this);
                e.setZIndex(this.getZIndex() - 1);
            } else {
                t.remove(e);
            }
        }
    },
    updateHideOnMaskTap: function(e) {
        var t = this.getModal();
        if (t) {
            t[e ? "on" : "un"].call(t, "tap", "hide", this);
        }
    },
    updateZIndex: function(e) {
        var t = this.getModal();
        this.callParent(arguments);
        if (t) {
            t.setZIndex(e - 1);
        }
    },
    updateBaseCls: function(e, t) {
        var i = this, n = i.getUi();
        if (e) {
            this.element.addCls(e);
            this.innerElement.addCls(e, null, "inner");
            if (n) {
                this.element.addCls(e, null, n);
            }
        }
        if (t) {
            this.element.removeCls(t);
            this.innerElement.removeCls(e, null, "inner");
            if (n) {
                this.element.removeCls(t, null, n);
            }
        }
    },
    updateUseBodyElement: function(e) {
        if (e) {
            this.link("bodyElement", this.innerElement.wrap({
                cls: "x-body"
            }));
        }
    },
    applyItems: function(e, t) {
        if (e) {
            var i = this;
            i.getDefaultType();
            i.getDefaults();
            if (i.initialized && t.length > 0) {
                i.removeAll();
            }
            i.add(e);
            if (i.initialized) {
                var n = i.initialConfig.activeItem || i.config.activeItem || 0;
                i.setActiveItem(n);
            }
        }
    },
    applyControl: function(e) {
        var t, i, n, r;
        for (t in e) {
            r = e[t];
            for (i in r) {
                n = r[i];
                if (Ext.isObject(n)) {
                    n.delegate = t;
                }
            }
            r.delegate = t;
            this.addListener(r);
        }
        return e;
    },
    onFirstItemAdd: function() {
        delete this.onItemAdd;
        if (this.innerHtmlElement && !this.getHtml()) {
            this.innerHtmlElement.destroy();
            delete this.innerHtmlElement;
        }
        this.on("innerstatechange", "onItemInnerStateChange", this, {
            delegate: "> component"
        });
        return this.onItemAdd.apply(this, arguments);
    },
    updateLayout: function(e, t) {
        if (t && t.isLayout) {
            Ext.Logger.error("Replacing a layout after one has already been initialized is not currently supported.");
        }
    },
    getLayout: function() {
        var e = this.layout;
        if (!e) {
            e = this.link("_layout", this.link("layout", Ext.factory(this._layout || "default", Ext.layout.Default, null, "layout")));
            e.setContainer(this);
        }
        return e;
    },
    updateDefaultType: function(e) {
        this.defaultItemClass = Ext.ClassManager.getByAlias("widget." + e);
        if (!this.defaultItemClass) {
            Ext.Logger.error("Invalid defaultType of: '" + e + "', must be a valid component xtype");
        }
    },
    applyDefaults: function(e) {
        if (e) {
            this.factoryItem = this.factoryItemWithDefaults;
            return e;
        }
    },
    factoryItem: function(e) {
        if (!e) {
            Ext.Logger.error("Invalid item given: " + e + ", must be either the config object to factory a new item, " + "or an existing component instance");
        }
        return Ext.factory(e, this.defaultItemClass);
    },
    factoryItemWithDefaults: function(e) {
        if (!e) {
            Ext.Logger.error("Invalid item given: " + e + ", must be either the config object to factory a new item, " + "or an existing component instance");
        }
        var t = this, i = t.getDefaults(), n;
        if (!i) {
            return Ext.factory(e, t.defaultItemClass);
        }
        if (e.isComponent) {
            n = e;
            if (i && e.isInnerItem() && !t.has(n)) {
                n.setConfig(i, true);
            }
        } else {
            if (i && !e.ignoreDefaults) {
                if (!(e.hasOwnProperty("left") && e.hasOwnProperty("right") && e.hasOwnProperty("top") && e.hasOwnProperty("bottom") && e.hasOwnProperty("docked") && e.hasOwnProperty("centered"))) {
                    e = Ext.mergeIf({}, e, i);
                }
            }
            n = Ext.factory(e, t.defaultItemClass);
        }
        return n;
    },
    add: function(e) {
        var t = this, i, n, r, s;
        e = Ext.Array.from(e);
        n = e.length;
        for (i = 0; i < n; i++) {
            r = t.factoryItem(e[i]);
            this.doAdd(r);
            if (!s && !this.getActiveItem() && this.innerItems.length > 0 && r.isInnerItem()) {
                s = r;
            }
        }
        if (s) {
            this.setActiveItem(s);
        }
        return r;
    },
    doAdd: function(e) {
        var t = this, i = t.getItems(), n;
        if (!i.has(e)) {
            n = i.length;
            i.add(e);
            if (e.isInnerItem()) {
                t.insertInner(e);
            }
            e.setParent(t);
            t.onItemAdd(e, n);
        }
    },
    remove: function(e, t) {
        var i = this, n = i.indexOf(e), r = i.getInnerItems();
        if (t === undefined) {
            t = i.getAutoDestroy();
        }
        if (n !== -1) {
            if (!i.removingAll && r.length > 1 && e === i.getActiveItem()) {
                i.on({
                    activeitemchange: "doRemove",
                    scope: i,
                    single: true,
                    order: "after",
                    args: [ e, n, t ]
                });
                i.doResetActiveItem(r.indexOf(e));
            } else {
                i.doRemove(e, n, t);
                if (r.length === 0) {
                    i.setActiveItem(null);
                }
            }
        }
        return i;
    },
    doResetActiveItem: function(e) {
        if (e === 0) {
            this.setActiveItem(1);
        } else {
            this.setActiveItem(0);
        }
    },
    doRemove: function(e, t, i) {
        var n = this;
        n.items.remove(e);
        if (e.isInnerItem()) {
            n.removeInner(e);
        }
        n.onItemRemove(e, t, i);
        e.setParent(null);
        if (i) {
            e.destroy();
        }
    },
    removeAll: function(e, t) {
        var i = this.items, n = i.length, r = 0, s;
        if (e === undefined) {
            e = this.getAutoDestroy();
        }
        t = Boolean(t);
        this.removingAll = true;
        for (;r < n; r++) {
            s = i.getAt(r);
            if (s && (t || s.isInnerItem())) {
                this.doRemove(s, r, e);
                r--;
                n--;
            }
        }
        this.setActiveItem(null);
        this.removingAll = false;
        return this;
    },
    getAt: function(e) {
        return this.items.getAt(e);
    },
    getInnerAt: function(e) {
        return this.innerItems[e];
    },
    removeAt: function(e) {
        var t = this.getAt(e);
        if (t) {
            this.remove(t);
        }
        return this;
    },
    removeInnerAt: function(e) {
        var t = this.getInnerItems()[e];
        if (t) {
            this.remove(t);
        }
        return this;
    },
    has: function(e) {
        return this.getItems().indexOf(e) != -1;
    },
    hasInnerItem: function(e) {
        return this.innerItems.indexOf(e) != -1;
    },
    indexOf: function(e) {
        return this.getItems().indexOf(e);
    },
    innerIndexOf: function(e) {
        return this.innerItems.indexOf(e);
    },
    insertInner: function(e, t) {
        var i = this.getItems().items, n = this.innerItems, r = n.indexOf(e), s = -1, a;
        if (r !== -1) {
            n.splice(r, 1);
        }
        if (typeof t == "number") {
            do {
                a = i[++t];
            } while (a && !a.isInnerItem());
            if (a) {
                s = n.indexOf(a);
                n.splice(s, 0, e);
            }
        }
        if (s === -1) {
            n.push(e);
            s = n.length - 1;
        }
        if (r !== -1) {
            this.onInnerItemMove(e, s, r);
        }
        return this;
    },
    onInnerItemMove: Ext.emptyFn,
    removeInner: function(e) {
        Ext.Array.remove(this.innerItems, e);
        return this;
    },
    insert: function(e, t) {
        var i = this, n;
        if (Ext.isArray(t)) {
            for (n = t.length - 1; n >= 0; n--) {
                i.insert(e, t[n]);
            }
            return i;
        }
        t = this.factoryItem(t);
        this.doInsert(e, t);
        return t;
    },
    doInsert: function(e, t) {
        var i = this, n = i.items, r = n.length, s, a;
        a = t.isInnerItem();
        if (e > r) {
            e = r;
        }
        if (n[e - 1] === t) {
            return i;
        }
        s = i.indexOf(t);
        if (s !== -1) {
            if (s < e) {
                e -= 1;
            }
            n.removeAt(s);
        }
        n.insert(e, t);
        if (s === -1) {
            t.setParent(i);
        }
        if (a) {
            i.insertInner(t, e);
        }
        if (s !== -1) {
            i.onItemMove(t, e, s);
        } else {
            i.onItemAdd(t, e);
        }
    },
    insertFirst: function(e) {
        return this.insert(0, e);
    },
    insertLast: function(e) {
        return this.insert(this.getItems().length, e);
    },
    insertBefore: function(e, t) {
        var i = this.indexOf(t);
        if (i !== -1) {
            this.insert(i, e);
        }
        return this;
    },
    insertAfter: function(e, t) {
        var i = this.indexOf(t);
        if (i !== -1) {
            this.insert(i + 1, e);
        }
        return this;
    },
    onItemAdd: function(e, t) {
        this.doItemLayoutAdd(e, t);
        if (this.initialized) {
            this.fireEvent("add", this, e, t);
        }
    },
    doItemLayoutAdd: function(e, t) {
        var i = this.getLayout();
        if (this.isRendered() && e.setRendered(true)) {
            e.fireAction("renderedchange", [ this, e, true ], "onItemAdd", i, {
                args: [ e, t ]
            });
        } else {
            i.onItemAdd(e, t);
        }
    },
    onItemRemove: function(e, t) {
        this.doItemLayoutRemove(e, t);
        this.fireEvent("remove", this, e, t);
    },
    doItemLayoutRemove: function(e, t) {
        var i = this.getLayout();
        if (this.isRendered() && e.setRendered(false)) {
            e.fireAction("renderedchange", [ this, e, false ], "onItemRemove", i, {
                args: [ e, t, undefined ]
            });
        } else {
            i.onItemRemove(e, t);
        }
    },
    onItemMove: function(e, t, i) {
        if (e.isDocked()) {
            e.setDocked(null);
        }
        this.doItemLayoutMove(e, t, i);
        this.fireEvent("move", this, e, t, i);
    },
    doItemLayoutMove: function(e, t, i) {
        this.getLayout().onItemMove(e, t, i);
    },
    onItemInnerStateChange: function(e, t) {
        var i = this.getLayout();
        if (t) {
            this.insertInner(e, this.items.indexOf(e));
        } else {
            this.removeInner(e);
        }
        i.onItemInnerStateChange.apply(i, arguments);
    },
    getInnerItems: function() {
        return this.innerItems;
    },
    getDockedItems: function() {
        var e = this.getItems().items, t = [], i = e.length, n, r;
        for (r = 0; r < i; r++) {
            n = e[r];
            if (n.isDocked()) {
                t.push(n);
            }
        }
        return t;
    },
    applyActiveItem: function(e, t) {
        var i = this.getInnerItems();
        this.getItems();
        if (!e && i.length === 0) {
            return 0;
        } else if (typeof e == "number") {
            e = Math.max(0, Math.min(e, i.length - 1));
            e = i[e];
            if (e) {
                return e;
            } else if (t) {
                return null;
            }
        } else if (e) {
            var n;
            if (typeof e == "string") {
                n = this.child(e);
                e = {
                    xtype: e
                };
            }
            if (!n || !n.isComponent) {
                n = this.factoryItem(e);
            }
            this.pendingActiveItem = n;
            if (!n.isInnerItem()) {
                Ext.Logger.error("Setting activeItem to be a non-inner item");
            }
            if (!this.has(n)) {
                this.add(n);
            }
            return n;
        }
    },
    animateActiveItem: function(e, t) {
        var i = this.getLayout(), n;
        if (this.activeItemAnimation) {
            this.activeItemAnimation.destroy();
        }
        this.activeItemAnimation = t = new Ext.fx.layout.Card(t);
        if (t && i.isCard) {
            t.setLayout(i);
            n = i.getAnimation();
            if (n) {
                n.disable();
                t.on("animationend", function() {
                    n.enable();
                    t.destroy();
                }, this);
            }
        }
        return this.setActiveItem(e);
    },
    doSetActiveItem: function(e, t) {
        delete this.pendingActiveItem;
        if (t) {
            t.fireEvent("deactivate", t, this, e);
        }
        if (e) {
            e.fireEvent("activate", e, this, t);
        }
    },
    doSetHidden: function(e) {
        var t = this.getModal();
        if (t) {
            t.setHidden(e);
        }
        this.callSuper(arguments);
    },
    setRendered: function(e) {
        if (this.callParent(arguments)) {
            var t = this.items.items, i, n;
            for (i = 0, n = t.length; i < n; i++) {
                t[i].setRendered(e);
            }
            return true;
        }
        return false;
    },
    getScrollableBehavior: function() {
        var e = this.scrollableBehavior;
        if (!e) {
            e = this.scrollableBehavior = new Ext.behavior.Scrollable(this);
        }
        return e;
    },
    applyScrollable: function(e) {
        if (typeof e === "boolean") {
            if (e === false && !this.heightLayoutSized) {
                Ext.Logger.warn("This container is set to scrollable: false but has no specified height. " + "You may need to set the container to scrollable: null or provide a height.", this);
            }
            this.getScrollableBehavior().setConfig({
                disabled: !e
            });
        } else if (e && !e.isObservable) {
            this.getScrollableBehavior().setConfig(e);
        }
        return e;
    },
    doSetScrollable: function() {},
    getScrollable: function() {
        return this.getScrollableBehavior().getScrollView();
    },
    getRefItems: function(e) {
        var t = this.getItems().items.slice(), i = t.length, n, r;
        if (e) {
            for (n = 0; n < i; n++) {
                r = t[n];
                if (r.getRefItems) {
                    t = t.concat(r.getRefItems(true));
                }
            }
        }
        return t;
    },
    getComponent: function(e) {
        if (Ext.isObject(e)) {
            e = e.getItemId();
        }
        return this.getItems().get(e);
    },
    getDockedComponent: function(e) {
        if (Ext.isObject(e)) {
            e = e.getItemId();
        }
        var t = this.getDockedItems(), i = t.length, n, r;
        if (Ext.isNumber(e)) {
            return t[e];
        }
        for (r = 0; r < i; r++) {
            n = t[r];
            if (n.id == e) {
                return n;
            }
        }
        return false;
    },
    query: function(e) {
        return Ext.ComponentQuery.query(e, this);
    },
    child: function(e) {
        return this.query("> " + e)[0] || null;
    },
    down: function(e) {
        return this.query(e)[0] || null;
    },
    onClassExtended: function(e, t) {
        if ("onAdd" in t || "onRemove" in t) {
            throw new Error("[" + e.$className + "] 'onAdd()' and 'onRemove()' methods " + "no longer exist in Ext.Container, please use 'onItemAdd()' " + "and 'onItemRemove()' instead }");
        }
    },
    destroy: function() {
        var e = this, t = e.getModal();
        if (t) {
            t.destroy();
        }
        e.removeAll(true, true);
        e.unlink("_scrollable");
        Ext.destroy(e.items);
        e.callSuper();
    }
}, function() {
    this.addMember("defaultItemClass", this);
    Ext.deprecateClassMethod(this, "addAll", "add");
    Ext.deprecateClassMethod(this, "removeDocked", "remove");
    this.override({
        constructor: function(e) {
            e = e || {};
            var t = e.dockedItems, i, n, r;
            if (e.scroll) {
                Ext.Logger.deprecate("'scroll' config is deprecated, please use 'scrollable' instead.", this);
                e.scrollable = e.scroll;
                delete e.scroll;
            }
            this.callOverridden(arguments);
            if (t) {
                Ext.Logger.deprecate("'dockedItems' config is deprecated, please add all docked items inside the 'items' config with a 'docked' property indicating the docking position instead, i.e { /*...*/ docked: 'top' /*...*/ }");
                t = Ext.Array.from(t);
                for (i = 0, n = t.length; i < n; i++) {
                    r = t[i];
                    if ("dock" in r) {
                        Ext.Logger.deprecate("'dock' config for docked items is deprecated, please use 'docked' instead");
                        r.docked = r.dock;
                    }
                }
                this.add(t);
            }
        },
        add: function() {
            var e = arguments;
            if (e.length > 1) {
                if (typeof e[0] == "number") {
                    Ext.Logger.deprecate("add(index, item) method signature is deprecated, please use insert(index, item) instead");
                    return this.insert(e[0], e[1]);
                }
                Ext.Logger.deprecate("Passing items as multiple arguments is deprecated, please use one single array of items instead");
                e = [ Array.prototype.slice.call(e) ];
            }
            return this.callOverridden(e);
        },
        doAdd: function(e) {
            var t = e.getDocked(), i = e.overlay, n;
            if (i && t) {
                Ext.Logger.deprecate("'overlay' config is deprecated on docked items, please set the top/left/right/bottom configurations instead.", this);
                if (t == "top") {
                    n = {
                        top: 0,
                        bottom: "auto",
                        left: 0,
                        right: 0
                    };
                } else if (t == "bottom") {
                    n = {
                        top: null,
                        bottom: 0,
                        left: 0,
                        right: 0
                    };
                }
                if (n) {
                    e.setDocked(false);
                    e.setTop(n.top);
                    e.setBottom(n.bottom);
                    e.setLeft(n.left);
                    e.setRight(n.right);
                }
            }
            return this.callOverridden(arguments);
        },
        applyDefaults: function(e) {
            if (typeof e == "function") {
                Ext.Logger.deprecate("Passing a function as 'defaults' is deprecated. To add custom logics when " + "'defaults' is applied to each item, have your own factoryItem() method in your sub-class instead");
            }
            return this.callOverridden(arguments);
        },
        factoryItemWithDefaults: function(e) {
            var t = this.getDefaults(), i, n;
            if (typeof t == "function") {
                i = t.call(this, e);
            }
            if (typeof e == "string") {
                Ext.Logger.deprecate("Passing a string id of item ('" + e + "') is deprecated, please pass a reference to that item instead");
                e = Ext.getCmp(e);
            }
            if (i) {
                this._defaults = i;
            }
            n = this.callParent([ e ]);
            if (i) {
                this._defaults = t;
            }
            return n;
        },
        applyMasked: function(e) {
            if (Ext.isObject(e) && !e.isInstance && "message" in e && !("xtype" in e) && !("xclass" in e)) {
                e.xtype = "loadmask";
                Ext.Logger.deprecate("Using a 'message' config without specify an 'xtype' or 'xclass' will no longer implicitly set 'xtype' to 'loadmask'. Please set that explicitly.");
            }
            return this.callOverridden(arguments);
        }
    });
    Ext.deprecateClassMethod(this, "setMask", "setMasked");
});

Ext.define("Ext.viewport.Default", {
    extend: "Ext.Container",
    xtype: "viewport",
    PORTRAIT: "portrait",
    LANDSCAPE: "landscape",
    requires: [ "Ext.LoadMask", "Ext.layout.Card" ],
    config: {
        autoMaximize: false,
        autoBlurInput: true,
        preventPanning: true,
        preventZooming: false,
        autoRender: true,
        layout: "card",
        width: "100%",
        height: "100%",
        useBodyElement: true
    },
    isReady: false,
    isViewport: true,
    isMaximizing: false,
    id: "ext-viewport",
    isInputRegex: /^(input|textarea|select|a)$/i,
    focusedElement: null,
    fullscreenItemCls: Ext.baseCSSPrefix + "fullscreen",
    constructor: function(e) {
        var t = Ext.Function.bind;
        this.doPreventPanning = t(this.doPreventPanning, this);
        this.doPreventZooming = t(this.doPreventZooming, this);
        this.doBlurInput = t(this.doBlurInput, this);
        this.maximizeOnEvents = [ "ready", "orientationchange" ];
        this.orientation = this.determineOrientation();
        this.windowWidth = this.getWindowWidth();
        this.windowHeight = this.getWindowHeight();
        this.windowOuterHeight = this.getWindowOuterHeight();
        if (!this.stretchHeights) {
            this.stretchHeights = {};
        }
        this.callParent([ e ]);
        if (!Ext.os.is.Android || Ext.browser.name == "ChromeMobile") {
            if (this.supportsOrientation()) {
                this.addWindowListener("orientationchange", t(this.onOrientationChange, this));
            } else {
                this.addWindowListener("resize", t(this.onResize, this));
            }
        }
        document.addEventListener("focus", t(this.onElementFocus, this), true);
        document.addEventListener("blur", t(this.onElementBlur, this), true);
        Ext.onDocumentReady(this.onDomReady, this);
        this.on("ready", this.onReady, this, {
            single: true
        });
        this.getEventDispatcher().addListener("component", "*", "fullscreen", "onItemFullscreenChange", this);
        return this;
    },
    onDomReady: function() {
        this.isReady = true;
        this.updateSize();
        this.fireEvent("ready", this);
    },
    onReady: function() {
        if (this.getAutoRender()) {
            this.render();
        }
    },
    onElementFocus: function(e) {
        this.focusedElement = e.target;
    },
    onElementBlur: function() {
        this.focusedElement = null;
    },
    render: function() {
        if (!this.rendered) {
            var e = Ext.getBody(), t = Ext.baseCSSPrefix, i = [], n = Ext.os, r = n.name.toLowerCase(), s = Ext.browser.name.toLowerCase(), a = n.version.getMajor(), o = this.getOrientation();
            this.renderTo(e);
            i.push(t + n.deviceType.toLowerCase());
            if (n.is.iPad) {
                i.push(t + "ipad");
            }
            i.push(t + r);
            i.push(t + s);
            if (a) {
                i.push(t + r + "-" + a);
            }
            if (n.is.BlackBerry) {
                i.push(t + "bb");
            }
            if (Ext.browser.is.Standalone) {
                i.push(t + "standalone");
            }
            i.push(t + o);
            e.addCls(i);
        }
    },
    applyAutoBlurInput: function(e) {
        var t = Ext.feature.has.Touch ? "touchstart" : "mousedown";
        if (e) {
            this.addWindowListener(t, this.doBlurInput, false);
        } else {
            this.removeWindowListener(t, this.doBlurInput, false);
        }
        return e;
    },
    applyAutoMaximize: function(e) {
        if (Ext.browser.is.WebView) {
            e = false;
        }
        if (e) {
            this.on("ready", "doAutoMaximizeOnReady", this, {
                single: true
            });
            this.on("orientationchange", "doAutoMaximizeOnOrientationChange", this);
        } else {
            this.un("ready", "doAutoMaximizeOnReady", this);
            this.un("orientationchange", "doAutoMaximizeOnOrientationChange", this);
        }
        return e;
    },
    applyPreventPanning: function(e) {
        if (e) {
            this.addWindowListener("touchmove", this.doPreventPanning, false);
        } else {
            this.removeWindowListener("touchmove", this.doPreventPanning, false);
        }
        return e;
    },
    applyPreventZooming: function(e) {
        var t = Ext.feature.has.Touch ? "touchstart" : "mousedown";
        if (e) {
            this.addWindowListener(t, this.doPreventZooming, false);
        } else {
            this.removeWindowListener(t, this.doPreventZooming, false);
        }
        return e;
    },
    doAutoMaximizeOnReady: function() {
        var e = arguments[arguments.length - 1];
        e.pause();
        this.isMaximizing = true;
        this.on("maximize", function() {
            this.isMaximizing = false;
            this.updateSize();
            e.resume();
            this.fireEvent("ready", this);
        }, this, {
            single: true
        });
        this.maximize();
    },
    doAutoMaximizeOnOrientationChange: function() {
        var e = arguments[arguments.length - 1], t = e.firingArguments;
        e.pause();
        this.isMaximizing = true;
        this.on("maximize", function() {
            this.isMaximizing = false;
            this.updateSize();
            t[2] = this.windowWidth;
            t[3] = this.windowHeight;
            e.resume();
        }, this, {
            single: true
        });
        this.maximize();
    },
    doBlurInput: function(e) {
        var t = e.target, i = this.focusedElement;
        if (i && !this.isInputRegex.test(t.tagName)) {
            delete this.focusedElement;
            i.blur();
        }
    },
    doPreventPanning: function(e) {
        e.preventDefault();
    },
    doPreventZooming: function(e) {
        if ("button" in e && e.button !== 0) {
            return;
        }
        var t = e.target;
        if (t && t.nodeType === 1 && !this.isInputRegex.test(t.tagName)) {
            e.preventDefault();
        }
    },
    addWindowListener: function(e, t, i) {
        window.addEventListener(e, t, Boolean(i));
    },
    removeWindowListener: function(e, t, i) {
        window.removeEventListener(e, t, Boolean(i));
    },
    doAddListener: function(e, t, i, n) {
        if (e === "ready" && this.isReady && !this.isMaximizing) {
            t.call(i);
            return this;
        }
        return this.callSuper(arguments);
    },
    supportsOrientation: function() {
        return Ext.feature.has.Orientation;
    },
    onResize: function() {
        var e = this.windowWidth, t = this.windowHeight, i = this.getWindowWidth(), n = this.getWindowHeight(), r = this.getOrientation(), s = this.determineOrientation();
        if (e !== i && t !== n && r !== s) {
            this.fireOrientationChangeEvent(s, r);
        }
    },
    onOrientationChange: function() {
        var e = this.getOrientation(), t = this.determineOrientation();
        if (t !== e) {
            this.fireOrientationChangeEvent(t, e);
        }
    },
    fireOrientationChangeEvent: function(e, t) {
        var i = Ext.baseCSSPrefix;
        Ext.getBody().replaceCls(i + t, i + e);
        this.orientation = e;
        this.updateSize();
        this.fireEvent("orientationchange", this, e, this.windowWidth, this.windowHeight);
    },
    updateSize: function(e, t) {
        this.windowWidth = e !== undefined ? e : this.getWindowWidth();
        this.windowHeight = t !== undefined ? t : this.getWindowHeight();
        return this;
    },
    waitUntil: function(e, t, i, n, r) {
        if (!n) {
            n = 50;
        }
        if (!r) {
            r = 2e3;
        }
        var s = this, a = 0;
        setTimeout(function o() {
            a += n;
            if (e.call(s) === true) {
                if (t) {
                    t.call(s);
                }
            } else {
                if (a >= r) {
                    if (i) {
                        i.call(s);
                    }
                } else {
                    setTimeout(o, n);
                }
            }
        }, n);
    },
    maximize: function() {
        this.fireMaximizeEvent();
    },
    fireMaximizeEvent: function() {
        this.updateSize();
        this.fireEvent("maximize", this);
    },
    doSetHeight: function(e) {
        Ext.getBody().setHeight(e);
        this.callParent(arguments);
    },
    doSetWidth: function(e) {
        Ext.getBody().setWidth(e);
        this.callParent(arguments);
    },
    scrollToTop: function() {
        window.scrollTo(0, -1);
    },
    getWindowWidth: function() {
        return window.innerWidth;
    },
    getWindowHeight: function() {
        return window.innerHeight;
    },
    getWindowOuterHeight: function() {
        return window.outerHeight;
    },
    getWindowOrientation: function() {
        return window.orientation;
    },
    getOrientation: function() {
        return this.orientation;
    },
    getSize: function() {
        return {
            width: this.windowWidth,
            height: this.windowHeight
        };
    },
    determineOrientation: function() {
        var e = this.PORTRAIT, t = this.LANDSCAPE;
        if (this.supportsOrientation()) {
            if (this.getWindowOrientation() % 180 === 0) {
                return e;
            }
            return t;
        } else {
            if (this.getWindowHeight() >= this.getWindowWidth()) {
                return e;
            }
            return t;
        }
    },
    onItemFullscreenChange: function(e) {
        e.addCls(this.fullscreenItemCls);
        this.add(e);
    }
});

Ext.define("Ext.viewport.Ios", {
    extend: "Ext.viewport.Default",
    isFullscreen: function() {
        return this.isHomeScreen();
    },
    isHomeScreen: function() {
        return window.navigator.standalone === true;
    },
    constructor: function() {
        this.callParent(arguments);
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            this.addWindowListener("touchstart", Ext.Function.bind(this.onTouchStart, this));
        }
    },
    maximize: function() {
        if (this.isFullscreen()) {
            return this.callParent();
        }
        var e = this.stretchHeights, t = this.orientation, i = this.getWindowHeight(), n = e[t];
        if (window.scrollY > 0) {
            this.scrollToTop();
            if (!n) {
                e[t] = n = this.getWindowHeight();
            }
            this.setHeight(n);
            this.fireMaximizeEvent();
        } else {
            if (!n) {
                n = this.getScreenHeight();
            }
            this.setHeight(n);
            this.waitUntil(function() {
                this.scrollToTop();
                return i !== this.getWindowHeight();
            }, function() {
                if (!e[t]) {
                    n = e[t] = this.getWindowHeight();
                    this.setHeight(n);
                }
                this.fireMaximizeEvent();
            }, function() {
                Ext.Logger.error("Timeout waiting for window.innerHeight to change", this);
                n = e[t] = this.getWindowHeight();
                this.setHeight(n);
                this.fireMaximizeEvent();
            }, 50, 1e3);
        }
    },
    getScreenHeight: function() {
        return window.screen[this.orientation === this.PORTRAIT ? "height" : "width"];
    },
    onElementFocus: function() {
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            clearTimeout(this.scrollToTopTimer);
        }
        this.callParent(arguments);
    },
    onElementBlur: function() {
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            this.scrollToTopTimer = setTimeout(this.scrollToTop, 500);
        }
        this.callParent(arguments);
    },
    onTouchStart: function() {
        if (this.focusedElement === null) {
            this.scrollToTop();
        }
    },
    scrollToTop: function() {
        window.scrollTo(0, 0);
    }
}, function() {
    if (!Ext.os.is.iOS) {
        return;
    }
    if (Ext.os.version.lt("3.2")) {
        this.override({
            constructor: function() {
                var e = this.stretchHeights = {};
                e[this.PORTRAIT] = 416;
                e[this.LANDSCAPE] = 268;
                return this.callOverridden(arguments);
            }
        });
    }
    if (Ext.os.version.lt("5")) {
        this.override({
            fieldMaskClsTest: "-field-mask",
            doPreventZooming: function(e) {
                var t = e.target;
                if (t && t.nodeType === 1 && !this.isInputRegex.test(t.tagName) && t.className.indexOf(this.fieldMaskClsTest) == -1) {
                    e.preventDefault();
                }
            }
        });
    }
    if (Ext.os.is.iPad) {
        this.override({
            isFullscreen: function() {
                return true;
            }
        });
    }
});

Ext.define("Ext.viewport.Android", {
    extend: "Ext.viewport.Default",
    constructor: function() {
        this.on("orientationchange", "doFireOrientationChangeEvent", this, {
            prepend: true
        });
        this.on("orientationchange", "hideKeyboardIfNeeded", this, {
            prepend: true
        });
        this.callParent(arguments);
        this.addWindowListener("resize", Ext.Function.bind(this.onResize, this));
    },
    getDummyInput: function() {
        var e = this.dummyInput, t = this.focusedElement, i = Ext.fly(t).getPageBox();
        if (!e) {
            this.dummyInput = e = document.createElement("input");
            e.style.position = "absolute";
            e.style.opacity = "0";
            document.body.appendChild(e);
        }
        e.style.left = i.left + "px";
        e.style.top = i.top + "px";
        e.style.display = "";
        return e;
    },
    doBlurInput: function(e) {
        var t = e.target, i = this.focusedElement, n;
        if (i && !this.isInputRegex.test(t.tagName)) {
            n = this.getDummyInput();
            delete this.focusedElement;
            n.focus();
            setTimeout(function() {
                n.style.display = "none";
            }, 100);
        }
    },
    hideKeyboardIfNeeded: function() {
        var e = arguments[arguments.length - 1], t = this.focusedElement;
        if (t) {
            delete this.focusedElement;
            e.pause();
            if (Ext.os.version.lt("4")) {
                t.style.display = "none";
            } else {
                t.blur();
            }
            setTimeout(function() {
                t.style.display = "";
                e.resume();
            }, 1e3);
        }
    },
    doFireOrientationChangeEvent: function() {
        var e = arguments[arguments.length - 1];
        this.orientationChanging = true;
        e.pause();
        this.waitUntil(function() {
            return this.getWindowOuterHeight() !== this.windowOuterHeight;
        }, function() {
            this.windowOuterHeight = this.getWindowOuterHeight();
            this.updateSize();
            e.firingArguments[2] = this.windowWidth;
            e.firingArguments[3] = this.windowHeight;
            e.resume();
            this.orientationChanging = false;
        }, function() {
            Ext.Logger.error("Timeout waiting for viewport's outerHeight to change before firing orientationchange", this);
        });
        return this;
    },
    applyAutoMaximize: function(e) {
        e = this.callParent(arguments);
        this.on("add", "fixSize", this, {
            single: true
        });
        if (!e) {
            this.on("ready", "fixSize", this, {
                single: true
            });
            this.onAfter("orientationchange", "doFixSize", this, {
                buffer: 100
            });
        } else {
            this.un("ready", "fixSize", this);
            this.unAfter("orientationchange", "doFixSize", this);
        }
    },
    fixSize: function() {
        this.doFixSize();
    },
    doFixSize: function() {
        this.setHeight(this.getWindowHeight());
    },
    determineOrientation: function() {
        return this.getWindowHeight() >= this.getWindowWidth() ? this.PORTRAIT : this.LANDSCAPE;
    },
    getActualWindowOuterHeight: function() {
        return Math.round(this.getWindowOuterHeight() / window.devicePixelRatio);
    },
    maximize: function() {
        var e = this.stretchHeights, t = this.orientation, i;
        i = e[t];
        if (!i) {
            e[t] = i = this.getActualWindowOuterHeight();
        }
        if (!this.addressBarHeight) {
            this.addressBarHeight = i - this.getWindowHeight();
        }
        this.setHeight(i);
        var n = Ext.Function.bind(this.isHeightMaximized, this, [ i ]);
        this.scrollToTop();
        this.waitUntil(n, this.fireMaximizeEvent, this.fireMaximizeEvent);
    },
    isHeightMaximized: function(e) {
        this.scrollToTop();
        return this.getWindowHeight() === e;
    }
}, function() {
    if (!Ext.os.is.Android) {
        return;
    }
    var e = Ext.os.version, t = Ext.browser.userAgent, i = /(htc|desire|incredible|ADR6300)/i.test(t) && e.lt("2.3");
    if (i) {
        this.override({
            constructor: function(e) {
                if (!e) {
                    e = {};
                }
                e.autoMaximize = false;
                this.watchDogTick = Ext.Function.bind(this.watchDogTick, this);
                setInterval(this.watchDogTick, 1e3);
                return this.callParent([ e ]);
            },
            watchDogTick: function() {
                this.watchDogLastTick = Ext.Date.now();
            },
            doPreventPanning: function() {
                var e = Ext.Date.now(), t = this.watchDogLastTick, i = e - t;
                if (i >= 2e3) {
                    return;
                }
                return this.callParent(arguments);
            },
            doPreventZooming: function() {
                var e = Ext.Date.now(), t = this.watchDogLastTick, i = e - t;
                if (i >= 2e3) {
                    return;
                }
                return this.callParent(arguments);
            }
        });
    }
    if (e.match("2")) {
        this.override({
            onReady: function() {
                this.addWindowListener("resize", Ext.Function.bind(this.onWindowResize, this));
                this.callParent(arguments);
            },
            scrollToTop: function() {
                document.body.scrollTop = 100;
            },
            onWindowResize: function() {
                var e = this.windowWidth, t = this.windowHeight, i = this.getWindowWidth(), n = this.getWindowHeight();
                if (this.getAutoMaximize() && !this.isMaximizing && !this.orientationChanging && window.scrollY === 0 && e === i && n < t && (n >= t - this.addressBarHeight || !this.focusedElement)) {
                    this.scrollToTop();
                }
            },
            fixSize: function() {
                var e = this.getOrientation(), t = window.outerHeight, i = window.outerWidth, n;
                if (e === "landscape" && t < i || e === "portrait" && t >= i) {
                    n = this.getActualWindowOuterHeight();
                } else {
                    n = this.getWindowHeight();
                }
                this.waitUntil(function() {
                    return n > this.getWindowHeight();
                }, this.doFixSize, this.doFixSize, 50, 1e3);
            }
        });
    } else if (e.gtEq("3.1")) {
        this.override({
            isHeightMaximized: function(e) {
                this.scrollToTop();
                return this.getWindowHeight() === e - 1;
            }
        });
    } else if (e.match("3")) {
        this.override({
            isHeightMaximized: function() {
                this.scrollToTop();
                return true;
            }
        });
    }
    if (e.gtEq("4")) {
        this.override({
            doBlurInput: Ext.emptyFn,
            onResize: function() {
                this.callParent();
                this.doFixSize();
            }
        });
    }
});

Ext.define("Ext.viewport.Viewport", {
    requires: [ "Ext.viewport.Ios", "Ext.viewport.Android" ],
    constructor: function(e) {
        var t = Ext.os.name, i, n;
        switch (t) {
          case "Android":
            i = Ext.browser.name == "ChromeMobile" ? "Default" : "Android";
            break;

          case "iOS":
            i = "Ios";
            break;

          default:
            i = "Default";
        }
        n = Ext.create("Ext.viewport." + i, e);
        return n;
    }
});

Ext.define("Ext.app.Controller", {
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    config: {
        refs: {},
        routes: {},
        control: {},
        before: {},
        application: {},
        stores: [],
        models: [],
        views: []
    },
    constructor: function(e) {
        this.initConfig(e);
        this.mixins.observable.constructor.call(this, e);
    },
    init: Ext.emptyFn,
    launch: Ext.emptyFn,
    redirectTo: function(e) {
        return this.getApplication().redirectTo(e);
    },
    execute: function(e, t) {
        e.setBeforeFilters(this.getBefore()[e.getAction()]);
        e.execute();
    },
    applyBefore: function(e) {
        var t, i, n, r;
        for (i in e) {
            t = Ext.Array.from(e[i]);
            n = t.length;
            for (r = 0; r < n; r++) {
                t[r] = this[t[r]];
            }
            e[i] = t;
        }
        return e;
    },
    applyControl: function(e) {
        this.control(e, this);
        return e;
    },
    applyRefs: function(e) {
        if (Ext.isArray(e)) {
            Ext.Logger.deprecate("In Sencha Touch 2 the refs config accepts an object but you have passed it an array.");
        }
        this.ref(e);
        return e;
    },
    applyRoutes: function(e) {
        var t = this instanceof Ext.app.Application ? this : this.getApplication(), i = t.getRouter(), n, r, s;
        for (r in e) {
            n = e[r];
            s = {
                controller: this.$className
            };
            if (Ext.isString(n)) {
                s.action = n;
            } else {
                Ext.apply(s, n);
            }
            i.connect(r, s);
        }
        return e;
    },
    applyStores: function(e) {
        return this.getFullyQualified(e, "store");
    },
    applyModels: function(e) {
        return this.getFullyQualified(e, "model");
    },
    applyViews: function(e) {
        return this.getFullyQualified(e, "view");
    },
    getFullyQualified: function(e, t) {
        var i = e.length, n = this.getApplication().getName(), r, s;
        for (s = 0; s < i; s++) {
            r = e[s];
            if (Ext.isString(r) && (Ext.Loader.getPrefix(r) === "" || r === n)) {
                e[s] = n + "." + t + "." + r;
            }
        }
        return e;
    },
    control: function(e) {
        this.getApplication().control(e, this);
    },
    ref: function(e) {
        var t = this, i, n, r, s;
        for (i in e) {
            r = e[i];
            n = "get" + Ext.String.capitalize(i);
            if (!this[n]) {
                if (Ext.isString(e[i])) {
                    s = {
                        ref: i,
                        selector: r
                    };
                } else {
                    s = e[i];
                }
                this[n] = function(e, i) {
                    var n = [ e, i ];
                    return function() {
                        return t.getRef.apply(t, n.concat.apply(n, arguments));
                    };
                }(i, s);
            }
            this.references = this.references || [];
            this.references.push(i.toLowerCase());
        }
    },
    getRef: function(e, t, i) {
        this.refCache = this.refCache || {};
        t = t || {};
        i = i || {};
        Ext.apply(t, i);
        if (t.forceCreate) {
            return Ext.ComponentManager.create(t, "component");
        }
        var n = this, r = n.refCache[e];
        if (!r) {
            n.refCache[e] = r = Ext.ComponentQuery.query(t.selector)[0];
            if (!r && t.autoCreate) {
                n.refCache[e] = r = Ext.ComponentManager.create(t, "component");
            }
            if (r) {
                r.on("destroy", function() {
                    n.refCache[e] = null;
                });
            }
        }
        return r;
    },
    hasRef: function(e) {
        return this.references && this.references.indexOf(e.toLowerCase()) !== -1;
    },
    onClassExtended: function(e, t) {
        var i = this.prototype, n = i.config, r = t.config || {}, s = t.refs, a = {}, o = t.stores, l = t.views, u = Ext.String.format, c, f, d, h, g;
        for (f in n) {
            if (f in t && f != "control") {
                if (f == "refs") {
                    for (h = 0; h < s.length; h++) {
                        c = s[h];
                        a[c.ref] = c;
                    }
                    r.refs = a;
                } else {
                    r[f] = t[f];
                }
                delete t[f];
                Ext.Logger.deprecate(f + " is deprecated as a property directly on the " + this.$className + " prototype. Please put it inside the config object.");
            }
        }
        if (o) {
            d = o.length;
            r.stores = o;
            for (h = 0; h < d; h++) {
                g = u("get{0}Store", Ext.String.capitalize(o[h]));
                i[g] = function(e) {
                    return function() {
                        return Ext.StoreManager.lookup(e);
                    };
                }(o[h]);
            }
        }
        if (l) {
            d = l.length;
            r.views = l;
            for (h = 0; h < d; h++) {
                g = u("get{0}View", l[h]);
                i[g] = function(e) {
                    return function() {
                        return Ext.ClassManager.classes[u("{0}.view.{1}", this.getApplication().getName(), e)];
                    };
                }(l[h]);
            }
        }
        t.config = r;
    },
    getModel: function(e) {
        Ext.Logger.deprecate("getModel() is deprecated and considered bad practice - please just use the Model " + "name instead (e.g. MyApp.model.User vs this.getModel('User'))");
        var t = this.getApplication().getName(), i = Ext.ClassManager.classes;
        return i[t + ".model." + e];
    },
    getController: function(e, t) {
        Ext.Logger.deprecate("Ext.app.Controller#getController is deprecated and considered bad practice - " + "please use this.getApplication().getController('someController') instead");
        return this.getApplication().getController(e, t);
    }
}, function() {
    Ext.regController = function(e, t) {
        Ext.apply(t, {
            extend: "Ext.app.Controller"
        });
        Ext.Logger.deprecate("[Ext.app.Controller] Ext.regController is deprecated, please use Ext.define to define a Controller as " + "with any other class. For more information see the Touch 1.x -> 2.x migration guide");
        Ext.define("controller." + e, t);
    };
});

Ext.define("Ext.app.History", {
    mixins: [ "Ext.mixin.Observable" ],
    config: {
        actions: [],
        updateUrl: true,
        token: ""
    },
    constructor: function(e) {
        if (Ext.feature.has.History) {
            window.addEventListener("hashchange", Ext.bind(this.detectStateChange, this));
        } else {
            setInterval(Ext.bind(this.detectStateChange, this), 100);
        }
        this.initConfig(e);
        if (e && Ext.isEmpty(e.token)) {
            this.setToken(window.location.hash.substr(1));
        }
    },
    add: function(e, t) {
        this.getActions().push(Ext.factory(e, Ext.app.Action));
        var i = e.getUrl();
        if (this.getUpdateUrl()) {
            this.setToken(i);
            window.location.hash = i;
        }
        if (t !== true) {
            this.fireEvent("change", i);
        }
        this.setToken(i);
    },
    back: function() {
        var e = this.getActions(), t = e[e.length - 2];
        if (t) {
            e.pop();
            t.getController().getApplication().redirectTo(t.getUrl());
        } else {
            e[e.length - 1].getController().getApplication().redirectTo("");
        }
    },
    applyToken: function(e) {
        return e[0] == "#" ? e.substr(1) : e;
    },
    detectStateChange: function() {
        var e = this.applyToken(window.location.hash), t = this.getToken();
        if (e != t) {
            this.onStateChange();
            this.setToken(e);
        }
    },
    onStateChange: function() {
        this.fireEvent("change", window.location.hash.substr(1));
    }
});

Ext.define("Ext.app.Profile", {
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    config: {
        namespace: "auto",
        name: "auto",
        controllers: [],
        models: [],
        views: [],
        stores: [],
        application: null
    },
    constructor: function(e) {
        this.initConfig(e);
        this.mixins.observable.constructor.apply(this, arguments);
    },
    isActive: function() {
        return false;
    },
    launch: Ext.emptyFn,
    applyNamespace: function(e) {
        if (e == "auto") {
            e = this.getName();
        }
        return e.toLowerCase();
    },
    applyName: function(e) {
        if (e == "auto") {
            var t = this.$className.split(".");
            e = t[t.length - 1];
        }
        return e;
    },
    getDependencies: function() {
        var e = [], t = Ext.String.format, i = this.getApplication().getName(), n = this.getNamespace(), r = {
            model: this.getModels(),
            view: this.getViews(),
            controller: this.getControllers(),
            store: this.getStores()
        }, s, a, o;
        for (s in r) {
            a = [];
            Ext.each(r[s], function(t) {
                if (Ext.isString(t)) {
                    if (Ext.isString(t) && (Ext.Loader.getPrefix(t) === "" || t === i)) {
                        t = i + "." + s + "." + n + "." + t;
                    }
                    a.push(t);
                    e.push(t);
                }
            }, this);
            r[s] = a;
        }
        r.all = e;
        return r;
    }
});

Ext.define("Ext.app.Action", {
    config: {
        scope: null,
        application: null,
        controller: null,
        action: null,
        args: [],
        url: undefined,
        data: {},
        title: null,
        beforeFilters: [],
        currentFilterIndex: -1
    },
    constructor: function(e) {
        this.initConfig(e);
        this.getUrl();
    },
    execute: function() {
        this.resume();
    },
    resume: function() {
        var e = this.getCurrentFilterIndex() + 1, t = this.getBeforeFilters(), i = this.getController(), n = t[e];
        if (n) {
            this.setCurrentFilterIndex(e);
            n.call(i, this);
        } else {
            i[this.getAction()].apply(i, this.getArgs());
        }
    },
    applyUrl: function(e) {
        if (e === null || e === undefined) {
            e = this.urlEncode();
        }
        return e;
    },
    applyController: function(e) {
        var t = this.getApplication(), i = t.getCurrentProfile();
        if (Ext.isString(e)) {
            e = t.getController(e, i ? i.getNamespace() : null);
        }
        return e;
    },
    urlEncode: function() {
        var e = this.getController(), t;
        if (e instanceof Ext.app.Controller) {
            t = e.$className.split(".");
            e = t[t.length - 1];
        }
        return e + "/" + this.getAction();
    }
});

Ext.define("Ext.app.Route", {
    config: {
        conditions: {},
        url: null,
        controller: null,
        action: null,
        initialized: false
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    recognize: function(e) {
        if (!this.getInitialized()) {
            this.initialize();
        }
        if (this.recognizes(e)) {
            var t = this.matchesFor(e), i = e.match(this.matcherRegex);
            i.shift();
            return Ext.applyIf(t, {
                controller: this.getController(),
                action: this.getAction(),
                historyUrl: e,
                args: i
            });
        }
    },
    initialize: function() {
        this.paramMatchingRegex = new RegExp(/:([0-9A-Za-z\_]*)/g);
        this.paramsInMatchString = this.getUrl().match(this.paramMatchingRegex) || [];
        this.matcherRegex = this.createMatcherRegex(this.getUrl());
        this.setInitialized(true);
    },
    recognizes: function(e) {
        return this.matcherRegex.test(e);
    },
    matchesFor: function(e) {
        var t = {}, i = this.paramsInMatchString, n = e.match(this.matcherRegex), r = i.length, s;
        n.shift();
        for (s = 0; s < r; s++) {
            t[i[s].replace(":", "")] = n[s];
        }
        return t;
    },
    argsFor: function(e) {
        var t = [], i = this.paramsInMatchString, n = e.match(this.matcherRegex), r = i.length, s;
        n.shift();
        for (s = 0; s < r; s++) {
            t.push(i[s].replace(":", ""));
            params[i[s].replace(":", "")] = n[s];
        }
        return params;
    },
    urlFor: function(e) {
        var t = this.getUrl();
        for (var i in e) {
            t = t.replace(":" + i, e[i]);
        }
        return t;
    },
    createMatcherRegex: function(e) {
        var t = this.paramsInMatchString, i = t.length, n, r, s;
        for (n = 0; n < i; n++) {
            r = this.getConditions()[t[n]];
            s = Ext.util.Format.format("({0})", r || "[%a-zA-Z0-9-\\_\\s,]+");
            e = e.replace(new RegExp(t[n]), s);
        }
        return new RegExp("^" + e + "$");
    }
});

Ext.define("Ext.app.Router", {
    requires: [ "Ext.app.Route" ],
    config: {
        routes: [],
        defaults: {
            action: "index"
        }
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    connect: function(e, t) {
        t = Ext.apply({
            url: e
        }, t || {}, this.getDefaults());
        var i = Ext.create("Ext.app.Route", t);
        this.getRoutes().push(i);
        return i;
    },
    recognize: function(e) {
        var t = this.getRoutes(), i = t.length, n, r;
        for (n = 0; n < i; n++) {
            r = t[n].recognize(e);
            if (r !== undefined) {
                return r;
            }
        }
        return undefined;
    },
    draw: function(e) {
        e.call(this, this);
    },
    clear: function() {
        this.setRoutes([]);
    }
}, function() {
    Ext.Router = {};
    var e = [];
    Ext.Router.setAppInstance = function(t) {
        Ext.Router.appInstance = t;
        if (e.length > 0) {
            Ext.each(e, Ext.Router.draw);
        }
    };
    Ext.Router.draw = function(t) {
        Ext.Logger.deprecate("Ext.Router.map is deprecated, please define your routes inline inside each Controller. " + "Please see the 1.x -> 2.x migration guide for more details.");
        var i = Ext.Router.appInstance, n;
        if (i) {
            n = i.getRouter();
            t(n);
        } else {
            e.push(t);
        }
    };
});

Ext.define("Ext.app.Application", {
    extend: "Ext.app.Controller",
    requires: [ "Ext.app.History", "Ext.app.Profile", "Ext.app.Router", "Ext.app.Action" ],
    config: {
        profiles: [],
        controllers: [],
        history: {},
        name: null,
        appFolder: "app",
        router: {},
        controllerInstances: [],
        profileInstances: [],
        currentProfile: null,
        launch: Ext.emptyFn,
        enableLoader: true,
        requires: []
    },
    constructor: function(e) {
        e = e || {};
        Ext.applyIf(e, {
            application: this
        });
        this.initConfig(e);
        for (var t in e) {
            this[t] = e[t];
        }
        if (e.autoCreateViewport) {
            Ext.Logger.deprecate("[Ext.app.Application] autoCreateViewport has been deprecated in Sencha Touch 2. Please implement a " + 'launch function on your Application instead and use Ext.create("MyApp.view.Main") to create your initial UI.');
        }
        Ext.Loader.setConfig({
            enabled: true
        });
        Ext.require(this.getRequires(), function() {
            if (this.getEnableLoader() !== false) {
                Ext.require(this.getProfiles(), this.onProfilesLoaded, this);
            }
        }, this);
    },
    dispatch: function(e, t) {
        e = e || {};
        Ext.applyIf(e, {
            application: this
        });
        e = Ext.factory(e, Ext.app.Action);
        if (e) {
            var i = this.getCurrentProfile(), n = i ? i.getNamespace() : undefined, r = this.getController(e.getController(), n);
            if (r) {
                if (t !== false) {
                    this.getHistory().add(e, true);
                }
                r.execute(e);
            }
        }
    },
    redirectTo: function(e) {
        if (Ext.data && Ext.data.Model && e instanceof Ext.data.Model) {
            var t = e;
            e = t.toUrl();
        }
        var i = this.getRouter().recognize(e);
        if (i) {
            i.url = e;
            if (t) {
                i.data = {};
                i.data.record = t;
            }
            return this.dispatch(i);
        }
    },
    control: function(e, t) {
        t = t || this;
        var i = this.getEventDispatcher(), n = t ? t.getRefs() : {}, r, s, a, o, l;
        for (r in e) {
            if (e.hasOwnProperty(r)) {
                o = e[r];
                l = n[r];
                if (l) {
                    r = l.selector || l;
                }
                for (s in o) {
                    a = o[s];
                    if (Ext.isString(a)) {
                        a = t[a];
                    }
                    i.addListener("component", r, s, a, t);
                }
            }
        }
    },
    getController: function(e, t) {
        var i = this.getControllerInstances(), n = this.getName(), r = Ext.String.format, s;
        if (e instanceof Ext.app.Controller) {
            return e;
        }
        if (i[e]) {
            return i[e];
        } else {
            s = r("{0}.controller.{1}", n, e);
            t = r("{0}.controller.{1}.{2}", n, t, e);
            return i[t] || i[s];
        }
    },
    onProfilesLoaded: function() {
        var e = this.getProfiles(), t = e.length, i = [], n = this.gatherDependencies(), r, s, a;
        for (s = 0; s < t; s++) {
            i[s] = Ext.create(e[s], {
                application: this
            });
            a = i[s].getDependencies();
            n = n.concat(a.all);
            if (i[s].isActive() && !r) {
                r = i[s];
                this.setCurrentProfile(r);
                this.setControllers(this.getControllers().concat(a.controller));
                this.setModels(this.getModels().concat(a.model));
                this.setViews(this.getViews().concat(a.view));
                this.setStores(this.getStores().concat(a.store));
            }
        }
        this.setProfileInstances(i);
        Ext.require(n, this.loadControllerDependencies, this);
    },
    loadControllerDependencies: function() {
        this.instantiateControllers();
        var e = this.getControllerInstances(), t = [], i = [], n, r, s, a;
        for (a in e) {
            r = e[a];
            s = r.getStores();
            i = i.concat(s);
            t = t.concat(r.getModels().concat(r.getViews()).concat(s));
        }
        this.setStores(this.getStores().concat(i));
        Ext.require(t, this.onDependenciesLoaded, this);
    },
    onDependenciesLoaded: function() {
        var e = this, t = this.getCurrentProfile(), i = this.getLaunch(), n, r;
        this.instantiateStores();
        Ext.app.Application.appInstance = this;
        if (Ext.Router) {
            Ext.Router.setAppInstance(this);
        }
        n = this.getControllerInstances();
        for (r in n) {
            n[r].init(this);
        }
        if (t) {
            t.launch();
        }
        i.call(e);
        for (r in n) {
            if (n[r] && !(n[r] instanceof Ext.app.Controller)) {
                Ext.Logger.warn("The controller '" + r + "' doesn't have a launch method. Are you sure it extends from Ext.app.Controller?");
            } else {
                n[r].launch(this);
            }
        }
        e.redirectTo(window.location.hash.substr(1));
    },
    gatherDependencies: function() {
        var e = this.getModels().concat(this.getViews()).concat(this.getControllers());
        Ext.each(this.getStores(), function(t) {
            if (Ext.isString(t)) {
                e.push(t);
            }
        }, this);
        return e;
    },
    instantiateStores: function() {
        var e = this.getStores(), t = e.length, i, n, r, s, a;
        for (a = 0; a < t; a++) {
            i = e[a];
            if (Ext.data && Ext.data.Store && !(i instanceof Ext.data.Store)) {
                if (Ext.isString(i)) {
                    r = i;
                    n = Ext.ClassManager.classes[i];
                    i = {
                        xclass: i
                    };
                    if (n.prototype.defaultConfig.storeId === undefined) {
                        s = r.split(".");
                        i.id = s[s.length - 1];
                    }
                }
                e[a] = Ext.factory(i, Ext.data.Store);
            }
        }
        this.setStores(e);
    },
    instantiateControllers: function() {
        var e = this.getControllers(), t = {}, i = e.length, n, r;
        for (r = 0; r < i; r++) {
            n = e[r];
            t[n] = Ext.create(n, {
                application: this
            });
        }
        return this.setControllerInstances(t);
    },
    applyControllers: function(e) {
        return this.getFullyQualified(e, "controller");
    },
    applyProfiles: function(e) {
        return this.getFullyQualified(e, "profile");
    },
    applyName: function(e) {
        var t;
        if (e && e.match(/ /g)) {
            t = e;
            e = e.replace(/ /g, "");
            Ext.Logger.warn('Attempting to create an application with a name which contains whitespace ("' + t + '"). Renamed to "' + e + '".');
        }
        return e;
    },
    updateName: function(e) {
        Ext.ClassManager.setNamespace(e + ".app", this);
        if (!Ext.Loader.config.paths[e]) {
            Ext.Loader.setPath(e, this.getAppFolder());
        }
    },
    applyRouter: function(e) {
        return Ext.factory(e, Ext.app.Router, this.getRouter());
    },
    applyHistory: function(e) {
        var t = Ext.factory(e, Ext.app.History, this.getHistory());
        t.on("change", this.onHistoryChange, this);
        return t;
    },
    onHistoryChange: function(e) {
        this.dispatch(this.getRouter().recognize(e), false);
    }
}, function() {
    Ext.regApplication = function(e) {
        Ext.Logger.deprecate("[Ext.app.Application] Ext.regApplication() is deprecated, please replace it with Ext.application()");
        var t = e.name, i = Ext.String.format;
        Ext.ns(t, i("{0}.controllers", t), i("{0}.models", t), i("{0}.views", t));
        Ext.application(e);
    };
    Ext.define("Ext.data.ProxyMgr", {
        singleton: true,
        registerType: function(e, t) {
            Ext.Logger.deprecate("Ext.data.ProxyMgr no longer exists - instead of calling Ext.data.ProxyMgr.registerType just update " + 'your custom Proxy class to set alias: "proxy.' + e + '"');
            Ext.ClassManager.setAlias(t, "proxy." + e);
        }
    });
    Ext.reg = function(e, t) {
        Ext.Logger.deprecate('Ext.reg is deprecated, please set xtype: "' + e + '" directly in your subclass instead');
        Ext.ClassManager.setAlias(t, e);
    };
    Ext.redirect = function() {
        var e = Ext.app.Application.appInstance;
        Ext.Logger.deprecate("[Ext.app.Application] Ext.redirect is deprecated, please use YourApp.redirectTo instead");
        if (e) {
            e.redirectTo.apply(e, arguments);
        }
    };
    Ext.dispatch = function() {
        var e = Ext.app.Application.appInstance;
        Ext.Logger.deprecate("[Ext.app.Application] Ext.dispatch is deprecated, please use YourApp.dispatch instead");
        if (e) {
            e.dispatch.apply(e, arguments);
        }
    };
});

Ext.define("Ext.data.JsonP", {
    alternateClassName: "Ext.util.JSONP",
    singleton: true,
    requestCount: 0,
    requests: {},
    timeout: 3e4,
    disableCaching: true,
    disableCachingParam: "_dc",
    callbackKey: "callback",
    request: function(e) {
        e = Ext.apply({}, e);
        if (!e.url) {
            Ext.Logger.error("A url must be specified for a JSONP request.");
        }
        var t = this, i = Ext.isDefined(e.disableCaching) ? e.disableCaching : t.disableCaching, n = e.disableCachingParam || t.disableCachingParam, r = ++t.requestCount, s = e.callbackName || "callback" + r, a = e.callbackKey || t.callbackKey, o = Ext.isDefined(e.timeout) ? e.timeout : t.timeout, l = Ext.apply({}, e.params), u = e.url, c = Ext.isSandboxed ? Ext.getUniqueGlobalNamespace() : "Ext", f, d;
        l[a] = c + ".data.JsonP." + s;
        if (i) {
            l[n] = new Date().getTime();
        }
        d = t.createScript(u, l, e);
        t.requests[r] = f = {
            url: u,
            params: l,
            script: d,
            id: r,
            scope: e.scope,
            success: e.success,
            failure: e.failure,
            callback: e.callback,
            callbackKey: a,
            callbackName: s
        };
        if (o > 0) {
            f.timeout = setTimeout(Ext.bind(t.handleTimeout, t, [ f ]), o);
        }
        t.setupErrorHandling(f);
        t[s] = Ext.bind(t.handleResponse, t, [ f ], true);
        t.loadScript(f);
        return f;
    },
    abort: function(e) {
        var t = this.requests, i;
        if (e) {
            if (!e.id) {
                e = t[e];
            }
            this.handleAbort(e);
        } else {
            for (i in t) {
                if (t.hasOwnProperty(i)) {
                    this.abort(t[i]);
                }
            }
        }
    },
    setupErrorHandling: function(e) {
        e.script.onerror = Ext.bind(this.handleError, this, [ e ]);
    },
    handleAbort: function(e) {
        e.errorType = "abort";
        this.handleResponse(null, e);
    },
    handleError: function(e) {
        e.errorType = "error";
        this.handleResponse(null, e);
    },
    cleanupErrorHandling: function(e) {
        e.script.onerror = null;
    },
    handleTimeout: function(e) {
        e.errorType = "timeout";
        this.handleResponse(null, e);
    },
    handleResponse: function(e, t) {
        var i = true;
        if (t.timeout) {
            clearTimeout(t.timeout);
        }
        delete this[t.callbackName];
        delete this.requests[t.id];
        this.cleanupErrorHandling(t);
        Ext.fly(t.script).destroy();
        if (t.errorType) {
            i = false;
            Ext.callback(t.failure, t.scope, [ t.errorType, t ]);
        } else {
            Ext.callback(t.success, t.scope, [ e, t ]);
        }
        Ext.callback(t.callback, t.scope, [ i, e, t.errorType, t ]);
    },
    createScript: function(e, t, i) {
        var n = document.createElement("script");
        n.setAttribute("src", Ext.urlAppend(e, Ext.Object.toQueryString(t)));
        n.setAttribute("async", true);
        n.setAttribute("type", "text/javascript");
        return n;
    },
    loadScript: function(e) {
        Ext.getHead().appendChild(e.script);
    }
});

Ext.define("Ext.data.Request", {
    config: {
        action: null,
        params: null,
        method: "GET",
        url: null,
        operation: null,
        proxy: null,
        disableCaching: false,
        headers: {},
        callbackKey: null,
        jsonP: null,
        jsonData: null,
        xmlData: null,
        withCredentials: null,
        username: null,
        password: null,
        callback: null,
        scope: null,
        timeout: 3e4,
        records: null,
        directFn: null,
        args: null
    },
    constructor: function(e) {
        this.initConfig(e);
    }
});

Ext.define("Ext.data.Batch", {
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    config: {
        autoStart: false,
        pauseOnException: true,
        proxy: null
    },
    current: -1,
    total: 0,
    isRunning: false,
    isComplete: false,
    hasException: false,
    constructor: function(e) {
        var t = this;
        t.initConfig(e);
        t.operations = [];
    },
    add: function(e) {
        this.total++;
        e.setBatch(this);
        this.operations.push(e);
    },
    start: function() {
        this.hasException = false;
        this.isRunning = true;
        this.runNextOperation();
    },
    runNextOperation: function() {
        this.runOperation(this.current + 1);
    },
    pause: function() {
        this.isRunning = false;
    },
    runOperation: function(e) {
        var t = this, i = t.operations, n = i[e], r;
        if (n === undefined) {
            t.isRunning = false;
            t.isComplete = true;
            t.fireEvent("complete", t, i[i.length - 1]);
        } else {
            t.current = e;
            r = function(e) {
                var i = e.hasException();
                if (i) {
                    t.hasException = true;
                    t.fireEvent("exception", t, e);
                } else {
                    t.fireEvent("operationcomplete", t, e);
                }
                if (i && t.getPauseOnException()) {
                    t.pause();
                } else {
                    e.setCompleted();
                    t.runNextOperation();
                }
            };
            n.setStarted();
            t.getProxy()[n.getAction()](n, r, t);
        }
    }
});

Ext.define("Ext.data.Operation", {
    config: {
        synchronous: true,
        action: null,
        filters: null,
        sorters: null,
        grouper: null,
        start: null,
        limit: null,
        batch: null,
        callback: null,
        scope: null,
        resultSet: null,
        records: null,
        request: null,
        response: null,
        withCredentials: null,
        params: null,
        url: null,
        page: null,
        node: null,
        model: undefined,
        addRecords: false
    },
    started: false,
    running: false,
    complete: false,
    success: undefined,
    exception: false,
    error: undefined,
    constructor: function(e) {
        this.initConfig(e);
    },
    applyModel: function(e) {
        if (typeof e == "string") {
            e = Ext.data.ModelManager.getModel(e);
            if (!e) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.");
            }
        }
        if (e && !e.prototype.isModel && Ext.isObject(e)) {
            e = Ext.data.ModelManager.registerType(e.storeId || e.id || Ext.id(), e);
        }
        if (!e) {
            Ext.Logger.warn("Unless you define your model using metadata, an Operation needs to have a model defined.");
        }
        return e;
    },
    getRecords: function() {
        var e = this.getResultSet();
        return this._records || (e ? e.getRecords() : []);
    },
    setStarted: function() {
        this.started = true;
        this.running = true;
    },
    setCompleted: function() {
        this.complete = true;
        this.running = false;
    },
    setSuccessful: function() {
        this.success = true;
    },
    setException: function(e) {
        this.exception = true;
        this.success = false;
        this.running = false;
        this.error = e;
    },
    hasException: function() {
        return this.exception === true;
    },
    getError: function() {
        return this.error;
    },
    isStarted: function() {
        return this.started === true;
    },
    isRunning: function() {
        return this.running === true;
    },
    isComplete: function() {
        return this.complete === true;
    },
    wasSuccessful: function() {
        return this.isComplete() && this.success === true;
    },
    allowWrite: function() {
        return this.getAction() != "read";
    },
    process: function(e, t, i, n) {
        if (t.getSuccess() !== false) {
            this.setResponse(n);
            this.setResultSet(t);
            this.setCompleted();
            this.setSuccessful();
        } else {
            return false;
        }
        return this["process" + Ext.String.capitalize(e)].call(this, t, i, n);
    },
    processRead: function(e) {
        var t = e.getRecords(), i = [], n = this.getModel(), r = t.length, s, a;
        for (s = 0; s < r; s++) {
            a = t[s];
            i.push(new n(a.data, a.id, a.node));
        }
        this.setRecords(i);
        e.setRecords(i);
        return true;
    },
    processCreate: function(e) {
        var t = e.getRecords(), i = this.getRecords(), n = t.length, r, s, a;
        for (r = 0; r < n; r++) {
            a = t[r];
            if (a.clientId === null && i.length == 1 && t.length == 1) {
                s = i[r];
            } else {
                s = this.findCurrentRecord(a.clientId);
            }
            if (s) {
                this.updateRecord(s, a);
            } else {
                Ext.Logger.warn("Unable to match the record that came back from the server.");
            }
        }
        return true;
    },
    processUpdate: function(e) {
        var t = e.getRecords(), i = this.getRecords(), n = t.length, r, s, a;
        for (r = 0; r < n; r++) {
            a = t[r];
            s = i[r];
            if (s) {
                this.updateRecord(s, a);
            } else {
                Ext.Logger.warn("Unable to match the updated record that came back from the server.");
            }
        }
        return true;
    },
    processDestroy: function(e) {
        var t = e.getRecords(), i = t.length, n, r, s;
        for (n = 0; n < i; n++) {
            s = t[n];
            r = this.findCurrentRecord(s.id);
            if (r) {
                r.setIsErased(true);
                r.notifyStores("afterErase", r);
            } else {
                Ext.Logger.warn("Unable to match the destroyed record that came back from the server.");
            }
        }
    },
    findCurrentRecord: function(e) {
        var t = this.getRecords(), i = t.length, n, r;
        for (n = 0; n < i; n++) {
            r = t[n];
            if (r.getId() === e) {
                return r;
            }
        }
    },
    updateRecord: function(e, t) {
        var i = t.data, n = t.id;
        e.beginEdit();
        e.set(i);
        if (n !== null) {
            e.setId(n);
        }
        e.endEdit(true);
        e.commit();
    }
}, function() {
    Ext.deprecateProperty(this, "group", "grouper");
});

Ext.define("Ext.data.writer.Writer", {
    alias: "writer.base",
    alternateClassName: [ "Ext.data.DataWriter", "Ext.data.Writer" ],
    config: {
        writeAllFields: true,
        nameProperty: "name"
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    write: function(e) {
        var t = e.getOperation(), i = t.getRecords() || [], n = i.length, r = 0, s = [];
        for (;r < n; r++) {
            s.push(this.getRecordData(i[r]));
        }
        return this.writeRecords(e, s);
    },
    writeDate: function(e, t) {
        var i = e.getDateFormat() || "timestamp";
        switch (i) {
          case "timestamp":
            return t.getTime() / 1e3;

          case "time":
            return t.getTime();

          default:
            return Ext.Date.format(t, i);
        }
    },
    getRecordData: function(e) {
        var t = e.phantom === true, i = this.getWriteAllFields() || t, n = this.getNameProperty(), r = e.getFields(), s = {}, a, o, l, u, c;
        if (i) {
            r.each(function(t) {
                if (t.getPersist()) {
                    o = t.config[n] || t.getName();
                    c = e.get(t.getName());
                    if (t.getType().type == "date") {
                        c = this.writeDate(t, c);
                    }
                    s[o] = c;
                }
            }, this);
        } else {
            a = e.getChanges();
            for (u in a) {
                if (a.hasOwnProperty(u)) {
                    l = r.get(u);
                    if (l.getPersist()) {
                        o = l.config[n] || l.getName();
                        c = a[u];
                        if (l.getType().type == "date") {
                            c = this.writeDate(l, c);
                        }
                        s[o] = c;
                    }
                }
            }
            if (!t) {
                s[e.getIdProperty()] = e.getId();
            }
        }
        return s;
    },
    onClassExtended: function(e, t, i) {
        var n = this, r = n.prototype.config, s = t.config || {}, a;
        for (a in r) {
            if (a in t) {
                s[a] = t[a];
                delete t[a];
                Ext.Logger.deprecate(a + " is deprecated as a property directly on the Writer prototype. " + "Please put it inside the config object.");
            }
        }
        t.config = s;
    }
});

Ext.define("Ext.data.ResultSet", {
    config: {
        loaded: true,
        count: null,
        total: null,
        success: false,
        records: null,
        message: null
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    applyCount: function(e) {
        if (!e && e !== 0) {
            return this.getRecords().length;
        }
        return e;
    },
    updateRecords: function(e) {
        this.setCount(e.length);
    }
});

Ext.define("Ext.data.writer.Json", {
    extend: "Ext.data.writer.Writer",
    alternateClassName: "Ext.data.JsonWriter",
    alias: "writer.json",
    config: {
        rootProperty: undefined,
        encode: false,
        allowSingle: true,
        encodeRequest: false
    },
    applyRootProperty: function(e) {
        if (!e && (this.getEncode() || this.getEncodeRequest())) {
            e = "data";
        }
        return e;
    },
    writeRecords: function(e, t) {
        var i = this.getRootProperty(), n = e.getParams(), r = this.getAllowSingle(), s;
        if (this.getAllowSingle() && t && t.length == 1) {
            t = t[0];
        }
        if (this.getEncodeRequest()) {
            s = e.getJsonData() || {};
            if (t && (t.length || r && Ext.isObject(t))) {
                s[i] = t;
            }
            e.setJsonData(Ext.apply(s, n || {}));
            e.setParams(null);
            e.setMethod("POST");
            return e;
        }
        if (!t || !(t.length || r && Ext.isObject(t))) {
            return e;
        }
        if (this.getEncode()) {
            if (i) {
                n[i] = Ext.encode(t);
            } else {
                Ext.Logger.error("Must specify a root when using encode");
            }
        } else {
            s = e.getJsonData() || {};
            if (i) {
                s[i] = t;
            } else {
                s = t;
            }
            e.setJsonData(s);
        }
        return e;
    }
}, function() {
    this.override({
        constructor: function(e) {
            e = e || {};
            if (e.root) {
                Ext.Logger.deprecate("root has been deprecated as a configuration on Writer. Please use rootProperty instead.");
                e.rootProperty = e.root;
                delete e.root;
            }
            this.callOverridden([ e ]);
        }
    });
});

Ext.define("Ext.data.reader.Reader", {
    requires: [ "Ext.data.ResultSet" ],
    alternateClassName: [ "Ext.data.Reader", "Ext.data.DataReader" ],
    mixins: [ "Ext.mixin.Observable" ],
    isReader: true,
    config: {
        idProperty: undefined,
        clientIdProperty: "clientId",
        totalProperty: "total",
        successProperty: "success",
        messageProperty: null,
        rootProperty: "",
        implicitIncludes: true,
        model: undefined
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    fieldCount: 0,
    applyModel: function(e) {
        if (typeof e == "string") {
            e = Ext.data.ModelManager.getModel(e);
            if (!e) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.");
            }
        }
        if (e && !e.prototype.isModel && Ext.isObject(e)) {
            e = Ext.data.ModelManager.registerType(e.storeId || e.id || Ext.id(), e);
        }
        return e;
    },
    applyIdProperty: function(e) {
        if (!e && this.getModel()) {
            e = this.getModel().getIdProperty();
        }
        return e;
    },
    updateModel: function(e) {
        if (e) {
            if (!this.getIdProperty()) {
                this.setIdProperty(e.getIdProperty());
            }
            this.buildExtractors();
        }
    },
    createAccessor: Ext.emptyFn,
    createFieldAccessExpression: function() {
        return "undefined";
    },
    buildExtractors: function() {
        if (!this.getModel()) {
            return;
        }
        var e = this, t = e.getTotalProperty(), i = e.getSuccessProperty(), n = e.getMessageProperty();
        if (t) {
            e.getTotal = e.createAccessor(t);
        }
        if (i) {
            e.getSuccess = e.createAccessor(i);
        }
        if (n) {
            e.getMessage = e.createAccessor(n);
        }
        e.extractRecordData = e.buildRecordDataExtractor();
    },
    buildRecordDataExtractor: function() {
        var e = this, t = e.getModel(), i = t.getFields(), n = i.length, r = [], s = e.getModel().getClientIdProperty(), a = "__field", o = [ "var me = this,\n", "    fields = me.getModel().getFields(),\n", "    idProperty = me.getIdProperty(),\n", '    idPropertyIsFn = (typeof idProperty == "function"),', "    value,\n", "    internalId" ], l, u, c, f;
        i = i.items;
        for (l = 0; l < n; l++) {
            u = i[l];
            f = u.getName();
            if (f === t.getIdProperty()) {
                r[l] = "idField";
            } else {
                r[l] = a + l;
            }
            o.push(",\n    ", r[l], ' = fields.get("', u.getName(), '")');
        }
        o.push(";\n\n    return function(source) {\n        var dest = {};\n");
        o.push("        if (idPropertyIsFn) {\n");
        o.push("            idField.setMapping(idProperty);\n");
        o.push("        }\n");
        for (l = 0; l < n; l++) {
            u = i[l];
            c = r[l];
            f = u.getName();
            if (f === t.getIdProperty() && u.getMapping() === null && t.getIdProperty() !== this.getIdProperty()) {
                u.setMapping(this.getIdProperty());
            }
            o.push("        try {\n");
            o.push("            value = ", e.createFieldAccessExpression(u, c, "source"), ";\n");
            o.push("            if (value !== undefined) {\n");
            o.push('                dest["' + u.getName() + '"] = value;\n');
            o.push("            }\n");
            o.push("        } catch(e){}\n");
        }
        if (s) {
            o.push("        internalId = " + e.createFieldAccessExpression(Ext.create("Ext.data.Field", {
                name: s
            }), null, "source") + ";\n");
            o.push("        if (internalId !== undefined) {\n");
            o.push('            dest["_clientId"] = internalId;\n        }\n');
        }
        o.push("        return dest;\n");
        o.push("    };");
        return Ext.functionFactory(o.join("")).call(e);
    },
    getFields: function() {
        return this.getModel().getFields().items;
    },
    getData: function(e) {
        return e;
    },
    getResponseData: function(e) {
        return e;
    },
    getRoot: function(e) {
        return e;
    },
    read: function(e) {
        var t = e, i = this.getModel(), n, r, s, a, o;
        if (e) {
            t = this.getResponseData(e);
        }
        if (t) {
            n = this.readRecords(t);
            r = n.getRecords();
            for (s = 0, a = r.length; s < a; s++) {
                o = r[s];
                r[s] = new i(o.data, o.id, o.node);
            }
            return n;
        } else {
            return this.nullResultSet;
        }
    },
    process: function(e) {
        var t = e;
        if (e) {
            t = this.getResponseData(e);
        }
        if (t) {
            return this.readRecords(t);
        } else {
            return this.nullResultSet;
        }
    },
    readRecords: function(e) {
        var t = this;
        t.rawData = e;
        e = t.getData(e);
        if (e.metaData) {
            t.onMetaChange(e.metaData);
        }
        if (!t.getModel()) {
            Ext.Logger.warn("In order to read record data, a Reader needs to have a Model defined on it.");
        }
        var i = Ext.isArray(e), n = i ? e : t.getRoot(e), r = true, s = 0, a, o, l, u;
        if (i && !e.length) {
            return t.nullResultSet;
        }
        if (t.getTotal) {
            o = parseInt(t.getTotal(e), 10);
            if (!isNaN(o)) {
                a = o;
            }
        }
        if (t.getSuccess) {
            o = t.getSuccess(e);
            if (o === false || o === "false") {
                r = false;
            }
        }
        if (t.getMessage) {
            u = t.getMessage(e);
        }
        if (n) {
            l = t.extractData(n);
            s = l.length;
        } else {
            s = 0;
            l = [];
        }
        return new Ext.data.ResultSet({
            total: a,
            count: s,
            records: l,
            success: r,
            message: u
        });
    },
    extractData: function(e) {
        var t = this, i = [], n = e.length, r = t.getModel(), s = r.getIdProperty(), a = r.getFields(), o, l, u, c, f;
        if (a.isDirty) {
            t.buildExtractors(true);
            delete a.isDirty;
        }
        if (!e.length && Ext.isObject(e)) {
            e = [ e ];
            n = 1;
        }
        for (l = 0; l < n; l++) {
            f = null;
            c = null;
            o = e[l];
            if (o.isModel) {
                u = o.data;
            } else {
                u = t.extractRecordData(o);
            }
            if (u._clientId !== undefined) {
                f = u._clientId;
                delete u._clientId;
            }
            if (u[s] !== undefined) {
                c = u[s];
            }
            if (t.getImplicitIncludes()) {
                t.readAssociated(u, o);
            }
            i.push({
                clientId: f,
                id: c,
                data: u,
                node: o
            });
        }
        return i;
    },
    readAssociated: function(e, t) {
        var i = this.getModel().associations.items, n = i.length, r = 0, s, a, o;
        for (;r < n; r++) {
            s = i[r];
            o = s.getAssociationKey();
            a = this.getAssociatedDataRoot(t, o);
            if (a) {
                e[o] = a;
            }
        }
    },
    getAssociatedDataRoot: function(e, t) {
        var i = /[\[\.]/, n = String(t).search(i);
        if (n >= 0) {
            return Ext.functionFactory("obj", "return obj" + (n > 0 ? "." : "") + t)(e);
        }
        return e[t];
    },
    onMetaChange: function(e) {
        var t = e.fields, i = this, n, r, s;
        i.metaData = e;
        if (e.rootProperty !== undefined) {
            i.setRootProperty(e.rootProperty);
        } else if (e.root !== undefined) {
            i.setRootProperty(e.root);
        }
        if (e.idProperty !== undefined) {
            i.setIdProperty(e.idProperty);
        }
        if (e.totalProperty !== undefined) {
            i.setTotalProperty(e.totalProperty);
        }
        if (e.successProperty !== undefined) {
            i.setSuccessProperty(e.successProperty);
        }
        if (e.messageProperty !== undefined) {
            i.setMessageProperty(e.messageProperty);
        }
        if (t) {
            if (i.getModel()) {
                i.getModel().setFields(t);
                i.buildExtractors();
            } else {
                s = i.getIdProperty();
                r = {
                    fields: t
                };
                if (s) {
                    r.idProperty = s;
                }
                n = Ext.define("Ext.data.reader.MetaModel" + Ext.id(), {
                    extend: "Ext.data.Model",
                    config: r
                });
                i.setModel(n);
            }
        } else {
            i.buildExtractors();
        }
    },
    onClassExtended: function(e, t, i) {
        var n = this, r = n.prototype.config, s = t.config || {}, a;
        for (a in r) {
            if (a in t) {
                s[a] = t[a];
                delete t[a];
                Ext.Logger.deprecate(a + " is deprecated as a property directly on the Reader prototype. " + "Please put it inside the config object.");
            }
        }
        t.config = s;
    }
}, function() {
    Ext.apply(this.prototype, {
        nullResultSet: new Ext.data.ResultSet({
            total: 0,
            count: 0,
            records: [],
            success: false
        })
    });
    this.override({
        constructor: function(e) {
            e = e || {};
            if (e.root) {
                Ext.Logger.deprecate("root has been deprecated as a configuration on Reader. Please use rootProperty instead.");
                e.rootProperty = e.root;
                delete e.root;
            }
            this.callOverridden([ e ]);
        }
    });
});

Ext.define("Ext.data.reader.Json", {
    extend: "Ext.data.reader.Reader",
    alternateClassName: "Ext.data.JsonReader",
    alias: "reader.json",
    config: {
        record: null,
        useSimpleAccessors: false
    },
    objectRe: /[\[\.]/,
    getResponseData: function(e) {
        var t = e;
        if (e && e.responseText) {
            t = e.responseText;
        }
        if (typeof t !== "string") {
            return t;
        }
        var i;
        try {
            i = Ext.decode(t);
        } catch (n) {
            this.fireEvent("exception", this, e, "Unable to parse the JSON returned by the server: " + n.toString());
            Ext.Logger.warn("Unable to parse the JSON returned by the server: " + n.toString());
        }
        if (!i) {
            this.fireEvent("exception", this, e, "JSON object not found");
            Ext.Logger.error("JSON object not found");
        }
        return i;
    },
    buildExtractors: function() {
        var e = this, t = e.getRootProperty();
        e.callParent(arguments);
        if (t) {
            e.rootAccessor = e.createAccessor(t);
        } else {
            delete e.rootAccessor;
        }
    },
    getRoot: function(e) {
        var t = this.getModel().getFields();
        if (t.isDirty) {
            this.buildExtractors(true);
            delete t.isDirty;
        }
        if (this.rootAccessor) {
            return this.rootAccessor.call(this, e);
        } else {
            return e;
        }
    },
    extractData: function(e) {
        var t = this.getRecord(), i = [], n, r;
        if (t) {
            n = e.length;
            if (!n && Ext.isObject(e)) {
                n = 1;
                e = [ e ];
            }
            for (r = 0; r < n; r++) {
                i[r] = e[r][t];
            }
        } else {
            i = e;
        }
        return this.callParent([ i ]);
    },
    createAccessor: function() {
        var e = /[\[\.]/;
        return function(t) {
            if (Ext.isEmpty(t)) {
                return Ext.emptyFn;
            }
            if (Ext.isFunction(t)) {
                return t;
            }
            if (this.getUseSimpleAccessors() !== true) {
                var i = String(t).search(e);
                if (i >= 0) {
                    return Ext.functionFactory("obj", "var value; try {value = obj" + (i > 0 ? "." : "") + t + "} catch(e) {}; return value;");
                }
            }
            return function(e) {
                return e[t];
            };
        };
    }(),
    createFieldAccessExpression: function(e, t, i) {
        var n = this, r = n.objectRe, s = e.getMapping() !== null, a = s ? e.getMapping() : e.getName(), o, l;
        if (typeof a === "function") {
            o = t + ".getMapping()(" + i + ", this)";
        } else if (n.getUseSimpleAccessors() === true || (l = String(a).search(r)) < 0) {
            if (!s || isNaN(a)) {
                a = '"' + a + '"';
            }
            o = i + "[" + a + "]";
        } else {
            o = i + (l > 0 ? "." : "") + a;
        }
        return o;
    }
});

Ext.define("Ext.data.proxy.Proxy", {
    extend: "Ext.Evented",
    alias: "proxy.proxy",
    alternateClassName: [ "Ext.data.DataProxy", "Ext.data.Proxy" ],
    requires: [ "Ext.data.reader.Json", "Ext.data.writer.Json", "Ext.data.Batch", "Ext.data.Operation" ],
    config: {
        batchOrder: "create,update,destroy",
        batchActions: true,
        model: null,
        reader: {
            type: "json"
        },
        writer: {
            type: "json"
        }
    },
    isProxy: true,
    applyModel: function(e) {
        if (typeof e == "string") {
            e = Ext.data.ModelManager.getModel(e);
            if (!e) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.");
            }
        }
        if (e && !e.prototype.isModel && Ext.isObject(e)) {
            e = Ext.data.ModelManager.registerType(e.storeId || e.id || Ext.id(), e);
        }
        return e;
    },
    updateModel: function(e) {
        if (e) {
            var t = this.getReader();
            if (t && !t.getModel()) {
                t.setModel(e);
            }
        }
    },
    applyReader: function(e, t) {
        return Ext.factory(e, Ext.data.Reader, t, "reader");
    },
    updateReader: function(e) {
        if (e) {
            var t = this.getModel();
            if (!t) {
                t = e.getModel();
                if (t) {
                    this.setModel(t);
                }
            } else {
                e.setModel(t);
            }
            if (e.onMetaChange) {
                e.onMetaChange = Ext.Function.createSequence(e.onMetaChange, this.onMetaChange, this);
            }
        }
    },
    onMetaChange: function(e) {
        var t = this.getReader().getModel();
        if (!this.getModel() && t) {
            this.setModel(t);
        }
        this.fireEvent("metachange", this, e);
    },
    applyWriter: function(e, t) {
        return Ext.factory(e, Ext.data.Writer, t, "writer");
    },
    create: Ext.emptyFn,
    read: Ext.emptyFn,
    update: Ext.emptyFn,
    destroy: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.getReader(), this.getWriter());
    },
    batch: function(e, t) {
        var i = this, n = i.getBatchActions(), r = i.getModel(), s, a;
        if (e.operations === undefined) {
            e = {
                operations: e,
                listeners: t
            };
            Ext.Logger.deprecate("Passes old-style signature to Proxy.batch (operations, listeners). Please convert to single options argument syntax.");
        }
        if (e.batch && e.batch.isBatch) {
            s = e.batch;
        } else {
            s = new Ext.data.Batch(e.batch || {});
        }
        s.setProxy(i);
        s.on("complete", Ext.bind(i.onBatchComplete, i, [ e ], 0));
        if (e.listeners) {
            s.on(e.listeners);
        }
        Ext.each(i.getBatchOrder().split(","), function(t) {
            a = e.operations[t];
            if (a) {
                if (n) {
                    s.add(new Ext.data.Operation({
                        action: t,
                        records: a,
                        model: r
                    }));
                } else {
                    Ext.each(a, function(e) {
                        s.add(new Ext.data.Operation({
                            action: t,
                            records: [ e ],
                            model: r
                        }));
                    });
                }
            }
        }, i);
        s.start();
        return s;
    },
    onBatchComplete: function(e, t) {
        var i = e.scope || this;
        if (t.hasException) {
            if (Ext.isFunction(e.failure)) {
                Ext.callback(e.failure, i, [ t, e ]);
            }
        } else if (Ext.isFunction(e.success)) {
            Ext.callback(e.success, i, [ t, e ]);
        }
        if (Ext.isFunction(e.callback)) {
            Ext.callback(e.callback, i, [ t, e ]);
        }
    },
    onClassExtended: function(e, t) {
        var i = this.prototype, n = i.config, r = t.config || {}, s;
        for (s in n) {
            if (s != "control" && s in t) {
                r[s] = t[s];
                delete t[s];
                Ext.Logger.warn(s + " is deprecated as a property directly on the " + this.$className + " prototype. Please put it inside the config object.");
            }
        }
        t.config = r;
    }
}, function() {});

Ext.define("Ext.data.proxy.Server", {
    extend: "Ext.data.proxy.Proxy",
    alias: "proxy.server",
    alternateClassName: "Ext.data.ServerProxy",
    requires: [ "Ext.data.Request" ],
    config: {
        url: null,
        pageParam: "page",
        startParam: "start",
        limitParam: "limit",
        groupParam: "group",
        sortParam: "sort",
        filterParam: "filter",
        directionParam: "dir",
        enablePagingParams: true,
        simpleSortMode: false,
        noCache: true,
        cacheString: "_dc",
        timeout: 3e4,
        api: {
            create: undefined,
            read: undefined,
            update: undefined,
            destroy: undefined
        },
        extraParams: {}
    },
    constructor: function(e) {
        e = e || {};
        if (e.nocache !== undefined) {
            e.noCache = e.nocache;
            Ext.Logger.warn("nocache configuration on Ext.data.proxy.Server has been deprecated. Please use noCache.");
        }
        this.callParent([ e ]);
    },
    create: function() {
        return this.doRequest.apply(this, arguments);
    },
    read: function() {
        return this.doRequest.apply(this, arguments);
    },
    update: function() {
        return this.doRequest.apply(this, arguments);
    },
    destroy: function() {
        return this.doRequest.apply(this, arguments);
    },
    setExtraParam: function(e, t) {
        this.getExtraParams()[e] = t;
    },
    buildRequest: function(e) {
        var t = this, i = Ext.applyIf(e.getParams() || {}, t.getExtraParams() || {}), n;
        i = Ext.applyIf(i, t.getParams(e));
        n = Ext.create("Ext.data.Request", {
            params: i,
            action: e.getAction(),
            records: e.getRecords(),
            url: e.getUrl(),
            operation: e,
            proxy: t
        });
        n.setUrl(t.buildUrl(n));
        e.setRequest(n);
        return n;
    },
    processResponse: function(e, t, i, n, r, s) {
        var a = this, o = t.getAction(), l, u;
        if (e === true) {
            l = a.getReader();
            try {
                u = l.process(n);
            } catch (c) {
                t.setException(c.message);
                a.fireEvent("exception", this, n, t);
                return;
            }
            if (!t.getModel()) {
                t.setModel(this.getModel());
            }
            if (t.process(o, u, i, n) === false) {
                this.fireEvent("exception", this, n, t);
            }
        } else {
            a.setException(t, n);
            a.fireEvent("exception", this, n, t);
        }
        if (typeof r == "function") {
            r.call(s || a, t);
        }
        a.afterRequest(i, e);
    },
    setException: function(e, t) {
        if (Ext.isObject(t)) {
            e.setException({
                status: t.status,
                statusText: t.statusText
            });
        }
    },
    applyEncoding: function(e) {
        return Ext.encode(e);
    },
    encodeSorters: function(e) {
        var t = [], i = e.length, n = 0;
        for (;n < i; n++) {
            t[n] = {
                property: e[n].getProperty(),
                direction: e[n].getDirection()
            };
        }
        return this.applyEncoding(t);
    },
    encodeFilters: function(e) {
        var t = [], i = e.length, n = 0;
        for (;n < i; n++) {
            t[n] = {
                property: e[n].getProperty(),
                value: e[n].getValue()
            };
        }
        return this.applyEncoding(t);
    },
    getParams: function(e) {
        var t = this, i = {}, n = e.getGrouper(), r = e.getSorters(), s = e.getFilters(), a = e.getPage(), o = e.getStart(), l = e.getLimit(), u = t.getSimpleSortMode(), c = t.getPageParam(), f = t.getStartParam(), d = t.getLimitParam(), h = t.getGroupParam(), g = t.getSortParam(), p = t.getFilterParam(), m = t.getDirectionParam();
        if (t.getEnablePagingParams()) {
            if (c && a !== null) {
                i[c] = a;
            }
            if (f && o !== null) {
                i[f] = o;
            }
            if (d && l !== null) {
                i[d] = l;
            }
        }
        if (h && n) {
            i[h] = t.encodeSorters([ n ]);
        }
        if (g && r && r.length > 0) {
            if (u) {
                i[g] = r[0].getProperty();
                i[m] = r[0].getDirection();
            } else {
                i[g] = t.encodeSorters(r);
            }
        }
        if (p && s && s.length > 0) {
            i[p] = t.encodeFilters(s);
        }
        return i;
    },
    buildUrl: function(e) {
        var t = this, i = t.getUrl(e);
        if (!i) {
            Ext.Logger.error("You are using a ServerProxy but have not supplied it with a url.");
        }
        if (t.getNoCache()) {
            i = Ext.urlAppend(i, Ext.String.format("{0}={1}", t.getCacheString(), Ext.Date.now()));
        }
        return i;
    },
    getUrl: function(e) {
        return e ? e.getUrl() || this.getApi()[e.getAction()] || this._url : this._url;
    },
    doRequest: function(e, t, i) {
        Ext.Logger.error("The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details");
    },
    afterRequest: Ext.emptyFn
});

Ext.define("Ext.data.proxy.JsonP", {
    extend: "Ext.data.proxy.Server",
    alternateClassName: "Ext.data.ScriptTagProxy",
    alias: [ "proxy.jsonp", "proxy.scripttag" ],
    requires: [ "Ext.data.JsonP" ],
    config: {
        defaultWriterType: "base",
        callbackKey: "callback",
        recordParam: "records",
        autoAppendParams: true
    },
    doRequest: function(e, t, i) {
        var n = e.getAction();
        if (n !== "read") {
            Ext.Logger.error("JsonP proxies can only be used to read data.");
        }
        var r = this, s = r.buildRequest(e), a = s.getParams();
        s.setConfig({
            callbackKey: r.getCallbackKey(),
            timeout: r.getTimeout(),
            scope: r,
            callback: r.createRequestCallback(s, e, t, i)
        });
        if (r.getAutoAppendParams()) {
            s.setParams({});
        }
        s.setJsonP(Ext.data.JsonP.request(s.getCurrentConfig()));
        s.setParams(a);
        e.setStarted();
        r.lastRequest = s;
        return s;
    },
    createRequestCallback: function(e, t, i, n) {
        var r = this;
        return function(s, a, o) {
            delete r.lastRequest;
            r.processResponse(s, t, e, a, i, n);
        };
    },
    setException: function(e, t) {
        e.setException(e.getRequest().getJsonP().errorType);
    },
    buildUrl: function(e) {
        var t = this, i = t.callParent(arguments), n = Ext.apply({}, e.getParams()), r = n.filters, s, a, o, l;
        delete n.filters;
        if (t.getAutoAppendParams()) {
            i = Ext.urlAppend(i, Ext.Object.toQueryString(n));
        }
        if (r && r.length) {
            for (o = 0; o < r.length; o++) {
                a = r[o];
                l = a.getValue();
                if (l) {
                    i = Ext.urlAppend(i, a.getProperty() + "=" + l);
                }
            }
        }
        return i;
    },
    destroy: function() {
        this.abort();
        this.callParent(arguments);
    },
    abort: function() {
        var e = this.lastRequest;
        if (e) {
            Ext.data.JsonP.abort(e.getJsonP());
        }
    }
});

Ext.define("Twitter.proxy.Twitter", {
    extend: "Ext.data.proxy.JsonP",
    alias: "proxy.twitter",
    config: {
        url: "http://search.twitter.com/search.json",
        extraParams: {
            result_type: "mixed",
            lang: "en"
        },
        reader: {
            type: "json",
            rootProperty: "results"
        }
    },
    filterParam: undefined,
    buildRequest: function(e) {
        var t = this.callParent(arguments), i = e.getFilters()[0], n = t.getParams();
        Ext.apply(n, {
            rpp: e.getLimit(),
            page: e.getPage()
        });
        if (i) {
            delete n.filter;
            Ext.apply(n, {
                q: i.getValue()
            });
            t.setParams(n);
            t.setUrl(this._url);
            t.setUrl(this.buildUrl(t));
        }
        return t;
    }
});

Ext.define("Twitter.profile.Phone", {
    extend: "Ext.app.Profile",
    config: {
        views: [ "Main" ],
        controllers: [ "Search" ]
    },
    isActive: function() {
        return Ext.os.is.Phone;
    },
    launch: function() {
        Ext.create("Twitter.view.phone.Main");
    }
});

Ext.define("Twitter.profile.Tablet", {
    extend: "Ext.app.Profile",
    config: {
        views: [ "Main" ],
        controllers: [ "Search" ]
    },
    isActive: function() {
        return Ext.os.is.Tablet || true;
    },
    launch: function() {
        Ext.create("Twitter.view.tablet.Main");
    }
});

Ext.define("Twitter.controller.Search", {
    extend: "Ext.app.Controller",
    config: {
        refs: {
            main: {
                selector: "mainview",
                xtype: "mainview",
                autoCreate: true
            },
            searchBar: "searchbar",
            searchList: "searchlist",
            tweetList: "tweetlist",
            searchField: "searchbar > searchfield"
        },
        control: {
            searchField: {
                keyup: "onSearch"
            },
            tweetList: {
                itemtap: "onTweetTap"
            },
            searchList: {
                select: "onSearchSelect",
                itemswipe: "onSearchSwipe"
            },
            "searchlist searchlistitem button": {
                tap: "onSearchDelete"
            }
        }
    },
    launch: function() {
        Ext.getStore("Searches").load({
            callback: this.onSearchesStoreLoad,
            scope: this
        });
    },
    onSearchesStoreLoad: function() {
        var e = Ext.getStore("Searches").getAt(0);
        if (!e) {
            this.doSearch("sencha");
        }
    },
    onSearchSelect: function(e, t) {
        var i = t.tweets();
        this.getTweetList().setStore(i);
        i.load();
    },
    onSearchSwipe: function(e, t, i) {
        if (Ext.getStore("Searches").getCount() < 2) {
            return;
        }
        this.currentDeleteButton = i.getDeleteButton();
        this.currentDeleteButton.show();
        Ext.getBody().on("tap", this.onBodyTap, this);
    },
    onBodyTap: function(e) {
        if (this.currentDeleteButton) {
            this.currentDeleteButton.hide();
        }
        Ext.getBody().un("tap", this.onBodyTap, this);
    },
    onTweetTap: function(e, t, i, n, r) {
        i = Ext.get(r.target);
        if (i && i.dom && i.hasCls("hashtag")) {
            this.doSearch(i.dom.innerHTML);
        }
    },
    onSearchDelete: function(e, t) {
        var i = e.getParent(), n = i.getRecord();
        this.fireAction("destroy", [ n, e ], "doDestroy");
    },
    doDestroy: function(e, t) {
        var i = Ext.getStore("Searches");
        i.remove(e);
        i.sync();
        t.hide();
    },
    onSearch: function(e, t) {
        var i = t.event.keyCode, n = this.getSearchField();
        if (i == 13) {
            this.fireAction("search", [ n.getValue() ], "doSearch");
        }
    },
    doSearch: function(e) {
        var t = Twitter.model.Search, i = this.getTweetList(), n = this.getSearchList(), r = Ext.getStore("Searches"), s = this.getSearchField(), a, o;
        if (!e) {
            return;
        }
        i.show();
        o = r.find("query", e);
        if (o != -1) {
            e = r.getAt(o);
            n.select(e);
            s.setValue("");
            s.blur();
            return;
        }
        if (!(e instanceof Twitter.model.Search)) {
            a = e.replace("%20", " ");
            e = new t({
                query: a
            });
        }
        r.add(e);
        r.sync();
        n.select(e);
        s.setValue("");
        s.blur();
    }
});

Ext.define("Ext.data.identifier.Simple", {
    alias: "data.identifier.simple",
    statics: {
        AUTO_ID: 1
    },
    config: {
        prefix: "ext-record-"
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    generate: function(e) {
        return this._prefix + this.self.AUTO_ID++;
    }
});

Ext.define("Ext.util.Grouper", {
    extend: "Ext.util.Sorter",
    isGrouper: true,
    config: {
        groupFn: null,
        sortProperty: null,
        sorterFn: function(e, t) {
            var i = this.getSortProperty(), n, r, s, a;
            n = this.getGroupFn();
            r = n.call(this, e);
            s = n.call(this, t);
            if (i) {
                if (r !== s) {
                    return this.defaultSortFn.call(this, e, t);
                } else {
                    return 0;
                }
            }
            return r > s ? 1 : r < s ? -1 : 0;
        }
    },
    defaultSortFn: function(e, t) {
        var i = this, n = i._transform, r = i._root, s, a, o = i._sortProperty;
        if (r !== null) {
            e = e[r];
            t = t[r];
        }
        s = e[o];
        a = t[o];
        if (n) {
            s = n(s);
            a = n(a);
        }
        return s > a ? 1 : s < a ? -1 : 0;
    },
    updateProperty: function(e) {
        this.setGroupFn(this.standardGroupFn);
    },
    standardGroupFn: function(e) {
        var t = this.getRoot(), i = this.getProperty(), n = e;
        if (t) {
            n = e[t];
        }
        return n[i];
    },
    getGroupString: function(e) {
        var t = this.getGroupFn().call(this, e);
        return typeof t != "undefined" ? t.toString() : "";
    }
});

Ext.define("Ext.mixin.Sortable", {
    extend: "Ext.mixin.Mixin",
    requires: [ "Ext.util.Sorter" ],
    mixinConfig: {
        id: "sortable"
    },
    config: {
        sorters: null,
        defaultSortDirection: "ASC",
        sortRoot: null
    },
    dirtySortFn: false,
    sortFn: null,
    sorted: false,
    applySorters: function(e, t) {
        if (!t) {
            t = this.createSortersCollection();
        }
        t.clear();
        this.sorted = false;
        if (e) {
            this.addSorters(e);
        }
        return t;
    },
    createSortersCollection: function() {
        this._sorters = Ext.create("Ext.util.Collection", function(e) {
            return e.getId();
        });
        return this._sorters;
    },
    addSorter: function(e, t) {
        this.addSorters([ e ], t);
    },
    addSorters: function(e, t) {
        var i = this.getSorters();
        return this.insertSorters(i ? i.length : 0, e, t);
    },
    insertSorter: function(e, t, i) {
        return this.insertSorters(e, [ t ], i);
    },
    insertSorters: function(e, t, i) {
        if (!Ext.isArray(t)) {
            t = [ t ];
        }
        var n = t.length, r = i || this.getDefaultSortDirection(), s = this.getSortRoot(), a = this.getSorters(), o = [], l, u, c, f;
        if (!a) {
            a = this.createSortersCollection();
        }
        for (u = 0; u < n; u++) {
            c = t[u];
            l = {
                direction: r,
                root: s
            };
            if (typeof c === "string") {
                f = a.get(c);
                if (!f) {
                    l.property = c;
                } else {
                    if (i) {
                        f.setDirection(i);
                    } else {
                        f.toggle();
                    }
                    continue;
                }
            } else if (Ext.isFunction(c)) {
                l.sorterFn = c;
            } else if (Ext.isObject(c)) {
                if (!c.isSorter) {
                    if (c.fn) {
                        c.sorterFn = c.fn;
                        delete c.fn;
                    }
                    l = Ext.apply(l, c);
                } else {
                    o.push(c);
                    if (!c.getRoot()) {
                        c.setRoot(s);
                    }
                    continue;
                }
            } else {
                Ext.Logger.warn("Invalid sorter specified:", c);
            }
            c = Ext.create("Ext.util.Sorter", l);
            o.push(c);
        }
        for (u = 0, n = o.length; u < n; u++) {
            a.insert(e + u, o[u]);
        }
        this.dirtySortFn = true;
        if (a.length) {
            this.sorted = true;
        }
        return a;
    },
    removeSorter: function(e) {
        return this.removeSorters([ e ]);
    },
    removeSorters: function(e) {
        if (!Ext.isArray(e)) {
            e = [ e ];
        }
        var t = e.length, i = this.getSorters(), n, r;
        for (n = 0; n < t; n++) {
            r = e[n];
            if (typeof r === "string") {
                i.removeAtKey(r);
            } else if (typeof r === "function") {
                i.each(function(e) {
                    if (e.getSorterFn() === r) {
                        i.remove(e);
                    }
                });
            } else if (r.isSorter) {
                i.remove(r);
            }
        }
        if (!i.length) {
            this.sorted = false;
        }
    },
    updateSortFn: function() {
        var e = this.getSorters().items;
        this.sortFn = function(t, i) {
            var n = e.length, r, s;
            for (s = 0; s < n; s++) {
                r = e[s].sort.call(this, t, i);
                if (r !== 0) {
                    break;
                }
            }
            return r;
        };
        this.dirtySortFn = false;
        return this.sortFn;
    },
    getSortFn: function() {
        if (this.dirtySortFn) {
            return this.updateSortFn();
        }
        return this.sortFn;
    },
    sort: function(e) {
        Ext.Array.sort(e, this.getSortFn());
        return e;
    },
    findInsertionIndex: function(e, t, i) {
        var n = 0, r = e.length - 1, s = i || this.getSortFn(), a, o;
        while (n <= r) {
            a = n + r >> 1;
            o = s(t, e[a]);
            if (o >= 0) {
                n = a + 1;
            } else if (o < 0) {
                r = a - 1;
            }
        }
        return n;
    }
});

Ext.define("Ext.mixin.Filterable", {
    extend: "Ext.mixin.Mixin",
    requires: [ "Ext.util.Filter" ],
    mixinConfig: {
        id: "filterable"
    },
    config: {
        filters: null,
        filterRoot: null
    },
    dirtyFilterFn: false,
    filterFn: null,
    filtered: false,
    applyFilters: function(e, t) {
        if (!t) {
            t = this.createFiltersCollection();
        }
        t.clear();
        this.filtered = false;
        this.dirtyFilterFn = true;
        if (e) {
            this.addFilters(e);
        }
        return t;
    },
    createFiltersCollection: function() {
        this._filters = Ext.create("Ext.util.Collection", function(e) {
            return e.getId();
        });
        return this._filters;
    },
    addFilter: function(e) {
        this.addFilters([ e ]);
    },
    addFilters: function(e) {
        var t = this.getFilters();
        return this.insertFilters(t ? t.length : 0, e);
    },
    insertFilter: function(e, t) {
        return this.insertFilters(e, [ t ]);
    },
    insertFilters: function(e, t) {
        if (!Ext.isArray(t)) {
            t = [ t ];
        }
        var i = t.length, n = this.getFilterRoot(), r = this.getFilters(), s = [], a, o, l;
        if (!r) {
            r = this.createFiltersCollection();
        }
        for (o = 0; o < i; o++) {
            l = t[o];
            a = {
                root: n
            };
            if (Ext.isFunction(l)) {
                a.filterFn = l;
            } else if (Ext.isObject(l)) {
                if (!l.isFilter) {
                    if (l.fn) {
                        l.filterFn = l.fn;
                        delete l.fn;
                    }
                    a = Ext.apply(a, l);
                } else {
                    s.push(l);
                    if (!l.getRoot()) {
                        l.setRoot(n);
                    }
                    continue;
                }
            } else {
                Ext.Logger.warn("Invalid filter specified:", l);
            }
            l = Ext.create("Ext.util.Filter", a);
            s.push(l);
        }
        for (o = 0, i = s.length; o < i; o++) {
            r.insert(e + o, s[o]);
        }
        this.dirtyFilterFn = true;
        if (r.length) {
            this.filtered = true;
        }
        return r;
    },
    removeFilters: function(e) {
        if (!Ext.isArray(e)) {
            e = [ e ];
        }
        var t = e.length, i = this.getFilters(), n, r;
        for (n = 0; n < t; n++) {
            r = e[n];
            if (typeof r === "string") {
                i.each(function(e) {
                    if (e.getProperty() === r) {
                        i.remove(e);
                    }
                });
            } else if (typeof r === "function") {
                i.each(function(e) {
                    if (e.getFilterFn() === r) {
                        i.remove(e);
                    }
                });
            } else {
                if (r.isFilter) {
                    i.remove(r);
                } else if (r.property !== undefined && r.value !== undefined) {
                    i.each(function(e) {
                        if (e.getProperty() === r.property && e.getValue() === r.value) {
                            i.remove(e);
                        }
                    });
                }
            }
        }
        if (!i.length) {
            this.filtered = false;
        }
    },
    updateFilterFn: function() {
        var e = this.getFilters().items;
        this.filterFn = function(t) {
            var i = true, n = e.length, r;
            for (r = 0; r < n; r++) {
                var s = e[r], a = s.getFilterFn(), o = s.getScope() || this;
                i = i && a.call(o, t);
            }
            return i;
        };
        this.dirtyFilterFn = false;
        return this.filterFn;
    },
    filter: function(e) {
        return this.getFilters().length ? Ext.Array.filter(e, this.getFilterFn()) : e;
    },
    isFiltered: function(e) {
        return this.getFilters().length ? !this.getFilterFn()(e) : false;
    },
    getFilterFn: function() {
        if (this.dirtyFilterFn) {
            return this.updateFilterFn();
        }
        return this.filterFn;
    }
});

Ext.define("Ext.data.SortTypes", {
    singleton: true,
    stripTagsRE: /<\/?[^>]+>/gi,
    none: function(e) {
        return e;
    },
    asText: function(e) {
        return String(e).replace(this.stripTagsRE, "");
    },
    asUCText: function(e) {
        return String(e).toUpperCase().replace(this.stripTagsRE, "");
    },
    asUCString: function(e) {
        return String(e).toUpperCase();
    },
    asDate: function(e) {
        if (!e) {
            return 0;
        }
        if (Ext.isDate(e)) {
            return e.getTime();
        }
        return Date.parse(String(e));
    },
    asFloat: function(e) {
        e = parseFloat(String(e).replace(/,/g, ""));
        return isNaN(e) ? 0 : e;
    },
    asInt: function(e) {
        e = parseInt(String(e).replace(/,/g, ""), 10);
        return isNaN(e) ? 0 : e;
    }
});

Ext.define("Ext.util.Inflector", {
    singleton: true,
    plurals: [ [ /(quiz)$/i, "$1zes" ], [ /^(ox)$/i, "$1en" ], [ /([m|l])ouse$/i, "$1ice" ], [ /(matr|vert|ind)ix|ex$/i, "$1ices" ], [ /(x|ch|ss|sh)$/i, "$1es" ], [ /([^aeiouy]|qu)y$/i, "$1ies" ], [ /(hive)$/i, "$1s" ], [ /(?:([^f])fe|([lr])f)$/i, "$1$2ves" ], [ /sis$/i, "ses" ], [ /([ti])um$/i, "$1a" ], [ /(buffal|tomat|potat)o$/i, "$1oes" ], [ /(bu)s$/i, "$1ses" ], [ /(alias|status|sex)$/i, "$1es" ], [ /(octop|vir)us$/i, "$1i" ], [ /(ax|test)is$/i, "$1es" ], [ /^person$/, "people" ], [ /^man$/, "men" ], [ /^(child)$/, "$1ren" ], [ /s$/i, "s" ], [ /$/, "s" ] ],
    singulars: [ [ /(quiz)zes$/i, "$1" ], [ /(matr)ices$/i, "$1ix" ], [ /(vert|ind)ices$/i, "$1ex" ], [ /^(ox)en/i, "$1" ], [ /(alias|status)es$/i, "$1" ], [ /(octop|vir)i$/i, "$1us" ], [ /(cris|ax|test)es$/i, "$1is" ], [ /(shoe)s$/i, "$1" ], [ /(o)es$/i, "$1" ], [ /(bus)es$/i, "$1" ], [ /([m|l])ice$/i, "$1ouse" ], [ /(x|ch|ss|sh)es$/i, "$1" ], [ /(m)ovies$/i, "$1ovie" ], [ /(s)eries$/i, "$1eries" ], [ /([^aeiouy]|qu)ies$/i, "$1y" ], [ /([lr])ves$/i, "$1f" ], [ /(tive)s$/i, "$1" ], [ /(hive)s$/i, "$1" ], [ /([^f])ves$/i, "$1fe" ], [ /(^analy)ses$/i, "$1sis" ], [ /((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, "$1$2sis" ], [ /([ti])a$/i, "$1um" ], [ /(n)ews$/i, "$1ews" ], [ /people$/i, "person" ], [ /s$/i, "" ] ],
    uncountable: [ "sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means" ],
    singular: function(e, t) {
        this.singulars.unshift([ e, t ]);
    },
    plural: function(e, t) {
        this.plurals.unshift([ e, t ]);
    },
    clearSingulars: function() {
        this.singulars = [];
    },
    clearPlurals: function() {
        this.plurals = [];
    },
    isTransnumeral: function(e) {
        return Ext.Array.indexOf(this.uncountable, e) != -1;
    },
    pluralize: function(e) {
        if (this.isTransnumeral(e)) {
            return e;
        }
        var t = this.plurals, i = t.length, n, r, s;
        for (s = 0; s < i; s++) {
            n = t[s];
            r = n[0];
            if (r == e || r.test && r.test(e)) {
                return e.replace(r, n[1]);
            }
        }
        return e;
    },
    singularize: function(e) {
        if (this.isTransnumeral(e)) {
            return e;
        }
        var t = this.singulars, i = t.length, n, r, s;
        for (s = 0; s < i; s++) {
            n = t[s];
            r = n[0];
            if (r == e || r.test && r.test(e)) {
                return e.replace(r, n[1]);
            }
        }
        return e;
    },
    classify: function(e) {
        return Ext.String.capitalize(this.singularize(e));
    },
    ordinalize: function(e) {
        var t = parseInt(e, 10), i = t % 10, n = t % 100;
        if (11 <= n && n <= 13) {
            return e + "th";
        } else {
            switch (i) {
              case 1:
                return e + "st";

              case 2:
                return e + "nd";

              case 3:
                return e + "rd";

              default:
                return e + "th";
            }
        }
    }
}, function() {
    var e = {
        alumnus: "alumni",
        cactus: "cacti",
        focus: "foci",
        nucleus: "nuclei",
        radius: "radii",
        stimulus: "stimuli",
        ellipsis: "ellipses",
        paralysis: "paralyses",
        oasis: "oases",
        appendix: "appendices",
        index: "indexes",
        beau: "beaux",
        bureau: "bureaux",
        tableau: "tableaux",
        woman: "women",
        child: "children",
        man: "men",
        corpus: "corpora",
        criterion: "criteria",
        curriculum: "curricula",
        genus: "genera",
        memorandum: "memoranda",
        phenomenon: "phenomena",
        foot: "feet",
        goose: "geese",
        tooth: "teeth",
        antenna: "antennae",
        formula: "formulae",
        nebula: "nebulae",
        vertebra: "vertebrae",
        vita: "vitae"
    }, t;
    for (t in e) {
        this.plural(t, e[t]);
        this.singular(e[t], t);
    }
});

Ext.define("Ext.data.Error", {
    config: {
        field: null,
        message: ""
    },
    constructor: function(e) {
        this.initConfig(e);
    }
});

Ext.define("Ext.data.proxy.Client", {
    extend: "Ext.data.proxy.Proxy",
    alternateClassName: "Ext.proxy.ClientProxy",
    clear: function() {
        Ext.Logger.error("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.");
    }
});

Ext.define("Ext.plugin.PullRefresh", {
    extend: "Ext.Component",
    alias: "plugin.pullrefresh",
    requires: [ "Ext.DateExtras" ],
    config: {
        list: null,
        pullRefreshText: "Pull down to refresh...",
        releaseRefreshText: "Release to refresh...",
        lastUpdatedText: "Last Updated:",
        loadingText: "Loading...",
        snappingAnimationDuration: 150,
        refreshFn: null,
        pullTpl: [ '<div class="x-list-pullrefresh">', '<div class="x-list-pullrefresh-arrow"></div>', '<div class="x-loading-spinner">', '<span class="x-loading-top"></span>', '<span class="x-loading-right"></span>', '<span class="x-loading-bottom"></span>', '<span class="x-loading-left"></span>', "</div>", '<div class="x-list-pullrefresh-wrap">', '<h3 class="x-list-pullrefresh-message">{message}</h3>', '<div class="x-list-pullrefresh-updated">{lastUpdatedText}&nbsp;{lastUpdated:date("m/d/Y h:iA")}</div>', "</div>", "</div>" ].join(""),
        translatable: true
    },
    isRefreshing: false,
    currentViewState: "",
    initialize: function() {
        this.callParent();
        this.on({
            painted: "onPainted",
            scope: this
        });
    },
    init: function(e) {
        var t = this;
        t.setList(e);
        t.initScrollable();
    },
    initScrollable: function() {
        var e = this, t = e.getList(), i = t.getStore(), n = e.getPullTpl(), r = e.element, s = t.getScrollable(), a;
        if (!s) {
            return;
        }
        a = s.getScroller();
        e.lastUpdated = new Date();
        t.container.insert(0, e);
        if (i) {
            if (i.isAutoLoading()) {
                t.setLoadingText(null);
            } else {
                i.on({
                    load: {
                        single: true,
                        fn: function() {
                            t.setLoadingText(null);
                        }
                    }
                });
            }
        }
        n.overwrite(r, {
            message: e.getPullRefreshText(),
            lastUpdatedText: e.getLastUpdatedText(),
            lastUpdated: e.lastUpdated
        }, true);
        e.loadingElement = r.getFirstChild();
        e.messageEl = r.down(".x-list-pullrefresh-message");
        e.updatedEl = r.down(".x-list-pullrefresh-updated");
        e.maxScroller = a.getMaxPosition();
        a.on({
            maxpositionchange: e.setMaxScroller,
            scroll: e.onScrollChange,
            scope: e
        });
    },
    onScrollableChange: function() {
        this.initScrollable();
    },
    updateList: function(e, t) {
        var i = this;
        if (e && e != t) {
            e.on({
                order: "after",
                scrollablechange: i.onScrollableChange,
                scope: i
            });
        } else if (t) {
            t.un({
                order: "after",
                scrollablechange: i.onScrollableChange,
                scope: i
            });
        }
    },
    fetchLatest: function() {
        var e = this.getList().getStore(), t = e.getProxy(), i;
        i = Ext.create("Ext.data.Operation", {
            page: 1,
            start: 0,
            model: e.getModel(),
            limit: e.getPageSize(),
            action: "read",
            filters: e.getRemoteFilter() ? e.getFilters() : []
        });
        t.read(i, this.onLatestFetched, this);
    },
    onLatestFetched: function(e) {
        var t = this.getList().getStore(), i = t.getData(), n = e.getRecords(), r = n.length, s = [], a, o, l;
        for (l = 0; l < r; l++) {
            a = n[l];
            o = i.getByKey(a.getId());
            if (o) {
                o.set(a.getData());
            } else {
                s.push(a);
            }
            o = undefined;
        }
        t.insert(0, s);
    },
    onPainted: function() {
        this.pullHeight = this.loadingElement.getHeight();
    },
    setMaxScroller: function(e, t) {
        this.maxScroller = t;
    },
    onScrollChange: function(e, t, i) {
        if (i < 0) {
            this.onBounceTop(i);
        }
        if (i > this.maxScroller.y) {
            this.onBounceBottom(i);
        }
    },
    applyPullTpl: function(e) {
        return Ext.isObject(e) && e.isTemplate ? e : new Ext.XTemplate(e);
    },
    onBounceTop: function(e) {
        var t = this, i = t.pullHeight, n = t.getList(), r = n.getScrollable().getScroller();
        if (!t.isReleased) {
            if (!i) {
                t.onPainted();
                i = t.pullHeight;
            }
            if (!t.isRefreshing && -e >= i + 10) {
                t.isRefreshing = true;
                t.setViewState("release");
                r.getContainer().onBefore({
                    dragend: "onScrollerDragEnd",
                    single: true,
                    scope: t
                });
            } else if (t.isRefreshing && -e < i + 10) {
                t.isRefreshing = false;
                t.setViewState("pull");
            }
        }
        t.getTranslatable().translate(0, -e);
    },
    onScrollerDragEnd: function() {
        var e = this;
        if (e.isRefreshing) {
            var t = e.getList(), i = t.getScrollable().getScroller();
            i.minPosition.y = -e.pullHeight;
            i.on({
                scrollend: "loadStore",
                single: true,
                scope: e
            });
            e.isReleased = true;
        }
    },
    loadStore: function() {
        var e = this, t = e.getList(), i = t.getScrollable().getScroller();
        e.setViewState("loading");
        e.isReleased = false;
        Ext.defer(function() {
            i.on({
                scrollend: function() {
                    if (e.getRefreshFn()) {
                        e.getRefreshFn().call(e, e);
                    } else {
                        e.fetchLatest();
                    }
                    e.resetRefreshState();
                },
                delay: 100,
                single: true,
                scope: e
            });
            i.minPosition.y = 0;
            i.scrollTo(null, 0, true);
        }, 500, e);
    },
    onBounceBottom: Ext.emptyFn,
    setViewState: function(e) {
        var t = this, i = Ext.baseCSSPrefix, n = t.messageEl, r = t.loadingElement;
        if (e === t.currentViewState) {
            return t;
        }
        t.currentViewState = e;
        if (n && r) {
            switch (e) {
              case "pull":
                n.setHtml(t.getPullRefreshText());
                r.removeCls([ i + "list-pullrefresh-release", i + "list-pullrefresh-loading" ]);
                break;

              case "release":
                n.setHtml(t.getReleaseRefreshText());
                r.addCls(i + "list-pullrefresh-release");
                break;

              case "loading":
                n.setHtml(t.getLoadingText());
                r.addCls(i + "list-pullrefresh-loading");
                break;
            }
        }
        return t;
    },
    resetRefreshState: function() {
        var e = this;
        e.isRefreshing = false;
        e.lastUpdated = new Date();
        e.setViewState("pull");
        e.updatedEl.setHtml(this.getLastUpdatedText() + "&nbsp;" + Ext.util.Format.date(e.lastUpdated, "m/d/Y h:iA"));
    }
});

Ext.define("Ext.plugin.ListPaging", {
    extend: "Ext.Component",
    alias: "plugin.listpaging",
    config: {
        autoPaging: false,
        loadMoreText: "Load More...",
        noMoreRecordsText: "No More Records",
        loadTpl: [ '<div class="{cssPrefix}loading-spinner" style="font-size: 180%; margin: 10px auto;">', '<span class="{cssPrefix}loading-top"></span>', '<span class="{cssPrefix}loading-right"></span>', '<span class="{cssPrefix}loading-bottom"></span>', '<span class="{cssPrefix}loading-left"></span>', "</div>", '<div class="{cssPrefix}list-paging-msg">{message}</div>' ].join(""),
        loadMoreCmp: {
            xtype: "component",
            baseCls: Ext.baseCSSPrefix + "list-paging",
            scrollDock: "bottom",
            docked: "bottom",
            hidden: true
        },
        loadMoreCmpAdded: false,
        loadingCls: Ext.baseCSSPrefix + "loading",
        list: null,
        scroller: null,
        loading: false
    },
    init: function(e) {
        var t = e.getScrollable().getScroller(), i = e.getStore();
        this.setList(e);
        this.setScroller(t);
        this.bindStore(e.getStore());
        e.setScrollToTopOnRefresh(false);
        this.addLoadMoreCmp();
        if (i) {
            this.disableDataViewMask(i);
        }
        e.updateStore = Ext.Function.createInterceptor(e.updateStore, this.bindStore, this);
        if (this.getAutoPaging()) {
            t.on({
                scrollend: this.onScrollEnd,
                scope: this
            });
        }
    },
    bindStore: function(e, t) {
        if (t) {
            t.un({
                beforeload: this.onStoreBeforeLoad,
                load: this.onStoreLoad,
                scope: this
            });
        }
        if (e) {
            e.on({
                beforeload: this.onStoreBeforeLoad,
                load: this.onStoreLoad,
                scope: this
            });
        }
    },
    disableDataViewMask: function(e) {
        var t = this.getList();
        if (e.isAutoLoading()) {
            t.setLoadingText(null);
        } else {
            e.on({
                load: {
                    single: true,
                    fn: function() {
                        t.setLoadingText(null);
                    }
                }
            });
        }
    },
    applyLoadTpl: function(e) {
        return Ext.isObject(e) && e.isTemplate ? e : new Ext.XTemplate(e);
    },
    applyLoadMoreCmp: function(e) {
        e = Ext.merge(e, {
            html: this.getLoadTpl().apply({
                cssPrefix: Ext.baseCSSPrefix,
                message: this.getLoadMoreText()
            }),
            listeners: {
                tap: {
                    fn: this.loadNextPage,
                    scope: this,
                    element: "element"
                }
            }
        });
        return Ext.factory(e, Ext.Component, this.getLoadMoreCmp());
    },
    onScrollEnd: function(e, t, i) {
        if (!this.getLoading() && i >= e.maxPosition.y) {
            this.loadNextPage();
        }
    },
    updateLoading: function(e) {
        var t = this.getLoadMoreCmp(), i = this.getLoadingCls();
        if (e) {
            t.addCls(i);
        } else {
            t.removeCls(i);
        }
    },
    onStoreBeforeLoad: function(e) {
        if (e.getCount() === 0) {
            this.getLoadMoreCmp().hide();
        }
    },
    onStoreLoad: function(e) {
        var t = this.getLoadMoreCmp(), i = this.getLoadTpl(), n = this.storeFullyLoaded() ? this.getNoMoreRecordsText() : this.getLoadMoreText();
        if (e.getCount()) {
            t.show();
            this.getList().scrollDockHeightRefresh();
        }
        this.setLoading(false);
        t.setHtml(i.apply({
            cssPrefix: Ext.baseCSSPrefix,
            message: n
        }));
    },
    addLoadMoreCmp: function() {
        var e = this.getList(), t = this.getLoadMoreCmp();
        if (!this.getLoadMoreCmpAdded()) {
            e.add(t);
            e.fireEvent("loadmorecmpadded", this, e);
            this.setLoadMoreCmpAdded(true);
        }
        return t;
    },
    storeFullyLoaded: function() {
        var e = this.getList().getStore(), t = e.getTotalCount();
        return t !== null ? e.getTotalCount() <= e.currentPage * e.getPageSize() : false;
    },
    loadNextPage: function() {
        var e = this;
        if (!e.storeFullyLoaded()) {
            e.setLoading(true);
            e.getList().getStore().nextPage({
                addRecords: true
            });
        }
    }
});

Ext.define("Ext.util.HashMap", {
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    constructor: function(e) {
        this.callParent();
        this.mixins.observable.constructor.call(this);
        this.clear(true);
    },
    getCount: function() {
        return this.length;
    },
    getData: function(e, t) {
        if (t === undefined) {
            t = e;
            e = this.getKey(t);
        }
        return [ e, t ];
    },
    getKey: function(e) {
        return e.id;
    },
    add: function(e, t) {
        var i = this, n;
        if (i.containsKey(e)) {
            throw new Error("This key already exists in the HashMap");
        }
        n = this.getData(e, t);
        e = n[0];
        t = n[1];
        i.map[e] = t;
        ++i.length;
        i.fireEvent("add", i, e, t);
        return t;
    },
    replace: function(e, t) {
        var i = this, n = i.map, r;
        if (!i.containsKey(e)) {
            i.add(e, t);
        }
        r = n[e];
        n[e] = t;
        i.fireEvent("replace", i, e, t, r);
        return t;
    },
    remove: function(e) {
        var t = this.findKey(e);
        if (t !== undefined) {
            return this.removeByKey(t);
        }
        return false;
    },
    removeByKey: function(e) {
        var t = this, i;
        if (t.containsKey(e)) {
            i = t.map[e];
            delete t.map[e];
            --t.length;
            t.fireEvent("remove", t, e, i);
            return true;
        }
        return false;
    },
    get: function(e) {
        return this.map[e];
    },
    clear: function(e) {
        var t = this;
        t.map = {};
        t.length = 0;
        if (e !== true) {
            t.fireEvent("clear", t);
        }
        return t;
    },
    containsKey: function(e) {
        return this.map[e] !== undefined;
    },
    contains: function(e) {
        return this.containsKey(this.findKey(e));
    },
    getKeys: function() {
        return this.getArray(true);
    },
    getValues: function() {
        return this.getArray(false);
    },
    getArray: function(e) {
        var t = [], i, n = this.map;
        for (i in n) {
            if (n.hasOwnProperty(i)) {
                t.push(e ? i : n[i]);
            }
        }
        return t;
    },
    each: function(e, t) {
        var i = Ext.apply({}, this.map), n, r = this.length;
        t = t || this;
        for (n in i) {
            if (i.hasOwnProperty(n)) {
                if (e.call(t, n, i[n], r) === false) {
                    break;
                }
            }
        }
        return this;
    },
    clone: function() {
        var e = new Ext.util.HashMap(), t = this.map, i;
        e.suspendEvents();
        for (i in t) {
            if (t.hasOwnProperty(i)) {
                e.add(i, t[i]);
            }
        }
        e.resumeEvents();
        return e;
    },
    findKey: function(e) {
        var t, i = this.map;
        for (t in i) {
            if (i.hasOwnProperty(t) && i[t] === e) {
                return t;
            }
        }
        return undefined;
    }
});

Ext.define("Ext.data.Connection", {
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    statics: {
        requestId: 0
    },
    config: {
        url: null,
        async: true,
        method: null,
        username: "",
        password: "",
        disableCaching: true,
        disableCachingParam: "_dc",
        timeout: 3e4,
        extraParams: null,
        defaultHeaders: null,
        useDefaultHeader: true,
        defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8",
        useDefaultXhrHeader: true,
        defaultXhrHeader: "XMLHttpRequest",
        autoAbort: false
    },
    textAreaRe: /textarea/i,
    multiPartRe: /multipart\/form-data/i,
    lineBreakRe: /\r\n/g,
    constructor: function(e) {
        this.initConfig(e);
        this.requests = {};
    },
    request: function(e) {
        e = e || {};
        var t = this, i = e.scope || window, n = e.username || t.getUsername(), r = e.password || t.getPassword() || "", s, a, o, l, u;
        if (t.fireEvent("beforerequest", t, e) !== false) {
            a = t.setOptions(e, i);
            if (this.isFormUpload(e) === true) {
                this.upload(e.form, a.url, a.data, e);
                return null;
            }
            if (e.autoAbort === true || t.getAutoAbort()) {
                t.abort();
            }
            u = this.getXhrInstance();
            s = e.async !== false ? e.async || t.getAsync() : false;
            if (n) {
                u.open(a.method, a.url, s, n, r);
            } else {
                u.open(a.method, a.url, s);
            }
            l = t.setupHeaders(u, e, a.data, a.params);
            o = {
                id: ++Ext.data.Connection.requestId,
                xhr: u,
                headers: l,
                options: e,
                async: s,
                timeout: setTimeout(function() {
                    o.timedout = true;
                    t.abort(o);
                }, e.timeout || t.getTimeout())
            };
            t.requests[o.id] = o;
            if (s) {
                u.onreadystatechange = Ext.Function.bind(t.onStateChange, t, [ o ]);
            }
            u.send(a.data);
            if (!s) {
                return this.onComplete(o);
            }
            return o;
        } else {
            Ext.callback(e.callback, e.scope, [ e, undefined, undefined ]);
            return null;
        }
    },
    upload: function(e, t, i, n) {
        e = Ext.getDom(e);
        n = n || {};
        var r = Ext.id(), s = document.createElement("iframe"), a = [], o = "multipart/form-data", l = {
            target: e.target,
            method: e.method,
            encoding: e.encoding,
            enctype: e.enctype,
            action: e.action
        }, u = function(t, i) {
            c = document.createElement("input");
            Ext.fly(c).set({
                type: "hidden",
                value: i,
                name: t
            });
            e.appendChild(c);
            a.push(c);
        }, c;
        Ext.fly(s).set({
            id: r,
            name: r,
            cls: Ext.baseCSSPrefix + "hide-display",
            src: Ext.SSL_SECURE_URL
        });
        document.body.appendChild(s);
        if (document.frames) {
            document.frames[r].name = r;
        }
        Ext.fly(e).set({
            target: r,
            method: "POST",
            enctype: o,
            encoding: o,
            action: t || l.action
        });
        if (i) {
            Ext.iterate(Ext.Object.fromQueryString(i), function(e, t) {
                if (Ext.isArray(t)) {
                    Ext.each(t, function(t) {
                        u(e, t);
                    });
                } else {
                    u(e, t);
                }
            });
        }
        Ext.fly(s).on("load", Ext.Function.bind(this.onUploadComplete, this, [ s, n ]), null, {
            single: true
        });
        e.submit();
        Ext.fly(e).set(l);
        Ext.each(a, function(e) {
            Ext.removeNode(e);
        });
    },
    onUploadComplete: function(e, t) {
        var i = this, n = {
            responseText: "",
            responseXML: null
        }, r, s;
        try {
            r = e.contentWindow.document || e.contentDocument || window.frames[id].document;
            if (r) {
                if (r.body) {
                    if (this.textAreaRe.test((s = r.body.firstChild || {}).tagName)) {
                        n.responseText = s.value;
                    } else {
                        n.responseText = r.body.innerHTML;
                    }
                }
                n.responseXML = r.XMLDocument || r;
            }
        } catch (a) {}
        i.fireEvent("requestcomplete", i, n, t);
        Ext.callback(t.success, t.scope, [ n, t ]);
        Ext.callback(t.callback, t.scope, [ t, true, n ]);
        setTimeout(function() {
            Ext.removeNode(e);
        }, 100);
    },
    isFormUpload: function(e) {
        var t = this.getForm(e);
        if (t) {
            return e.isUpload || this.multiPartRe.test(t.getAttribute("enctype"));
        }
        return false;
    },
    getForm: function(e) {
        return Ext.getDom(e.form) || null;
    },
    setOptions: function(e, t) {
        var i = this, n = e.params || {}, r = i.getExtraParams(), s = e.urlParams, a = e.url || i.getUrl(), o = e.jsonData, l, u, c;
        if (Ext.isFunction(n)) {
            n = n.call(t, e);
        }
        if (Ext.isFunction(a)) {
            a = a.call(t, e);
        }
        a = this.setupUrl(e, a);
        if (!a) {
            Ext.Logger.error("No URL specified");
        }
        c = e.rawData || e.xmlData || o || null;
        if (o && !Ext.isPrimitive(o)) {
            c = Ext.encode(c);
        }
        if (Ext.isObject(n)) {
            n = Ext.Object.toQueryString(n);
        }
        if (Ext.isObject(r)) {
            r = Ext.Object.toQueryString(r);
        }
        n = n + (r ? (n ? "&" : "") + r : "");
        s = Ext.isObject(s) ? Ext.Object.toQueryString(s) : s;
        n = this.setupParams(e, n);
        l = (e.method || i.getMethod() || (n || c ? "POST" : "GET")).toUpperCase();
        this.setupMethod(e, l);
        u = e.disableCaching !== false ? e.disableCaching || i.getDisableCaching() : false;
        if (u) {
            a = Ext.urlAppend(a, (e.disableCachingParam || i.getDisableCachingParam()) + "=" + new Date().getTime());
        }
        if ((l == "GET" || c) && n) {
            a = Ext.urlAppend(a, n);
            n = null;
        }
        if (s) {
            a = Ext.urlAppend(a, s);
        }
        return {
            url: a,
            method: l,
            data: c || n || null
        };
    },
    setupUrl: function(e, t) {
        var i = this.getForm(e);
        if (i) {
            t = t || i.action;
        }
        return t;
    },
    setupParams: function(e, t) {
        var i = this.getForm(e), n;
        if (i && !this.isFormUpload(e)) {
            n = Ext.Element.serializeForm(i);
            t = t ? t + "&" + n : n;
        }
        return t;
    },
    setupMethod: function(e, t) {
        if (this.isFormUpload(e)) {
            return "POST";
        }
        return t;
    },
    setupHeaders: function(e, t, i, n) {
        var r = this, s = Ext.apply({}, t.headers || {}, r.getDefaultHeaders() || {}), a = r.getDefaultPostHeader(), o = t.jsonData, l = t.xmlData, u, c;
        if (!s["Content-Type"] && (i || n)) {
            if (i) {
                if (t.rawData) {
                    a = "text/plain";
                } else {
                    if (l && Ext.isDefined(l)) {
                        a = "text/xml";
                    } else if (o && Ext.isDefined(o)) {
                        a = "application/json";
                    }
                }
            }
            s["Content-Type"] = a;
        }
        if ((r.getUseDefaultXhrHeader() && t.useDefaultXhrHeader !== false || t.useDefaultXhrHeader) && !s["X-Requested-With"]) {
            s["X-Requested-With"] = r.getDefaultXhrHeader();
        }
        try {
            for (u in s) {
                if (s.hasOwnProperty(u)) {
                    c = s[u];
                    e.setRequestHeader(u, c);
                }
            }
        } catch (f) {
            r.fireEvent("exception", u, c);
        }
        if (t.withCredentials) {
            e.withCredentials = t.withCredentials;
        }
        return s;
    },
    getXhrInstance: function() {
        var e = [ function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
        }, function() {
            return new ActiveXObject("MSXML2.XMLHTTP");
        }, function() {
            return new ActiveXObject("Microsoft.XMLHTTP");
        } ], t = 0, i = e.length, n;
        for (;t < i; ++t) {
            try {
                n = e[t];
                n();
                break;
            } catch (r) {}
        }
        return n;
    }(),
    isLoading: function(e) {
        if (!(e && e.xhr)) {
            return false;
        }
        var t = e.xhr.readyState;
        return !(t === 0 || t == 4);
    },
    abort: function(e) {
        var t = this, i = t.requests, n;
        if (e && t.isLoading(e)) {
            e.xhr.onreadystatechange = null;
            e.xhr.abort();
            t.clearTimeout(e);
            if (!e.timedout) {
                e.aborted = true;
            }
            t.onComplete(e);
            t.cleanup(e);
        } else if (!e) {
            for (n in i) {
                if (i.hasOwnProperty(n)) {
                    t.abort(i[n]);
                }
            }
        }
    },
    abortAll: function() {
        this.abort();
    },
    onStateChange: function(e) {
        if (e.xhr.readyState == 4) {
            this.clearTimeout(e);
            this.onComplete(e);
            this.cleanup(e);
        }
    },
    clearTimeout: function(e) {
        clearTimeout(e.timeout);
        delete e.timeout;
    },
    cleanup: function(e) {
        e.xhr = null;
        delete e.xhr;
    },
    onComplete: function(e) {
        var t = this, i = e.options, n, r, s;
        try {
            n = t.parseStatus(e.xhr.status, e.xhr);
            if (e.timedout) {
                n.success = false;
            }
        } catch (a) {
            n = {
                success: false,
                isException: false
            };
        }
        r = n.success;
        if (r) {
            s = t.createResponse(e);
            t.fireEvent("requestcomplete", t, s, i);
            Ext.callback(i.success, i.scope, [ s, i ]);
        } else {
            if (n.isException || e.aborted || e.timedout) {
                s = t.createException(e);
            } else {
                s = t.createResponse(e);
            }
            t.fireEvent("requestexception", t, s, i);
            Ext.callback(i.failure, i.scope, [ s, i ]);
        }
        Ext.callback(i.callback, i.scope, [ i, r, s ]);
        delete t.requests[e.id];
        return s;
    },
    parseStatus: function(e, t) {
        e = e == 1223 ? 204 : e;
        var i = e >= 200 && e < 300 || e == 304 || e == 0 && t.responseText.length > 0, n = false;
        if (!i) {
            switch (e) {
              case 12002:
              case 12029:
              case 12030:
              case 12031:
              case 12152:
              case 13030:
                n = true;
                break;
            }
        }
        return {
            success: i,
            isException: n
        };
    },
    createResponse: function(e) {
        var t = e.xhr, i = {}, n, r, s, a, o, l;
        if (e.timedout || e.aborted) {
            e.success = false;
            n = [];
        } else {
            n = t.getAllResponseHeaders().replace(this.lineBreakRe, "\n").split("\n");
        }
        r = n.length;
        while (r--) {
            s = n[r];
            a = s.indexOf(":");
            if (a >= 0) {
                o = s.substr(0, a).toLowerCase();
                if (s.charAt(a + 1) == " ") {
                    ++a;
                }
                i[o] = s.substr(a + 1);
            }
        }
        e.xhr = null;
        delete e.xhr;
        l = {
            request: e,
            requestId: e.id,
            status: t.status,
            statusText: t.statusText,
            getResponseHeader: function(e) {
                return i[e.toLowerCase()];
            },
            getAllResponseHeaders: function() {
                return i;
            },
            responseText: t.responseText,
            responseXML: t.responseXML
        };
        t = null;
        return l;
    },
    createException: function(e) {
        return {
            request: e,
            requestId: e.id,
            status: e.aborted ? -1 : 0,
            statusText: e.aborted ? "transaction aborted" : "communication failure",
            aborted: e.aborted,
            timedout: e.timedout
        };
    }
});

Ext.define("Ext.Button", {
    extend: "Ext.Component",
    xtype: "button",
    cachedConfig: {
        pressedCls: Ext.baseCSSPrefix + "button-pressing",
        badgeCls: Ext.baseCSSPrefix + "badge",
        hasBadgeCls: Ext.baseCSSPrefix + "hasbadge",
        labelCls: Ext.baseCSSPrefix + "button-label",
        iconMaskCls: Ext.baseCSSPrefix + "icon-mask",
        iconCls: null
    },
    config: {
        badgeText: null,
        text: null,
        icon: null,
        iconAlign: "left",
        pressedDelay: 0,
        iconMask: null,
        handler: null,
        scope: null,
        autoEvent: null,
        ui: "normal",
        baseCls: Ext.baseCSSPrefix + "button"
    },
    template: [ {
        tag: "span",
        reference: "badgeElement",
        hidden: true
    }, {
        tag: "span",
        className: Ext.baseCSSPrefix + "button-icon",
        reference: "iconElement",
        hidden: true
    }, {
        tag: "span",
        reference: "textElement",
        hidden: true
    } ],
    initialize: function() {
        this.callParent();
        this.element.on({
            scope: this,
            tap: "onTap",
            touchstart: "onPress",
            touchend: "onRelease"
        });
    },
    updateBadgeText: function(e) {
        var t = this.element, i = this.badgeElement;
        if (e) {
            i.show();
            i.setText(e);
        } else {
            i.hide();
        }
        t[e ? "addCls" : "removeCls"](this.getHasBadgeCls());
    },
    updateText: function(e) {
        var t = this.textElement;
        if (t) {
            if (e) {
                t.show();
                t.setHtml(e);
            } else {
                t.hide();
            }
        }
    },
    updateHtml: function(e) {
        var t = this.textElement;
        if (e) {
            t.show();
            t.setHtml(e);
        } else {
            t.hide();
        }
    },
    updateBadgeCls: function(e, t) {
        this.badgeElement.replaceCls(t, e);
    },
    updateHasBadgeCls: function(e, t) {
        var i = this.element;
        if (i.hasCls(t)) {
            i.replaceCls(t, e);
        }
    },
    updateLabelCls: function(e, t) {
        this.textElement.replaceCls(t, e);
    },
    updatePressedCls: function(e, t) {
        var i = this.element;
        if (i.hasCls(t)) {
            i.replaceCls(t, e);
        }
    },
    updateIcon: function(e) {
        var t = this, i = t.iconElement;
        if (e) {
            t.showIconElement();
            i.setStyle("background-image", "url(" + e + ")");
            t.refreshIconAlign();
            t.refreshIconMask();
        } else {
            i.setStyle("background-image", "");
            t.hideIconElement();
            t.setIconAlign(false);
        }
    },
    updateIconCls: function(e, t) {
        var i = this, n = i.iconElement;
        if (e) {
            i.showIconElement();
            n.replaceCls(t, e);
            i.refreshIconAlign();
            i.refreshIconMask();
        } else {
            n.removeCls(t);
            i.hideIconElement();
            i.setIconAlign(false);
        }
    },
    updateIconAlign: function(e, t) {
        var i = this.element, n = Ext.baseCSSPrefix + "iconalign-";
        if (!this.getText()) {
            e = "center";
        }
        i.removeCls(n + "center");
        i.removeCls(n + t);
        if (this.getIcon() || this.getIconCls()) {
            i.addCls(n + e);
        }
    },
    refreshIconAlign: function() {
        this.updateIconAlign(this.getIconAlign());
    },
    updateIconMaskCls: function(e, t) {
        var i = this.iconElement;
        if (this.getIconMask()) {
            i.replaceCls(t, e);
        }
    },
    updateIconMask: function(e) {
        this.iconElement[e ? "addCls" : "removeCls"](this.getIconMaskCls());
    },
    refreshIconMask: function() {
        this.updateIconMask(this.getIconMask());
    },
    applyAutoEvent: function(e) {
        var t = this;
        if (typeof e == "string") {
            e = {
                name: e,
                scope: t.scope || t
            };
        }
        return e;
    },
    updateAutoEvent: function(e) {
        var t = e.name, i = e.scope;
        this.setHandler(function() {
            i.fireEvent(t, i, this);
        });
        this.setScope(i);
    },
    hideIconElement: function() {
        this.iconElement.hide();
    },
    showIconElement: function() {
        this.iconElement.show();
    },
    applyUi: function(e) {
        if (e && Ext.isString(e)) {
            var t = e.split("-");
            if (t && (t[1] == "back" || t[1] == "forward")) {
                return t;
            }
        }
        return e;
    },
    getUi: function() {
        var e = this._ui;
        if (Ext.isArray(e)) {
            return e.join("-");
        }
        return e;
    },
    applyPressedDelay: function(e) {
        if (Ext.isNumber(e)) {
            return e;
        }
        return e ? 100 : 0;
    },
    onPress: function() {
        var e = this, t = e.element, i = e.getPressedDelay(), n = e.getPressedCls();
        if (!e.getDisabled()) {
            if (i > 0) {
                e.pressedTimeout = setTimeout(function() {
                    delete e.pressedTimeout;
                    if (t) {
                        t.addCls(n);
                    }
                }, i);
            } else {
                t.addCls(n);
            }
        }
    },
    onRelease: function(e) {
        this.fireAction("release", [ this, e ], "doRelease");
    },
    doRelease: function(e, t) {
        if (!e.getDisabled()) {
            if (e.hasOwnProperty("pressedTimeout")) {
                clearTimeout(e.pressedTimeout);
                delete e.pressedTimeout;
            } else {
                e.element.removeCls(e.getPressedCls());
            }
        }
    },
    onTap: function(e) {
        if (this.getDisabled()) {
            return false;
        }
        this.fireAction("tap", [ this, e ], "doTap");
    },
    doTap: function(e, t) {
        var i = e.getHandler(), n = e.getScope() || e;
        if (!i) {
            return;
        }
        if (typeof i == "string") {
            i = n[i];
        }
        if (t && t.preventDefault) {
            t.preventDefault();
        }
        i.apply(n, arguments);
    }
}, function() {
    Ext.deprecateClassMethod(this, "setBadge", "setBadgeText");
    Ext.deprecateClassMethod(this, "setIconClass", "setIconCls");
    this.override({
        constructor: function(e) {
            if (e) {
                if (e.hasOwnProperty("badge")) {
                    Ext.Logger.deprecate("'badge' config is deprecated, please use 'badgeText' config instead", this);
                    e.badgeText = e.badge;
                    delete e.badge;
                }
            }
            this.callParent([ e ]);
        }
    });
});

Ext.define("Ext.Title", {
    extend: "Ext.Component",
    xtype: "title",
    config: {
        baseCls: "x-title",
        title: ""
    },
    updateTitle: function(e) {
        this.setHtml(e);
    }
});

Ext.define("Ext.Spacer", {
    extend: "Ext.Component",
    alias: "widget.spacer",
    config: {},
    constructor: function(e) {
        e = e || {};
        if (!e.width) {
            e.flex = 1;
        }
        this.callParent([ e ]);
    }
});

Ext.define("Ext.mixin.Selectable", {
    extend: "Ext.mixin.Mixin",
    mixinConfig: {
        id: "selectable",
        hooks: {
            updateStore: "updateStore"
        }
    },
    config: {
        disableSelection: null,
        mode: "SINGLE",
        allowDeselect: false,
        lastSelected: null,
        lastFocused: null,
        deselectOnContainerClick: true
    },
    modes: {
        SINGLE: true,
        SIMPLE: true,
        MULTI: true
    },
    selectableEventHooks: {
        addrecords: "onSelectionStoreAdd",
        removerecords: "onSelectionStoreRemove",
        updaterecord: "onSelectionStoreUpdate",
        load: "refreshSelection",
        refresh: "refreshSelection"
    },
    constructor: function() {
        this.selected = new Ext.util.MixedCollection();
        this.callParent(arguments);
    },
    applyMode: function(e) {
        e = e ? e.toUpperCase() : "SINGLE";
        return this.modes[e] ? e : "SINGLE";
    },
    updateStore: function(e, t) {
        var i = this, n = Ext.apply({}, i.selectableEventHooks, {
            scope: i
        });
        if (t && Ext.isObject(t) && t.isStore) {
            if (t.autoDestroy) {
                t.destroy();
            } else {
                t.un(n);
                if (e) {
                    e.un("clear", "onSelectionStoreClear", this);
                }
            }
        }
        if (e) {
            e.on(n);
            e.onBefore("clear", "onSelectionStoreClear", this);
            i.refreshSelection();
        }
    },
    selectAll: function(e) {
        var t = this, i = t.getStore().getRange(), n = i.length, r = 0;
        for (;r < n; r++) {
            t.select(i[r], true, e);
        }
    },
    deselectAll: function(e) {
        var t = this, i = t.getStore().getRange();
        t.deselect(i, e);
        t.selected.clear();
        t.setLastSelected(null);
        t.setLastFocused(null);
    },
    selectWithEvent: function(e) {
        var t = this, i = t.isSelected(e);
        switch (t.getMode()) {
          case "MULTI":
          case "SIMPLE":
            if (i) {
                t.deselect(e);
            } else {
                t.select(e, true);
            }
            break;

          case "SINGLE":
            if (t.getAllowDeselect() && i) {
                t.deselect(e);
            } else {
                t.select(e, false);
            }
            break;
        }
    },
    selectRange: function(e, t, i) {
        var n = this, r = n.getStore(), s = [], a, o;
        if (n.getDisableSelection()) {
            return;
        }
        if (e > t) {
            a = t;
            t = e;
            e = a;
        }
        for (o = e; o <= t; o++) {
            s.push(r.getAt(o));
        }
        this.doMultiSelect(s, i);
    },
    select: function(e, t, i) {
        var n = this, r;
        if (n.getDisableSelection()) {
            return;
        }
        if (typeof e === "number") {
            e = [ n.getStore().getAt(e) ];
        }
        if (!e) {
            return;
        }
        if (n.getMode() == "SINGLE" && e) {
            r = e.length ? e[0] : e;
            n.doSingleSelect(r, i);
        } else {
            n.doMultiSelect(e, t, i);
        }
    },
    doSingleSelect: function(e, t) {
        var i = this, n = i.selected;
        if (i.getDisableSelection()) {
            return;
        }
        if (i.isSelected(e)) {
            return;
        }
        if (n.getCount() > 0) {
            i.deselect(i.getLastSelected(), t);
        }
        n.add(e);
        i.setLastSelected(e);
        i.onItemSelect(e, t);
        i.setLastFocused(e);
        if (!t) {
            i.fireSelectionChange([ e ]);
        }
    },
    doMultiSelect: function(e, t, i) {
        if (e === null || this.getDisableSelection()) {
            return;
        }
        e = !Ext.isArray(e) ? [ e ] : e;
        var n = this, r = n.selected, s = e.length, a = false, o = 0, l;
        if (!t && r.getCount() > 0) {
            a = true;
            n.deselect(n.getSelection(), true);
        }
        for (;o < s; o++) {
            l = e[o];
            if (t && n.isSelected(l)) {
                continue;
            }
            a = true;
            n.setLastSelected(l);
            r.add(l);
            if (!i) {
                n.setLastFocused(l);
            }
            n.onItemSelect(l, i);
        }
        if (a && !i) {
            this.fireSelectionChange(e);
        }
    },
    deselect: function(e, t) {
        var i = this;
        if (i.getDisableSelection()) {
            return;
        }
        e = Ext.isArray(e) ? e : [ e ];
        var n = i.selected, r = false, s = 0, a = i.getStore(), o = e.length, l;
        for (;s < o; s++) {
            l = e[s];
            if (typeof l === "number") {
                l = a.getAt(l);
            }
            if (n.remove(l)) {
                if (i.getLastSelected() == l) {
                    i.setLastSelected(n.last());
                }
                r = true;
            }
            if (l) {
                i.onItemDeselect(l, t);
            }
        }
        if (r && !t) {
            i.fireSelectionChange(e);
        }
    },
    updateLastFocused: function(e, t) {
        this.onLastFocusChanged(t, e);
    },
    fireSelectionChange: function(e) {
        var t = this;
        t.fireAction("beforeselectionchange", [ t ], function() {
            t.fireAction("selectionchange", [ t, e ], "getSelection");
        });
    },
    getSelection: function() {
        return this.selected.getRange();
    },
    isSelected: function(e) {
        e = Ext.isNumber(e) ? this.getStore().getAt(e) : e;
        return this.selected.indexOf(e) !== -1;
    },
    hasSelection: function() {
        return this.selected.getCount() > 0;
    },
    refreshSelection: function() {
        var e = this, t = e.getSelection();
        e.deselectAll(true);
        if (t.length) {
            e.select(t, false, true);
        }
    },
    onSelectionStoreRemove: function(e, t) {
        var i = this, n = i.selected, r = t.length, s, a;
        if (i.getDisableSelection()) {
            return;
        }
        for (a = 0; a < r; a++) {
            s = t[a];
            if (n.remove(s)) {
                if (i.getLastSelected() == s) {
                    i.setLastSelected(null);
                }
                if (i.getLastFocused() == s) {
                    i.setLastFocused(null);
                }
                i.fireSelectionChange([ s ]);
            }
        }
    },
    onSelectionStoreClear: function(e) {
        var t = e.getData().items;
        this.onSelectionStoreRemove(e, t);
    },
    getSelectionCount: function() {
        return this.selected.getCount();
    },
    onSelectionStoreAdd: Ext.emptyFn,
    onSelectionStoreUpdate: Ext.emptyFn,
    onItemSelect: Ext.emptyFn,
    onItemDeselect: Ext.emptyFn,
    onLastFocusChanged: Ext.emptyFn,
    onEditorKey: Ext.emptyFn
}, function() {});

Ext.define("Ext.dataview.element.Container", {
    extend: "Ext.Component",
    doInitialize: function() {
        this.element.on({
            touchstart: "onItemTouchStart",
            touchend: "onItemTouchEnd",
            tap: "onItemTap",
            taphold: "onItemTapHold",
            touchmove: "onItemTouchMove",
            singletap: "onItemSingleTap",
            doubletap: "onItemDoubleTap",
            swipe: "onItemSwipe",
            delegate: "> div",
            scope: this
        });
    },
    initialize: function() {
        this.callParent();
        this.doInitialize();
    },
    updateBaseCls: function(e, t) {
        var i = this;
        i.callParent([ e + "-container", t ]);
    },
    onItemTouchStart: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        Ext.get(i).on({
            touchmove: "onItemTouchMove",
            scope: t,
            single: true
        });
        t.fireEvent("itemtouchstart", t, Ext.get(i), n, e);
    },
    onItemTouchEnd: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        Ext.get(i).un({
            touchmove: "onItemTouchMove",
            scope: t
        });
        t.fireEvent("itemtouchend", t, Ext.get(i), n, e);
    },
    onItemTouchMove: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemtouchmove", t, Ext.get(i), n, e);
    },
    onItemTap: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemtap", t, Ext.get(i), n, e);
    },
    onItemTapHold: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemtaphold", t, Ext.get(i), n, e);
    },
    onItemDoubleTap: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemdoubletap", t, Ext.get(i), n, e);
    },
    onItemSingleTap: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemsingletap", t, Ext.get(i), n, e);
    },
    onItemSwipe: function(e) {
        var t = this, i = e.getTarget(), n = t.getViewItems().indexOf(i);
        t.fireEvent("itemswipe", t, Ext.get(i), n, e);
    },
    updateListItem: function(e, t) {
        var i = this, n = i.dataview, r = n.getStore(), s = r.indexOf(e), a = n.prepareData(e.getData(true), s, e);
        a.xcount = r.getCount();
        a.xindex = typeof a.xindex === "number" ? a.xindex : s;
        t.innerHTML = n.getItemTpl().apply(a);
    },
    addListItem: function(e, t) {
        var i = this, n = i.dataview, r = n.getStore(), s = n.prepareData(t.getData(true), e, t), a = i.element, o = a.dom.childNodes, l = o.length, u;
        s.xcount = typeof s.xcount === "number" ? s.xcount : r.getCount();
        s.xindex = typeof s.xindex === "number" ? s.xindex : e;
        u = Ext.Element.create(this.getItemElementConfig(e, s));
        if (!l || e == l) {
            u.appendTo(a);
        } else {
            u.insertBefore(o[e]);
        }
    },
    getItemElementConfig: function(e, t) {
        var i = this.dataview, n = i.getItemCls(), r = i.getBaseCls() + "-item";
        if (n) {
            r += " " + n;
        }
        return {
            cls: r,
            html: i.getItemTpl().apply(t)
        };
    },
    doRemoveItemCls: function(e) {
        var t = this.getViewItems(), i = t.length, n = 0;
        for (;n < i; n++) {
            Ext.fly(t[n]).removeCls(e);
        }
    },
    doAddItemCls: function(e) {
        var t = this.getViewItems(), i = t.length, n = 0;
        for (;n < i; n++) {
            Ext.fly(t[n]).addCls(e);
        }
    },
    moveItemsToCache: function(e, t) {
        var i = this, n = i.getViewItems(), r = t - e, s;
        for (;r >= 0; r--) {
            s = n[e + r];
            Ext.get(s).destroy();
        }
        if (i.getViewItems().length == 0) {
            this.dataview.showEmptyText();
        }
    },
    moveItemsFromCache: function(e) {
        var t = this, i = t.dataview, n = i.getStore(), r = e.length, s, a;
        if (r) {
            i.hideEmptyText();
        }
        for (s = 0; s < r; s++) {
            e[s]._tmpIndex = n.indexOf(e[s]);
        }
        Ext.Array.sort(e, function(e, t) {
            return e._tmpIndex > t._tmpIndex ? 1 : -1;
        });
        for (s = 0; s < r; s++) {
            a = e[s];
            t.addListItem(a._tmpIndex, a);
            delete a._tmpIndex;
        }
    },
    getViewItems: function() {
        return Array.prototype.slice.call(this.element.dom.childNodes);
    },
    updateAtNewIndex: function(e, t, i) {
        this.moveItemsToCache(e, e);
        this.moveItemsFromCache([ i ]);
    },
    destroy: function() {
        var e = this.getViewItems(), t = e.length, i = 0;
        for (;i < t; i++) {
            Ext.get(e[i]).destroy();
        }
        this.callParent();
    }
});

Ext.define("Ext.dataview.component.DataItem", {
    extend: "Ext.Container",
    xtype: "dataitem",
    config: {
        baseCls: Ext.baseCSSPrefix + "data-item",
        defaultType: "component",
        record: null,
        itemCls: null,
        dataMap: {},
        dataview: null,
        items: [ {
            xtype: "component"
        } ]
    },
    updateBaseCls: function(e, t) {
        var i = this;
        i.callParent(arguments);
    },
    updateItemCls: function(e, t) {
        if (t) {
            this.removeCls(t);
        }
        if (e) {
            this.addCls(e);
        }
    },
    doMapData: function(e, t, i) {
        var n, r, s, a;
        for (n in e) {
            s = e[n];
            r = this[n]();
            if (r) {
                for (a in s) {
                    if (t && r[a] && t[s[a]] !== undefined && t[s[a]] !== null) {
                        r[a](t[s[a]]);
                    }
                }
            }
        }
        if (i) {
            i.updateData(t);
        }
    },
    updateRecord: function(e) {
        if (!e) {
            return;
        }
        this._record = e;
        var t = this, i = t.dataview || this.getDataview(), n = i.prepareData(e.getData(true), i.getStore().indexOf(e), e), r = t.getItems(), s = r.first(), a = t.getDataMap();
        if (!s) {
            return;
        }
        if (a) {
            this.doMapData(a, n, s);
        }
        t.fireEvent("updatedata", t, n);
    }
});

Ext.define("Ext.dataview.IndexBar", {
    extend: "Ext.Component",
    alternateClassName: "Ext.IndexBar",
    config: {
        baseCls: Ext.baseCSSPrefix + "indexbar",
        direction: "vertical",
        letters: [ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ],
        ui: "alphabet",
        listPrefix: null
    },
    itemCls: Ext.baseCSSPrefix + "",
    updateDirection: function(e, t) {
        var i = this.getBaseCls();
        this.element.replaceCls(i + "-" + t, i + "-" + e);
    },
    getElementConfig: function() {
        return {
            reference: "wrapper",
            classList: [ "x-centered", "x-indexbar-wrapper" ],
            children: [ this.callParent() ]
        };
    },
    updateLetters: function(e) {
        this.innerElement.setHtml("");
        if (e) {
            var t = e.length, i;
            for (i = 0; i < t; i++) {
                this.innerElement.createChild({
                    html: e[i]
                });
            }
        }
    },
    updateListPrefix: function(e) {
        if (e && e.length) {
            this.innerElement.createChild({
                html: e
            }, 0);
        }
    },
    initialize: function() {
        this.callParent();
        this.innerElement.on({
            touchstart: this.onTouchStart,
            touchend: this.onTouchEnd,
            touchmove: this.onTouchMove,
            scope: this
        });
    },
    onTouchStart: function(e, t) {
        e.stopPropagation();
        this.innerElement.addCls(this.getBaseCls() + "-pressed");
        this.pageBox = this.innerElement.getPageBox();
        this.onTouchMove(e);
    },
    onTouchEnd: function(e, t) {
        this.innerElement.removeCls(this.getBaseCls() + "-pressed");
    },
    onTouchMove: function(e) {
        var t = Ext.util.Point.fromEvent(e), i, n = this.pageBox;
        if (!n) {
            n = this.pageBox = this.el.getPageBox();
        }
        if (this.getDirection() === "vertical") {
            if (t.y > n.bottom || t.y < n.top) {
                return;
            }
            i = Ext.Element.fromPoint(n.left + n.width / 2, t.y);
        } else {
            if (t.x > n.right || t.x < n.left) {
                return;
            }
            i = Ext.Element.fromPoint(t.x, n.top + n.height / 2);
        }
        if (i) {
            this.fireEvent("index", this, i.dom.innerHTML, i);
        }
    },
    destroy: function() {
        var e = this, t = Array.prototype.slice.call(e.innerElement.dom.childNodes), i = t.length, n = 0;
        for (;n < i; n++) {
            Ext.removeNode(t[n]);
        }
        this.callParent();
    }
}, function() {
    Ext.deprecateMethod(this, "isHorizontal", null, "Ext.dataview.IndexBar.isHorizontal() has been removed");
    Ext.deprecateMethod(this, "isVertical", null, "Ext.dataview.IndexBar.isVertical() has been removed");
    Ext.deprecateMethod(this, "refresh", null, "Ext.dataview.IndexBar.refresh() has been removed");
    Ext.deprecateProperty(this, "alphabet", null, "Ext.dataview.IndexBar.alphabet has been removed");
    Ext.deprecateProperty(this, "itemSelector", null, "Ext.dataview.IndexBar.itemSelector has been removed");
    Ext.deprecateProperty(this, "store", null, "Ext.dataview.IndexBar.store has been removed");
});

Ext.define("Ext.dataview.ListItemHeader", {
    extend: "Ext.Component",
    xtype: "listitemheader",
    config: {
        baseCls: Ext.baseCSSPrefix + "list-header",
        docked: "top"
    }
});

Ext.define("Ext.dataview.component.ListItem", {
    extend: "Ext.dataview.component.DataItem",
    xtype: "listitem",
    config: {
        baseCls: Ext.baseCSSPrefix + "list-item",
        dataMap: null,
        body: {
            xtype: "component",
            cls: "x-list-item-body"
        },
        disclosure: {
            xtype: "component",
            cls: "x-list-disclosure",
            hidden: true,
            docked: "right"
        },
        header: {
            xtype: "component",
            cls: "x-list-header",
            html: " ",
            hidden: true
        },
        tpl: null,
        items: null
    },
    applyBody: function(e) {
        if (e && !e.isComponent) {
            e = Ext.factory(e, Ext.Component, this.getBody());
        }
        return e;
    },
    updateBody: function(e, t) {
        if (e) {
            this.add(e);
        } else if (t) {
            t.destroy();
        }
    },
    applyHeader: function(e) {
        if (e && !e.isComponent) {
            e = Ext.factory(e, Ext.Component, this.getHeader());
        }
        return e;
    },
    updateHeader: function(e, t) {
        if (e) {
            this.element.getFirstChild().insertFirst(e.element);
        } else if (t) {
            t.destroy();
        }
    },
    applyDisclosure: function(e) {
        if (e && !e.isComponent) {
            e = Ext.factory(e, Ext.Component, this.getDisclosure());
        }
        return e;
    },
    updateDisclosure: function(e, t) {
        if (e) {
            this.add(e);
        } else if (t) {
            t.destroy();
        }
    },
    updateTpl: function(e) {
        this.getBody().setTpl(e);
    },
    updateRecord: function(e) {
        var t = this, i = t.dataview || this.getDataview(), n = e && i.prepareData(e.getData(true), i.getStore().indexOf(e), e), r = t.getDataMap(), s = this.getBody(), a = this.getDisclosure();
        t._record = e;
        if (r) {
            t.doMapData(r, n, s);
        } else if (s) {
            s.updateData(n || null);
        }
        if (a && e && i.getOnItemDisclosure()) {
            var o = i.getDisclosureProperty();
            a[n.hasOwnProperty(o) && n[o] === false ? "hide" : "show"]();
        }
        t.fireEvent("updatedata", t, n);
    },
    destroy: function() {
        Ext.destroy(this.getHeader());
        this.callParent(arguments);
    }
});

Ext.define("Ext.util.TranslatableList", {
    extend: "Ext.util.translatable.Abstract",
    config: {
        items: []
    },
    applyItems: function(e) {
        return Ext.Array.from(e);
    },
    doTranslate: function(e, t) {
        var i = this.getItems(), n = 0, r, s, a, o;
        for (r = 0, s = i.length; r < s; r++) {
            a = i[r];
            if (a && !a._list_hidden) {
                o = t + n;
                n += a.$height;
                a.translate(0, o);
            }
        }
    }
});

Ext.define("Ext.util.PositionMap", {
    config: {
        minimumHeight: 50
    },
    constructor: function(e) {
        this.map = [];
        this.adjustments = {};
        this.offset = 0;
        this.initConfig(e);
    },
    populate: function(e, t) {
        var i = this.map = this.map || [], n = this.getMinimumHeight(), r, s, a;
        e++;
        i.length = e;
        i[0] = 0;
        for (r = t + 1, a = e - 1; r <= a; r++) {
            s = r - 1;
            i[r] = i[s] + n;
        }
        this.adjustments = {
            indices: [],
            heights: {}
        };
        this.offset = 0;
        for (r = 1, a = e - 1; r <= a; r++) {
            s = r - 1;
            this.offset += i[r] - i[s] - n;
        }
    },
    setItemHeight: function(e, t) {
        t = Math.max(t, this.getMinimumHeight());
        if (t !== this.getItemHeight(e)) {
            var i = this.adjustments;
            i.indices.push(parseInt(e, 10));
            i.heights[e] = t;
        }
    },
    update: function() {
        var e = this.adjustments, t = e.indices, i = e.heights, n = this.map, r = t.length, s = this.getMinimumHeight(), a = 0, o, l, u, c, f, d;
        if (!e.indices.length) {
            return false;
        }
        Ext.Array.sort(t, function(e, t) {
            return e - t;
        });
        for (o = 0; o < r; o++) {
            c = t[o];
            f = t[o + 1] || n.length - 1;
            d = n[c + 1] !== undefined ? n[c + 1] - n[c] + a : s;
            u = i[c];
            a += u - d;
            for (l = c + 1; l <= f; l++) {
                n[l] += a;
            }
        }
        this.offset += a;
        this.adjustments = {
            indices: [],
            heights: {}
        };
        return true;
    },
    getItemHeight: function(e) {
        return this.map[e + 1] - this.map[e];
    },
    getTotalHeight: function() {
        return (this.map.length - 1) * this.getMinimumHeight() + this.offset;
    },
    findIndex: function(e) {
        return this.map.length ? this.binarySearch(this.map, e) : 0;
    },
    binarySearch: function(e, t) {
        var i = 0, n = e.length;
        if (t < e[0]) {
            return 0;
        }
        if (t > e[n - 1]) {
            return n - 1;
        }
        while (i + 1 < n) {
            var r = i + n >> 1, s = e[r];
            if (s == t) {
                return r;
            } else if (s < t) {
                i = r;
            } else {
                n = r;
            }
        }
        return i;
    }
});

Ext.define("Twitter.view.TweetListItemText", {
    extend: "Ext.Component",
    applyHtml: function(e) {
        e = e.replace(/(http:\/\/[^\s]*)/g, '<a class="link" target="_blank" href="$1">$1</a>');
        e = e.replace(/(^|\s)@(\w+)/g, '$1<span class="username">@$2</span>');
        e = e.replace(/(^|\s)#(\w+)/g, '$1<span class="hashtag">#$2</span>');
        return e;
    }
});

Ext.define("Ext.Img", {
    extend: "Ext.Component",
    xtype: [ "image", "img" ],
    config: {
        src: null,
        baseCls: Ext.baseCSSPrefix + "img",
        imageCls: Ext.baseCSSPrefix + "img-image",
        backgroundCls: Ext.baseCSSPrefix + "img-background",
        mode: "background"
    },
    beforeInitialize: function() {
        var e = this;
        e.onLoad = Ext.Function.bind(e.onLoad, e);
        e.onError = Ext.Function.bind(e.onError, e);
    },
    initialize: function() {
        var e = this;
        e.callParent();
        e.relayEvents(e.renderElement, "*");
        e.element.on({
            tap: "onTap",
            scope: e
        });
    },
    hide: function() {
        this.callParent();
        this.hiddenSrc = this.hiddenSrc || this.getSrc();
        this.setSrc(null);
    },
    show: function() {
        this.callParent();
        if (this.hiddenSrc) {
            this.setSrc(this.hiddenSrc);
            delete this.hiddenSrc;
        }
    },
    updateMode: function(e) {
        var t = this, i = t.getImageCls(), n = t.getBackgroundCls();
        if (e === "background") {
            if (t.imageElement) {
                t.imageElement.destroy();
                delete t.imageElement;
                t.updateSrc(t.getSrc());
            }
            t.replaceCls(i, n);
        } else {
            t.imageElement = t.element.createChild({
                tag: "img"
            });
            t.replaceCls(n, i);
        }
    },
    updateImageCls: function(e, t) {
        this.replaceCls(t, e);
    },
    updateBackgroundCls: function(e, t) {
        this.replaceCls(t, e);
    },
    onTap: function(e) {
        this.fireEvent("tap", this, e);
    },
    onAfterRender: function() {
        this.updateSrc(this.getSrc());
    },
    updateSrc: function(e) {
        var t = this, i;
        if (t.getMode() === "background") {
            i = this.imageObject || new Image();
        } else {
            i = t.imageElement.dom;
        }
        this.imageObject = i;
        i.setAttribute("src", Ext.isString(e) ? e : "");
        i.addEventListener("load", t.onLoad, false);
        i.addEventListener("error", t.onError, false);
    },
    detachListeners: function() {
        var e = this.imageObject;
        if (e) {
            e.removeEventListener("load", this.onLoad, false);
            e.removeEventListener("error", this.onError, false);
        }
    },
    onLoad: function(e) {
        this.detachListeners();
        if (this.getMode() === "background") {
            this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
        }
        this.fireEvent("load", this, e);
    },
    onError: function(e) {
        this.detachListeners();
        this.fireEvent("error", this, e);
    },
    doSetWidth: function(e) {
        var t = this.getMode() === "background" ? this.element : this.imageElement;
        t.setWidth(e);
        this.callParent(arguments);
    },
    doSetHeight: function(e) {
        var t = this.getMode() === "background" ? this.element : this.imageElement;
        t.setHeight(e);
        this.callParent(arguments);
    },
    destroy: function() {
        this.detachListeners();
        Ext.destroy(this.imageObject, this.imageElement);
        delete this.imageObject;
        delete this.imageElement;
        this.callParent();
    }
});

Ext.define("Ext.Decorator", {
    extend: "Ext.Component",
    isDecorator: true,
    config: {
        component: {}
    },
    statics: {
        generateProxySetter: function(e) {
            return function(t) {
                var i = this.getComponent();
                i[e].call(i, t);
                return this;
            };
        },
        generateProxyGetter: function(e) {
            return function() {
                var t = this.getComponent();
                return t[e].call(t);
            };
        }
    },
    onClassExtended: function(e, t) {
        if (!t.hasOwnProperty("proxyConfig")) {
            return;
        }
        var i = Ext.Class, n = t.proxyConfig, r = t.config;
        t.config = r ? Ext.applyIf(r, n) : n;
        var s, a, o, l;
        for (s in n) {
            if (n.hasOwnProperty(s)) {
                a = i.getConfigNameMap(s);
                o = a.set;
                l = a.get;
                t[o] = this.generateProxySetter(o);
                t[l] = this.generateProxyGetter(l);
            }
        }
    },
    applyComponent: function(e) {
        return Ext.factory(e, Ext.Component);
    },
    updateComponent: function(e, t) {
        if (t) {
            if (this.isRendered() && t.setRendered(false)) {
                t.fireAction("renderedchange", [ this, t, false ], "doUnsetComponent", this, {
                    args: [ t ]
                });
            } else {
                this.doUnsetComponent(t);
            }
        }
        if (e) {
            if (this.isRendered() && e.setRendered(true)) {
                e.fireAction("renderedchange", [ this, e, true ], "doSetComponent", this, {
                    args: [ e ]
                });
            } else {
                this.doSetComponent(e);
            }
        }
    },
    doUnsetComponent: function(e) {
        if (e.renderElement.dom) {
            e.setLayoutSizeFlags(0);
            this.innerElement.dom.removeChild(e.renderElement.dom);
        }
    },
    doSetComponent: function(e) {
        if (e.renderElement.dom) {
            e.setLayoutSizeFlags(this.getSizeFlags());
            this.innerElement.dom.appendChild(e.renderElement.dom);
        }
    },
    setRendered: function(e) {
        var t;
        if (this.callParent(arguments)) {
            t = this.getComponent();
            if (t) {
                t.setRendered(e);
            }
            return true;
        }
        return false;
    },
    setDisabled: function(e) {
        this.callParent(arguments);
        this.getComponent().setDisabled(e);
    },
    destroy: function() {
        Ext.destroy(this.getComponent());
        this.callParent();
    }
});

Ext.define("Ext.field.Input", {
    extend: "Ext.Component",
    xtype: "input",
    tag: "input",
    cachedConfig: {
        cls: Ext.baseCSSPrefix + "form-field",
        focusCls: Ext.baseCSSPrefix + "field-focus",
        maskCls: Ext.baseCSSPrefix + "field-mask",
        useMask: "auto",
        type: "text",
        checked: false
    },
    config: {
        baseCls: Ext.baseCSSPrefix + "field-input",
        name: null,
        value: null,
        isFocused: false,
        tabIndex: null,
        placeHolder: null,
        minValue: null,
        maxValue: null,
        stepValue: null,
        maxLength: null,
        autoComplete: null,
        autoCapitalize: null,
        autoCorrect: null,
        readOnly: null,
        maxRows: null,
        pattern: null,
        startValue: false
    },
    getTemplate: function() {
        var e = [ {
            reference: "input",
            tag: this.tag
        }, {
            reference: "clearIcon",
            cls: "x-clear-icon"
        } ];
        e.push({
            reference: "mask",
            classList: [ this.config.maskCls ]
        });
        return e;
    },
    initElement: function() {
        var e = this;
        e.callParent();
        e.input.on({
            scope: e,
            keyup: "onKeyUp",
            keydown: "onKeyDown",
            focus: "onFocus",
            blur: "onBlur",
            input: "onInput",
            paste: "onPaste"
        });
        e.mask.on({
            tap: "onMaskTap",
            scope: e
        });
        if (e.clearIcon) {
            e.clearIcon.on({
                tap: "onClearIconTap",
                scope: e
            });
        }
    },
    applyUseMask: function(e) {
        if (e === "auto") {
            e = Ext.os.is.iOS && Ext.os.version.lt("5");
        }
        return Boolean(e);
    },
    updateUseMask: function(e) {
        this.mask[e ? "show" : "hide"]();
    },
    updatePattern: function(e) {
        this.updateFieldAttribute("pattern", e);
    },
    updateFieldAttribute: function(e, t) {
        var i = this.input;
        if (t) {
            i.dom.setAttribute(e, t);
        } else {
            i.dom.removeAttribute(e);
        }
    },
    updateCls: function(e, t) {
        this.input.addCls(Ext.baseCSSPrefix + "input-el");
        this.input.replaceCls(t, e);
    },
    updateType: function(e, t) {
        var i = Ext.baseCSSPrefix + "input-";
        this.input.replaceCls(i + t, i + e);
        this.updateFieldAttribute("type", e);
    },
    updateName: function(e) {
        this.updateFieldAttribute("name", e);
    },
    getValue: function() {
        var e = this.input;
        if (e) {
            this._value = e.dom.value;
        }
        return this._value;
    },
    applyValue: function(e) {
        return Ext.isEmpty(e) ? "" : e;
    },
    updateValue: function(e) {
        var t = this.input;
        if (t) {
            t.dom.value = e;
        }
    },
    setValue: function(e) {
        var t = this._value;
        this.updateValue(this.applyValue(e));
        e = this.getValue();
        if (String(e) != String(t) && this.initialized) {
            this.onChange(this, e, t);
        }
        return this;
    },
    applyTabIndex: function(e) {
        if (e !== null && typeof e != "number") {
            throw new Error("Ext.field.Field: [applyTabIndex] trying to pass a value which is not a number");
        }
        return e;
    },
    updateTabIndex: function(e) {
        this.updateFieldAttribute("tabIndex", e);
    },
    testAutoFn: function(e) {
        return [ true, "on" ].indexOf(e) !== -1;
    },
    applyMaxLength: function(e) {
        if (e !== null && typeof e != "number") {
            throw new Error("Ext.field.Text: [applyMaxLength] trying to pass a value which is not a number");
        }
        return e;
    },
    updateMaxLength: function(e) {
        this.updateFieldAttribute("maxlength", e);
    },
    updatePlaceHolder: function(e) {
        this.updateFieldAttribute("placeholder", e);
    },
    applyAutoComplete: function(e) {
        return this.testAutoFn(e);
    },
    updateAutoComplete: function(e) {
        var t = e ? "on" : "off";
        this.updateFieldAttribute("autocomplete", t);
    },
    applyAutoCapitalize: function(e) {
        return this.testAutoFn(e);
    },
    updateAutoCapitalize: function(e) {
        var t = e ? "on" : "off";
        this.updateFieldAttribute("autocapitalize", t);
    },
    applyAutoCorrect: function(e) {
        return this.testAutoFn(e);
    },
    updateAutoCorrect: function(e) {
        var t = e ? "on" : "off";
        this.updateFieldAttribute("autocorrect", t);
    },
    updateMinValue: function(e) {
        this.updateFieldAttribute("min", e);
    },
    updateMaxValue: function(e) {
        this.updateFieldAttribute("max", e);
    },
    updateStepValue: function(e) {
        this.updateFieldAttribute("step", e);
    },
    checkedRe: /^(true|1|on)/i,
    getChecked: function() {
        var e = this.input, t;
        if (e) {
            t = e.dom.checked;
            this._checked = t;
        }
        return t;
    },
    applyChecked: function(e) {
        return !!this.checkedRe.test(String(e));
    },
    setChecked: function(e) {
        this.updateChecked(this.applyChecked(e));
        this._checked = e;
    },
    updateChecked: function(e) {
        this.input.dom.checked = e;
    },
    updateReadOnly: function(e) {
        this.updateFieldAttribute("readonly", e);
    },
    applyMaxRows: function(e) {
        if (e !== null && typeof e !== "number") {
            throw new Error("Ext.field.Input: [applyMaxRows] trying to pass a value which is not a number");
        }
        return e;
    },
    updateMaxRows: function(e) {
        this.updateFieldAttribute("rows", e);
    },
    doSetDisabled: function(e) {
        this.callParent(arguments);
        this.input.dom.disabled = e;
        if (!e) {
            this.blur();
        }
    },
    isDirty: function() {
        if (this.getDisabled()) {
            return false;
        }
        return String(this.getValue()) !== String(this.originalValue);
    },
    reset: function() {
        this.setValue(this.originalValue);
    },
    onMaskTap: function(e) {
        this.fireAction("masktap", [ this, e ], "doMaskTap");
    },
    doMaskTap: function(e, t) {
        if (e.getDisabled()) {
            return false;
        }
        e.maskCorrectionTimer = Ext.defer(e.showMask, 1e3, e);
        e.hideMask();
    },
    showMask: function(e) {
        if (this.mask) {
            this.mask.setStyle("display", "block");
        }
    },
    hideMask: function(e) {
        if (this.mask) {
            this.mask.setStyle("display", "none");
        }
    },
    focus: function() {
        var e = this, t = e.input;
        if (t && t.dom.focus) {
            t.dom.focus();
        }
        return e;
    },
    blur: function() {
        var e = this, t = this.input;
        if (t && t.dom.blur) {
            t.dom.blur();
        }
        return e;
    },
    select: function() {
        var e = this, t = e.input;
        if (t && t.dom.setSelectionRange) {
            t.dom.setSelectionRange(0, 9999);
        }
        return e;
    },
    onFocus: function(e) {
        this.fireAction("focus", [ e ], "doFocus");
    },
    doFocus: function(e) {
        var t = this;
        if (t.mask) {
            if (t.maskCorrectionTimer) {
                clearTimeout(t.maskCorrectionTimer);
            }
            t.hideMask();
        }
        if (!t.getIsFocused()) {
            t.setIsFocused(true);
            t.setStartValue(t.getValue());
        }
    },
    onBlur: function(e) {
        this.fireAction("blur", [ e ], "doBlur");
    },
    doBlur: function(e) {
        var t = this, i = t.getValue(), n = t.getStartValue();
        t.setIsFocused(false);
        if (String(i) != String(n)) {
            t.onChange(t, i, n);
        }
        t.showMask();
    },
    onClearIconTap: function(e) {
        this.fireEvent("clearicontap", this, e);
        if (Ext.os.is.Android) {
            this.focus();
        }
    },
    onClick: function(e) {
        this.fireEvent("click", e);
    },
    onChange: function(e, t, i) {
        this.fireEvent("change", e, t, i);
    },
    onPaste: function(e) {
        this.fireEvent("paste", e);
    },
    onKeyUp: function(e) {
        this.fireEvent("keyup", e);
    },
    onKeyDown: function() {
        this.ignoreInput = true;
    },
    onInput: function(e) {
        var t = this;
        if (t.ignoreInput) {
            t.ignoreInput = false;
            return;
        }
        setTimeout(function() {
            if (!t.ignoreInput) {
                t.fireEvent("keyup", e);
                t.ignoreInput = false;
            }
        }, 10);
    },
    onMouseDown: function(e) {
        this.fireEvent("mousedown", e);
    }
});

Ext.define("Twitter.controller.phone.Search", {
    extend: "Twitter.controller.Search",
    config: {
        refs: {
            tweetToolbar: "tweetlist toolbar",
            searchContainer: "mainview #searchcontainer"
        },
        control: {
            "tweetlist toolbar button": {
                tap: "onBackButtonTap"
            }
        }
    },
    launch: function() {
        this.callParent(arguments);
        this.getTweetToolbar().show();
    },
    onBackButtonTap: function() {
        this.getMain().setActiveItem(this.getSearchContainer());
    },
    onSearchSelect: function(e, t) {
        this.callParent(arguments);
        this.getMain().setActiveItem(this.getTweetList());
        var i = this.getSearchList();
        setTimeout(function() {
            i.deselect(t);
        }, 500);
    }
});

Ext.define("Twitter.controller.tablet.Search", {
    extend: "Twitter.controller.Search",
    onSearchesStoreLoad: function() {
        this.callParent();
        var e = Ext.getStore("Searches").getAt(0);
        if (e) {
            this.getSearchList().select(e);
        }
    },
    doDestroy: function(e, t) {
        var i = Ext.getStore("Searches"), n = i.getAt(i.indexOf(e) - 1);
        this.callParent(arguments);
        n = n || i.getAt(0);
        if (n) {
            this.getSearchList().select(n);
        } else {
            this.getTweetList().hide();
        }
    },
    onSearchSelect: function() {
        this.callParent(arguments);
        this.getTweetList().show();
    }
});

Ext.define("Ext.data.identifier.Uuid", {
    extend: "Ext.data.identifier.Simple",
    alias: "data.identifier.uuid",
    isUnique: true,
    config: {
        id: undefined,
        salt: null,
        timestamp: null,
        version: 4
    },
    applyId: function(e) {
        if (e === undefined) {
            return Ext.data.identifier.Uuid.Global;
        }
        return e;
    },
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        e.parts = [];
        e.init();
    },
    reconfigure: function(e) {
        this.setConfig(e);
        this.init();
    },
    generate: function() {
        var e = this, t = e.parts, i = e.getVersion(), n = e.getSalt(), r = e.getTimestamp();
        t[0] = e.toHex(r.lo, 8);
        t[1] = e.toHex(r.hi & 65535, 4);
        t[2] = e.toHex(r.hi >>> 16 & 4095 | i << 12, 4);
        t[3] = e.toHex(128 | e.clockSeq >>> 8 & 63, 2) + e.toHex(e.clockSeq & 255, 2);
        t[4] = e.toHex(n.hi, 4) + e.toHex(n.lo, 8);
        if (i == 4) {
            e.init();
        } else {
            ++r.lo;
            if (r.lo >= e.twoPow32) {
                r.lo = 0;
                ++r.hi;
            }
        }
        return t.join("-").toLowerCase();
    },
    init: function() {
        var e = this, t = e.getSalt(), i = e.getTimestamp();
        if (e.getVersion() == 4) {
            e.clockSeq = e.rand(0, e.twoPow14 - 1);
            if (!t) {
                t = {};
                e.setSalt(t);
            }
            if (!i) {
                i = {};
                e.setTimestamp(i);
            }
            t.lo = e.rand(0, e.twoPow32 - 1);
            t.hi = e.rand(0, e.twoPow16 - 1);
            i.lo = e.rand(0, e.twoPow32 - 1);
            i.hi = e.rand(0, e.twoPow28 - 1);
        } else {
            e.setSalt(e.split(e.getSalt()));
            e.setTimestamp(e.split(e.getTimestamp()));
            e.getSalt().hi |= 256;
        }
    },
    twoPow14: Math.pow(2, 14),
    twoPow16: Math.pow(2, 16),
    twoPow28: Math.pow(2, 28),
    twoPow32: Math.pow(2, 32),
    toHex: function(e, t) {
        var i = e.toString(16);
        if (i.length > t) {
            i = i.substring(i.length - t);
        } else if (i.length < t) {
            i = Ext.String.leftPad(i, t, "0");
        }
        return i;
    },
    rand: function(e, t) {
        var i = Math.random() * (t - e + 1);
        return Math.floor(i) + e;
    },
    split: function(e) {
        if (typeof e == "number") {
            var t = Math.floor(e / this.twoPow32);
            return {
                lo: Math.floor(e - t * this.twoPow32),
                hi: t
            };
        }
        return e;
    }
}, function() {
    this.Global = new this({
        id: "uuid"
    });
});

Ext.define("Ext.util.Collection", {
    config: {
        autoFilter: true,
        autoSort: true
    },
    mixins: {
        sortable: "Ext.mixin.Sortable",
        filterable: "Ext.mixin.Filterable"
    },
    constructor: function(e, t) {
        var i = this;
        i.all = [];
        i.items = [];
        i.keys = [];
        i.indices = {};
        i.map = {};
        i.length = 0;
        if (e) {
            i.getKey = e;
        }
        this.initConfig(t);
    },
    updateAutoSort: function(e, t) {
        if (t === false && e && this.items.length) {
            this.sort();
        }
    },
    updateAutoFilter: function(e, t) {
        if (t === false && e && this.all.length) {
            this.filter();
        }
    },
    insertSorters: function() {
        this.mixins.sortable.insertSorters.apply(this, arguments);
        if (this.getAutoSort() && this.items.length) {
            this.sort();
        }
        return this;
    },
    removeSorters: function(e) {
        this.mixins.sortable.removeSorters.call(this, e);
        if (this.sorted && this.getAutoSort() && this.items.length) {
            this.sort();
        }
        return this;
    },
    applyFilters: function(e) {
        var t = this.mixins.filterable.applyFilters.call(this, e);
        if (!e && this.all.length && this.getAutoFilter()) {
            this.filter();
        }
        return t;
    },
    addFilters: function(e) {
        this.mixins.filterable.addFilters.call(this, e);
        if (this.items.length && this.getAutoFilter()) {
            this.filter();
        }
        return this;
    },
    removeFilters: function(e) {
        this.mixins.filterable.removeFilters.call(this, e);
        if (this.filtered && this.all.length && this.getAutoFilter()) {
            this.filter();
        }
        return this;
    },
    filter: function(e, t, i, n) {
        if (e) {
            if (Ext.isString(e)) {
                this.addFilters({
                    property: e,
                    value: t,
                    anyMatch: i,
                    caseSensitive: n
                });
                return this.items;
            } else {
                this.addFilters(e);
                return this.items;
            }
        }
        this.items = this.mixins.filterable.filter.call(this, this.all.slice());
        this.updateAfterFilter();
        if (this.sorted && this.getAutoSort()) {
            this.sort();
        }
    },
    updateAfterFilter: function() {
        var e = this.items, t = this.keys, i = this.indices = {}, n = e.length, r, s, a;
        t.length = 0;
        for (r = 0; r < n; r++) {
            s = e[r];
            a = this.getKey(s);
            i[a] = r;
            t[r] = a;
        }
        this.length = e.length;
        this.dirtyIndices = false;
    },
    sort: function(e, t) {
        var i = this.items, n = this.keys, r = this.indices, s = i.length, a, o, l;
        if (e) {
            this.addSorters(e, t);
            return this.items;
        }
        for (a = 0; a < s; a++) {
            i[a]._current_key = n[a];
        }
        this.handleSort(i);
        for (a = 0; a < s; a++) {
            o = i[a];
            l = o._current_key;
            n[a] = l;
            r[l] = a;
            delete o._current_key;
        }
        this.dirtyIndices = true;
    },
    handleSort: function(e) {
        this.mixins.sortable.sort.call(this, e);
    },
    add: function(e, t) {
        var i = this, n = this.filtered, r = this.sorted, s = this.all, a = this.items, o = this.keys, l = this.indices, u = this.mixins.filterable, c = a.length, f = c;
        if (arguments.length == 1) {
            t = e;
            e = i.getKey(t);
        }
        if (typeof e != "undefined" && e !== null) {
            if (typeof i.map[e] != "undefined") {
                return i.replace(e, t);
            }
            i.map[e] = t;
        }
        s.push(t);
        if (n && this.getAutoFilter() && u.isFiltered.call(i, t)) {
            return null;
        }
        i.length++;
        if (r && this.getAutoSort()) {
            f = this.findInsertionIndex(a, t);
        }
        if (f !== c) {
            this.dirtyIndices = true;
            Ext.Array.splice(o, f, 0, e);
            Ext.Array.splice(a, f, 0, t);
        } else {
            l[e] = c;
            o.push(e);
            a.push(t);
        }
        return t;
    },
    getKey: function(e) {
        return e.id;
    },
    replace: function(e, t) {
        var i = this, n = i.sorted, r = i.filtered, s = i.mixins.filterable, a = i.items, o = i.keys, l = i.all, u = i.map, c = null, f = a.length, d, h, g;
        if (arguments.length == 1) {
            t = e;
            e = g = i.getKey(t);
        } else {
            g = i.getKey(t);
        }
        d = u[e];
        if (typeof e == "undefined" || e === null || typeof d == "undefined") {
            return i.add(g, t);
        }
        i.map[g] = t;
        if (g !== e) {
            delete i.map[e];
        }
        if (n && i.getAutoSort()) {
            Ext.Array.remove(a, d);
            Ext.Array.remove(o, e);
            Ext.Array.remove(l, d);
            l.push(t);
            i.dirtyIndices = true;
            if (r && i.getAutoFilter()) {
                if (s.isFiltered.call(i, t)) {
                    if (f !== a.length) {
                        i.length--;
                    }
                    return null;
                } else if (f === a.length) {
                    i.length++;
                    c = t;
                }
            }
            h = this.findInsertionIndex(a, t);
            Ext.Array.splice(o, h, 0, g);
            Ext.Array.splice(a, h, 0, t);
        } else {
            if (r) {
                if (i.getAutoFilter() && s.isFiltered.call(i, t)) {
                    if (a.indexOf(d) !== -1) {
                        Ext.Array.remove(a, d);
                        Ext.Array.remove(o, e);
                        i.length--;
                        i.dirtyIndices = true;
                    }
                    return null;
                } else if (a.indexOf(d) === -1) {
                    a.push(t);
                    o.push(g);
                    i.indices[g] = i.length;
                    i.length++;
                    return t;
                }
            }
            h = i.items.indexOf(d);
            o[h] = g;
            a[h] = t;
            this.dirtyIndices = true;
        }
        return c;
    },
    addAll: function(e) {
        var t = this, i = t.filtered, n = t.sorted, r = t.all, s = t.items, a = t.keys, o = t.map, l = t.getAutoFilter(), u = t.getAutoSort(), c = [], f = [], d = t.mixins.filterable, h = [], g, p, m, x;
        if (Ext.isObject(e)) {
            for (p in e) {
                if (e.hasOwnProperty(p)) {
                    f.push(s[p]);
                    c.push(p);
                }
            }
        } else {
            f = e;
            g = e.length;
            for (m = 0; m < g; m++) {
                c.push(t.getKey(e[m]));
            }
        }
        for (m = 0; m < g; m++) {
            p = c[m];
            x = f[m];
            if (typeof p != "undefined" && p !== null) {
                if (typeof o[p] != "undefined") {
                    t.replace(p, x);
                    continue;
                }
                o[p] = x;
            }
            r.push(x);
            if (i && l && d.isFiltered.call(t, x)) {
                continue;
            }
            t.length++;
            a.push(p);
            s.push(x);
            h.push(x);
        }
        if (h.length) {
            t.dirtyIndices = true;
            if (n && u) {
                t.sort();
            }
            return h;
        }
        return null;
    },
    each: function(e, t) {
        var i = this.items.slice(), n = 0, r = i.length, s;
        for (;n < r; n++) {
            s = i[n];
            if (e.call(t || s, s, n, r) === false) {
                break;
            }
        }
    },
    eachKey: function(e, t) {
        var i = this.keys, n = this.items, r = i.length, s;
        for (s = 0; s < r; s++) {
            e.call(t || window, i[s], n[s], s, r);
        }
    },
    findBy: function(e, t) {
        var i = this.keys, n = this.items, r = 0, s = n.length;
        for (;r < s; r++) {
            if (e.call(t || window, n[r], i[r])) {
                return n[r];
            }
        }
        return null;
    },
    filterBy: function(e, t) {
        var i = this, n = new this.self(), r = i.keys, s = i.all, a = s.length, o;
        n.getKey = i.getKey;
        for (o = 0; o < a; o++) {
            if (e.call(t || i, s[o], i.getKey(s[o]))) {
                n.add(r[o], s[o]);
            }
        }
        return n;
    },
    insert: function(e, t, i) {
        var n = this, r = this.sorted, s = this.map, a = this.filtered;
        if (arguments.length == 2) {
            i = t;
            t = n.getKey(i);
        }
        if (e >= n.length || r && n.getAutoSort()) {
            return n.add(t, i);
        }
        if (typeof t != "undefined" && t !== null) {
            if (typeof s[t] != "undefined") {
                n.replace(t, i);
                return false;
            }
            s[t] = i;
        }
        this.all.push(i);
        if (a && this.getAutoFilter() && this.mixins.filterable.isFiltered.call(n, i)) {
            return null;
        }
        n.length++;
        Ext.Array.splice(n.items, e, 0, i);
        Ext.Array.splice(n.keys, e, 0, t);
        n.dirtyIndices = true;
        return i;
    },
    insertAll: function(e, t) {
        if (e >= this.items.length || this.sorted && this.getAutoSort()) {
            return this.addAll(t);
        }
        var i = this, n = this.filtered, r = this.sorted, s = this.all, a = this.items, o = this.keys, l = this.map, u = this.getAutoFilter(), c = this.getAutoSort(), f = [], d = [], h = [], g = this.mixins.filterable, p = false, m, x, E, y;
        if (r && this.getAutoSort()) {
            Ext.Logger.error("Inserting a collection of items into a sorted Collection is invalid. Please just add these items or remove the sorters.");
        }
        if (Ext.isObject(t)) {
            for (x in t) {
                if (t.hasOwnProperty(x)) {
                    d.push(a[x]);
                    f.push(x);
                }
            }
        } else {
            d = t;
            m = t.length;
            for (E = 0; E < m; E++) {
                f.push(i.getKey(t[E]));
            }
        }
        for (E = 0; E < m; E++) {
            x = f[E];
            y = d[E];
            if (typeof x != "undefined" && x !== null) {
                if (typeof l[x] != "undefined") {
                    i.replace(x, y);
                    continue;
                }
                l[x] = y;
            }
            s.push(y);
            if (n && u && g.isFiltered.call(i, y)) {
                continue;
            }
            i.length++;
            Ext.Array.splice(a, e + E, 0, y);
            Ext.Array.splice(o, e + E, 0, x);
            p = true;
            h.push(y);
        }
        if (p) {
            this.dirtyIndices = true;
            if (r && c) {
                this.sort();
            }
            return h;
        }
        return null;
    },
    remove: function(e) {
        var t = this.items.indexOf(e);
        if (t === -1) {
            Ext.Array.remove(this.all, e);
            if (typeof this.getKey == "function") {
                var i = this.getKey(e);
                if (i !== undefined) {
                    delete this.map[i];
                }
            }
            return e;
        }
        return this.removeAt(this.items.indexOf(e));
    },
    removeAll: function(e) {
        if (e) {
            var t = e.length, i;
            for (i = 0; i < t; i++) {
                this.remove(e[i]);
            }
        }
        return this;
    },
    removeAt: function(e) {
        var t = this, i = t.items, n = t.keys, r = t.all, s, a;
        if (e < t.length && e >= 0) {
            s = i[e];
            a = n[e];
            if (typeof a != "undefined") {
                delete t.map[a];
            }
            Ext.Array.erase(i, e, 1);
            Ext.Array.erase(n, e, 1);
            Ext.Array.remove(r, s);
            delete t.indices[a];
            t.length--;
            this.dirtyIndices = true;
            return s;
        }
        return false;
    },
    removeAtKey: function(e) {
        return this.removeAt(this.indexOfKey(e));
    },
    getCount: function() {
        return this.length;
    },
    indexOf: function(e) {
        if (this.dirtyIndices) {
            this.updateIndices();
        }
        var t = this.indices[this.getKey(e)];
        return t === undefined ? -1 : t;
    },
    indexOfKey: function(e) {
        if (this.dirtyIndices) {
            this.updateIndices();
        }
        var t = this.indices[e];
        return t === undefined ? -1 : t;
    },
    updateIndices: function() {
        var e = this.items, t = e.length, i = this.indices = {}, n, r, s;
        for (n = 0; n < t; n++) {
            r = e[n];
            s = this.getKey(r);
            i[s] = n;
        }
        this.dirtyIndices = false;
    },
    get: function(e) {
        var t = this, i = t.map[e], n;
        if (i !== undefined) {
            n = i;
        } else if (typeof e == "number") {
            n = t.items[e];
        }
        return typeof n != "function" || t.getAllowFunctions() ? n : null;
    },
    getAt: function(e) {
        return this.items[e];
    },
    getByKey: function(e) {
        return this.map[e];
    },
    contains: function(e) {
        var t = this.getKey(e);
        if (t) {
            return this.containsKey(t);
        } else {
            return Ext.Array.contains(this.items, e);
        }
    },
    containsKey: function(e) {
        return typeof this.map[e] != "undefined";
    },
    clear: function() {
        var e = this;
        e.length = 0;
        e.items.length = 0;
        e.keys.length = 0;
        e.all.length = 0;
        e.dirtyIndices = true;
        e.indices = {};
        e.map = {};
    },
    first: function() {
        return this.items[0];
    },
    last: function() {
        return this.items[this.length - 1];
    },
    getRange: function(e, t) {
        var i = this, n = i.items, r = [], s;
        if (n.length < 1) {
            return r;
        }
        e = e || 0;
        t = Math.min(typeof t == "undefined" ? i.length - 1 : t, i.length - 1);
        if (e <= t) {
            for (s = e; s <= t; s++) {
                r[r.length] = n[s];
            }
        } else {
            for (s = e; s >= t; s--) {
                r[r.length] = n[s];
            }
        }
        return r;
    },
    findIndexBy: function(e, t, i) {
        var n = this, r = n.keys, s = n.items, a = i || 0, o = s.length;
        for (;a < o; a++) {
            if (e.call(t || n, s[a], r[a])) {
                return a;
            }
        }
        return -1;
    },
    clone: function() {
        var e = this, t = new this.self(), i = e.keys, n = e.items, r = 0, s = n.length;
        for (;r < s; r++) {
            t.add(i[r], n[r]);
        }
        t.getKey = e.getKey;
        return t;
    },
    destroy: function() {
        this.callSuper();
        this.clear();
    }
});

Ext.define("Ext.data.Errors", {
    extend: "Ext.util.Collection",
    requires: "Ext.data.Error",
    isValid: function() {
        return this.length === 0;
    },
    getByField: function(e) {
        var t = [], i, n;
        for (n = 0; n < this.length; n++) {
            i = this.items[n];
            if (i.getField() == e) {
                t.push(i);
            }
        }
        return t;
    },
    add: function() {
        var e = arguments.length == 1 ? arguments[0] : arguments[1];
        if (!(e instanceof Ext.data.Error)) {
            e = Ext.create("Ext.data.Error", {
                field: e.field || e.name,
                message: e.error || e.message
            });
        }
        return this.callParent([ e ]);
    }
});

Ext.define("Ext.data.proxy.Memory", {
    extend: "Ext.data.proxy.Client",
    alias: "proxy.memory",
    alternateClassName: "Ext.data.MemoryProxy",
    isMemoryProxy: true,
    config: {
        data: []
    },
    finishOperation: function(e, t, i) {
        if (e) {
            var n = 0, r = e.getRecords(), s = r.length;
            for (n; n < s; n++) {
                r[n].commit();
            }
            e.setCompleted();
            e.setSuccessful();
            Ext.callback(t, i || this, [ e ]);
        }
    },
    create: function() {
        this.finishOperation.apply(this, arguments);
    },
    update: function() {
        this.finishOperation.apply(this, arguments);
    },
    destroy: function() {
        this.finishOperation.apply(this, arguments);
    },
    read: function(e, t, i) {
        var n = this, r = n.getReader();
        if (e.process("read", r.process(n.getData())) === false) {
            this.fireEvent("exception", this, null, e);
        }
        Ext.callback(t, i || n, [ e ]);
    },
    clear: Ext.emptyFn
});

Ext.define("Ext.data.StoreManager", {
    extend: "Ext.util.Collection",
    alternateClassName: [ "Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager" ],
    singleton: true,
    uses: [ "Ext.data.ArrayStore", "Ext.data.Store" ],
    register: function() {
        for (var e = 0, t; t = arguments[e]; e++) {
            this.add(t);
        }
    },
    unregister: function() {
        for (var e = 0, t; t = arguments[e]; e++) {
            this.remove(this.lookup(t));
        }
    },
    lookup: function(e) {
        if (Ext.isArray(e)) {
            var t = [ "field1" ], i = !Ext.isArray(e[0]), n = e, r, s;
            if (i) {
                n = [];
                for (r = 0, s = e.length; r < s; ++r) {
                    n.push([ e[r] ]);
                }
            } else {
                for (r = 2, s = e[0].length; r <= s; ++r) {
                    t.push("field" + r);
                }
            }
            return Ext.create("Ext.data.ArrayStore", {
                data: n,
                fields: t,
                autoDestroy: true,
                autoCreated: true,
                expanded: i
            });
        }
        if (Ext.isString(e)) {
            return this.get(e);
        } else {
            if (e instanceof Ext.data.Store) {
                return e;
            } else {
                return Ext.factory(e, Ext.data.Store, null, "store");
            }
        }
    },
    getKey: function(e) {
        return e.getStoreId();
    }
}, function() {
    Ext.regStore = function(e, t) {
        var i;
        if (Ext.isObject(e)) {
            t = e;
        } else {
            if (t instanceof Ext.data.Store) {
                t.setStoreId(e);
            } else {
                t.storeId = e;
            }
        }
        if (t instanceof Ext.data.Store) {
            i = t;
        } else {
            i = Ext.create("Ext.data.Store", t);
        }
        return Ext.data.StoreManager.register(i);
    };
    Ext.getStore = function(e) {
        return Ext.data.StoreManager.lookup(e);
    };
});

Ext.define("Ext.data.Types", {
    singleton: true,
    requires: [ "Ext.data.SortTypes" ],
    stripRe: /[\$,%]/g,
    dashesRe: /-/g,
    iso8601TestRe: /\d\dT\d\d/,
    iso8601SplitRe: /[- :T\.Z\+]/
}, function() {
    var e = this, t = Ext.data.SortTypes;
    Ext.apply(e, {
        AUTO: {
            convert: function(e) {
                return e;
            },
            sortType: t.none,
            type: "auto"
        },
        STRING: {
            convert: function(e) {
                return e === undefined || e === null ? this.getAllowNull() ? null : "" : String(e);
            },
            sortType: t.asUCString,
            type: "string"
        },
        INT: {
            convert: function(t) {
                return t !== undefined && t !== null && t !== "" ? typeof t === "number" ? parseInt(t, 10) : parseInt(String(t).replace(e.stripRe, ""), 10) : this.getAllowNull() ? null : 0;
            },
            sortType: t.none,
            type: "int"
        },
        FLOAT: {
            convert: function(t) {
                return t !== undefined && t !== null && t !== "" ? typeof t === "number" ? t : parseFloat(String(t).replace(e.stripRe, ""), 10) : this.getAllowNull() ? null : 0;
            },
            sortType: t.none,
            type: "float"
        },
        BOOL: {
            convert: function(e) {
                if ((e === undefined || e === null || e === "") && this.getAllowNull()) {
                    return null;
                }
                return e !== "false" && !!e;
            },
            sortType: t.none,
            type: "bool"
        },
        DATE: {
            convert: function(t) {
                var i = this.getDateFormat(), n;
                if (!t) {
                    return null;
                }
                if (Ext.isDate(t)) {
                    return t;
                }
                if (i) {
                    if (i == "timestamp") {
                        return new Date(t * 1e3);
                    }
                    if (i == "time") {
                        return new Date(parseInt(t, 10));
                    }
                    return Ext.Date.parse(t, i);
                }
                n = new Date(Date.parse(t));
                if (isNaN(n)) {
                    if (e.iso8601TestRe.test(t)) {
                        n = t.split(e.iso8601SplitRe);
                        n = new Date(n[0], n[1] - 1, n[2], n[3], n[4], n[5]);
                    }
                    if (isNaN(n)) {
                        n = new Date(Date.parse(t.replace(e.dashesRe, "/")));
                        if (isNaN(n)) {
                            Ext.Logger.warn("Cannot parse the passed value (" + t + ") into a valid date");
                        }
                    }
                }
                return isNaN(n) ? null : n;
            },
            sortType: t.asDate,
            type: "date"
        }
    });
    Ext.apply(e, {
        BOOLEAN: this.BOOL,
        INTEGER: this.INT,
        NUMBER: this.FLOAT
    });
});

Ext.define("Ext.data.Field", {
    requires: [ "Ext.data.Types", "Ext.data.SortTypes" ],
    alias: "data.field",
    isField: true,
    config: {
        name: null,
        type: "auto",
        convert: undefined,
        dateFormat: null,
        allowNull: true,
        defaultValue: undefined,
        mapping: null,
        sortType: undefined,
        sortDir: "ASC",
        allowBlank: true,
        persist: true,
        encode: null,
        decode: null,
        bubbleEvents: "action"
    },
    constructor: function(e) {
        if (Ext.isString(e)) {
            e = {
                name: e
            };
        }
        this.initConfig(e);
    },
    applyType: function(e) {
        var t = Ext.data.Types, i = t.AUTO;
        if (e) {
            if (Ext.isString(e)) {
                return t[e.toUpperCase()] || i;
            } else {
                return e;
            }
        }
        return i;
    },
    updateType: function(e, t) {
        var i = this.getConvert();
        if (t && i === t.convert) {
            this.setConvert(e.convert);
        }
    },
    applySortType: function(e) {
        var t = Ext.data.SortTypes, i = this.getType(), n = i.sortType;
        if (e) {
            if (Ext.isString(e)) {
                return t[e] || n;
            } else {
                return e;
            }
        }
        return n;
    },
    applyConvert: function(e) {
        var t = this.getType().convert;
        if (e && e !== t) {
            this._hasCustomConvert = true;
            return e;
        } else {
            this._hasCustomConvert = false;
            return t;
        }
    },
    hasCustomConvert: function() {
        return this._hasCustomConvert;
    }
}, function() {
    Ext.deprecateProperty(this, "useNull", "allowNull");
});

Ext.define("Ext.AbstractManager", {
    requires: [ "Ext.util.HashMap" ],
    typeName: "type",
    constructor: function(e) {
        Ext.apply(this, e || {});
        this.all = Ext.create("Ext.util.HashMap");
        this.types = {};
    },
    get: function(e) {
        return this.all.get(e);
    },
    register: function(e) {
        this.all.add(e);
    },
    unregister: function(e) {
        this.all.remove(e);
    },
    registerType: function(e, t) {
        this.types[e] = t;
        t[this.typeName] = e;
    },
    isRegistered: function(e) {
        return this.types[e] !== undefined;
    },
    create: function(e, t) {
        var i = e[this.typeName] || e.type || t, n = this.types[i];
        if (n == undefined) {
            Ext.Error.raise("The '" + i + "' type has not been registered with this manager");
        }
        return new n(e);
    },
    onAvailable: function(e, t, i) {
        var n = this.all, r;
        if (n.containsKey(e)) {
            r = n.get(e);
            t.call(i || r, r);
        } else {
            n.on("add", function(r, s, a) {
                if (s == e) {
                    t.call(i || a, a);
                    n.un("add", t, i);
                }
            });
        }
    },
    each: function(e, t) {
        this.all.each(e, t || this);
    },
    getCount: function() {
        return this.all.getCount();
    }
});

Ext.define("Ext.data.ModelManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: [ "Ext.ModelMgr", "Ext.ModelManager" ],
    singleton: true,
    modelNamespace: null,
    registerType: function(e, t) {
        var i = t.prototype, n;
        if (i && i.isModel) {
            n = t;
        } else {
            t = {
                extend: t.extend || "Ext.data.Model",
                config: t
            };
            n = Ext.define(e, t);
        }
        this.types[e] = n;
        return n;
    },
    onModelDefined: Ext.emptyFn,
    getModel: function(e) {
        var t = e;
        if (typeof t == "string") {
            t = this.types[t];
            if (!t && this.modelNamespace) {
                t = this.types[this.modelNamespace + "." + t];
            }
        }
        return t;
    },
    create: function(e, t, i) {
        var n = typeof t == "function" ? t : this.types[t || e.name];
        return new n(e, i);
    }
}, function() {
    Ext.regModel = function() {
        Ext.Logger.deprecate("Ext.regModel has been deprecated. Models can now be created by " + 'extending Ext.data.Model: Ext.define("MyModel", {extend: "Ext.data.Model", fields: []});.');
        return this.ModelManager.registerType.apply(this.ModelManager, arguments);
    };
});

Ext.define("Ext.Ajax", {
    extend: "Ext.data.Connection",
    singleton: true,
    autoAbort: false
});

Ext.define("Ext.data.proxy.Ajax", {
    extend: "Ext.data.proxy.Server",
    requires: [ "Ext.util.MixedCollection", "Ext.Ajax" ],
    alias: "proxy.ajax",
    alternateClassName: [ "Ext.data.HttpProxy", "Ext.data.AjaxProxy" ],
    config: {
        withCredentials: false,
        username: null,
        password: null,
        actionMethods: {
            create: "POST",
            read: "GET",
            update: "POST",
            destroy: "POST"
        },
        headers: {}
    },
    doRequest: function(e, t, i) {
        var n = this, r = n.getWriter(), s = n.buildRequest(e);
        s.setConfig({
            headers: n.getHeaders(),
            timeout: n.getTimeout(),
            method: n.getMethod(s),
            callback: n.createRequestCallback(s, e, t, i),
            scope: n,
            proxy: n
        });
        if (e.getWithCredentials() || n.getWithCredentials()) {
            s.setWithCredentials(true);
            s.setUsername(n.getUsername());
            s.setPassword(n.getPassword());
        }
        s = r.write(s);
        Ext.Ajax.request(s.getCurrentConfig());
        return s;
    },
    getMethod: function(e) {
        return this.getActionMethods()[e.getAction()];
    },
    createRequestCallback: function(e, t, i, n) {
        var r = this;
        return function(s, a, o) {
            r.processResponse(a, t, e, o, i, n);
        };
    }
});

Ext.define("Ext.data.association.Association", {
    alternateClassName: "Ext.data.Association",
    requires: [ "Ext.data.ModelManager" ],
    config: {
        ownerModel: null,
        ownerName: undefined,
        associatedModel: null,
        associatedName: undefined,
        associationKey: undefined,
        primaryKey: "id",
        reader: null,
        type: null,
        name: undefined
    },
    statics: {
        create: function(e) {
            if (!e.isAssociation) {
                if (Ext.isString(e)) {
                    e = {
                        type: e
                    };
                }
                e.type = e.type.toLowerCase();
                return Ext.factory(e, Ext.data.association.Association, null, "association");
            }
            return e;
        }
    },
    constructor: function(e) {
        this.initConfig(e);
    },
    applyName: function(e) {
        if (!e) {
            e = this.getAssociatedName();
        }
        return e;
    },
    applyOwnerModel: function(e) {
        var t = Ext.data.ModelManager.getModel(e);
        if (t === undefined) {
            Ext.Logger.error("The configured ownerModel was not valid (you tried " + e + ")");
        }
        return t;
    },
    applyOwnerName: function(e) {
        if (!e) {
            e = this.getOwnerModel().modelName;
        }
        e = e.slice(e.lastIndexOf(".") + 1);
        return e;
    },
    updateOwnerModel: function(e, t) {
        if (t) {
            this.setOwnerName(e.modelName);
        }
    },
    applyAssociatedModel: function(e) {
        var t = Ext.data.ModelManager.types[e];
        if (t === undefined) {
            Ext.Logger.error("The configured associatedModel was not valid (you tried " + e + ")");
        }
        return t;
    },
    applyAssociatedName: function(e) {
        if (!e) {
            e = this.getAssociatedModel().modelName;
        }
        e = e.slice(e.lastIndexOf(".") + 1);
        return e;
    },
    updateAssociatedModel: function(e, t) {
        if (t) {
            this.setAssociatedName(e.modelName);
        }
    },
    applyReader: function(e) {
        if (e) {
            if (Ext.isString(e)) {
                e = {
                    type: e
                };
            }
            if (!e.isReader) {
                Ext.applyIf(e, {
                    type: "json"
                });
            }
        }
        return Ext.factory(e, Ext.data.Reader, this.getReader(), "reader");
    },
    updateReader: function(e) {
        e.setModel(this.getAssociatedModel());
    },
    onClassExtended: function(e, t, i) {
        var n = this, r = n.prototype.config, s = t.config || {}, a;
        for (a in r) {
            if (a in t) {
                s[a] = t[a];
                delete t[a];
                Ext.Logger.deprecate(a + " is deprecated as a property directly on the Association prototype. " + "Please put it inside the config object.");
            }
        }
        t.config = s;
    }
});

Ext.define("Ext.data.association.HasMany", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.HasManyAssociation",
    requires: [ "Ext.util.Inflector" ],
    alias: "association.hasmany",
    config: {
        foreignKey: undefined,
        store: undefined,
        storeName: undefined,
        filterProperty: null,
        autoLoad: false,
        autoSync: false
    },
    constructor: function(e) {
        e = e || {};
        if (e.storeConfig) {
            Ext.Logger.warn("storeConfig is deprecated on an association. Instead use the store configuration.");
            e.store = e.storeConfig;
            delete e.storeConfig;
        }
        this.callParent([ e ]);
    },
    applyName: function(e) {
        if (!e) {
            e = Ext.util.Inflector.pluralize(this.getAssociatedName().toLowerCase());
        }
        return e;
    },
    applyStoreName: function(e) {
        if (!e) {
            e = this.getName() + "Store";
        }
        return e;
    },
    applyForeignKey: function(e) {
        if (!e) {
            var t = this.getInverseAssociation();
            if (t) {
                e = t.getForeignKey();
            } else {
                e = this.getOwnerName().toLowerCase() + "_id";
            }
        }
        return e;
    },
    applyAssociationKey: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = Ext.util.Inflector.pluralize(t[0].toLowerCase() + t.slice(1));
        }
        return e;
    },
    updateForeignKey: function(e, t) {
        var i = this.getAssociatedModel().getFields(), n = i.get(e);
        if (!n) {
            n = new Ext.data.Field({
                name: e
            });
            i.add(n);
            i.isDirty = true;
        }
        if (t) {
            n = i.get(t);
            if (n) {
                i.remove(n);
                i.isDirty = true;
            }
        }
    },
    applyStore: function(e) {
        var t = this, i = t, n = t.getAssociatedModel(), r = t.getStoreName(), s = t.getForeignKey(), a = t.getPrimaryKey(), o = t.getFilterProperty(), l = t.getAutoLoad(), u = t.getAutoSync();
        return function() {
            var i = this, c, f, d, h = {}, g = {
                addrecords: t.onAddRecords,
                removerecords: t.onRemoveRecords,
                scope: t
            };
            if (i[r] === undefined) {
                if (o) {
                    f = {
                        property: o,
                        value: i.get(o),
                        exactMatch: true
                    };
                } else {
                    f = {
                        property: s,
                        value: i.get(a),
                        exactMatch: true
                    };
                }
                h[s] = i.get(a);
                c = Ext.apply({}, e, {
                    model: n,
                    filters: [ f ],
                    remoteFilter: true,
                    autoSync: u,
                    modelDefaults: h,
                    listeners: g
                });
                d = i[r] = Ext.create("Ext.data.Store", c);
                d.boundTo = i;
                if (l) {
                    i[r].load();
                }
            }
            return i[r];
        };
    },
    onAddRecords: function(e, t) {
        var i = t.length, n = e.boundTo.getId(), r, s;
        for (r = 0; r < i; r++) {
            s = t[r];
            s.set(this.getForeignKey(), n);
        }
        this.updateInverseInstances(e.boundTo);
    },
    onRemoveRecords: function(e, t) {
        var i = t.length, n, r;
        for (n = 0; n < i; n++) {
            r = t[n];
            r.set(this.getForeignKey(), null);
        }
    },
    updateStore: function(e) {
        this.getOwnerModel().prototype[this.getName()] = e;
    },
    read: function(e, t, i) {
        var n = e[this.getName()](), r = t.read(i).getRecords();
        n.add(r);
    },
    updateInverseInstances: function(e) {
        var t = e[this.getName()](), i = this.getInverseAssociation();
        if (i) {
            t.each(function(t) {
                t[i.getInstanceName()] = e;
            });
        }
    },
    getInverseAssociation: function() {
        var e = this.getOwnerModel().modelName;
        return this.getAssociatedModel().associations.findBy(function(t) {
            return t.getType().toLowerCase() === "belongsto" && t.getAssociatedModel().modelName === e;
        });
    }
}, function() {
    Ext.deprecateProperty(this, "storeConfig", "store");
});

Ext.define("Ext.data.association.BelongsTo", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.BelongsToAssociation",
    alias: "association.belongsto",
    config: {
        foreignKey: undefined,
        getterName: undefined,
        setterName: undefined,
        instanceName: undefined
    },
    applyForeignKey: function(e) {
        if (!e) {
            e = this.getAssociatedName().toLowerCase() + "_id";
        }
        return e;
    },
    updateForeignKey: function(e, t) {
        var i = this.getOwnerModel().getFields(), n = i.get(e);
        if (!n) {
            n = new Ext.data.Field({
                name: e
            });
            i.add(n);
            i.isDirty = true;
        }
        if (t) {
            n = i.get(t);
            if (n) {
                i.isDirty = true;
                i.remove(n);
            }
        }
    },
    applyInstanceName: function(e) {
        if (!e) {
            e = this.getAssociatedName() + "BelongsToInstance";
        }
        return e;
    },
    applyAssociationKey: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = t[0].toLowerCase() + t.slice(1);
        }
        return e;
    },
    applyGetterName: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = "get" + t[0].toUpperCase() + t.slice(1);
        }
        return e;
    },
    applySetterName: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = "set" + t[0].toUpperCase() + t.slice(1);
        }
        return e;
    },
    updateGetterName: function(e, t) {
        var i = this.getOwnerModel().prototype;
        if (t) {
            delete i[t];
        }
        if (e) {
            i[e] = this.createGetter();
        }
    },
    updateSetterName: function(e, t) {
        var i = this.getOwnerModel().prototype;
        if (t) {
            delete i[t];
        }
        if (e) {
            i[e] = this.createSetter();
        }
    },
    createSetter: function() {
        var e = this, t = e.getForeignKey(), i = e.getAssociatedModel(), n, r, s;
        return function(a, o, l) {
            var u = e.getInverseAssociation(), c = this;
            if (a && a.isModel) {
                a = a.getId();
            }
            if (Ext.isFunction(o)) {
                o = {
                    callback: o,
                    scope: l || c
                };
            }
            delete c[e.getInstanceName()];
            n = Ext.data.Model.cache[Ext.data.Model.generateCacheId(i.modelName, this.get(t))];
            r = Ext.data.Model.cache[Ext.data.Model.generateCacheId(i.modelName, a)];
            c.set(t, a);
            if (u) {
                if (r) {
                    if (u.getType().toLowerCase() === "hasmany") {
                        s = r[u.getName()]();
                        s.add(c);
                    } else {
                        r[u.getInstanceName()] = c;
                    }
                }
                if (n) {
                    if (u.getType().toLowerCase() === "hasmany") {
                        s = n[u.getName()]();
                        s.remove(c);
                    } else {
                        delete a[u.getInstanceName()];
                    }
                }
            }
            if (r) {
                c[e.getInstanceName()] = r;
            }
            if (Ext.isObject(o)) {
                return c.save(o);
            }
            return c;
        };
    },
    createGetter: function() {
        var e = this, t = e.getAssociatedModel(), i = e.getForeignKey(), n = e.getInstanceName();
        return function(e, r) {
            e = e || {};
            var s = this, a = s.get(i), o, l, u;
            l = s[n];
            if (!l) {
                l = Ext.data.Model.cache[Ext.data.Model.generateCacheId(t.modelName, a)];
                if (l) {
                    s[n] = l;
                }
            }
            if (e.reload === true || l === undefined) {
                if (typeof e == "function") {
                    e = {
                        callback: e,
                        scope: r || s
                    };
                }
                o = e.success;
                e.success = function(e) {
                    s[n] = e;
                    if (o) {
                        o.apply(this, arguments);
                    }
                };
                t.load(a, e);
            } else {
                u = [ l ];
                r = r || s;
                Ext.callback(e, r, u);
                Ext.callback(e.success, r, u);
                Ext.callback(e.failure, r, u);
                Ext.callback(e.callback, r, u);
                return l;
            }
        };
    },
    read: function(e, t, i) {
        e[this.getInstanceName()] = t.read([ i ]).getRecords()[0];
    },
    getInverseAssociation: function() {
        var e = this.getOwnerModel().modelName, t = this.getForeignKey();
        return this.getAssociatedModel().associations.findBy(function(i) {
            var n = i.getType().toLowerCase();
            return (n === "hasmany" || n === "hasone") && i.getAssociatedModel().modelName === e && i.getForeignKey() === t;
        });
    }
});

Ext.define("Ext.data.association.HasOne", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.HasOneAssociation",
    alias: "association.hasone",
    config: {
        foreignKey: undefined,
        getterName: undefined,
        setterName: undefined,
        instanceName: undefined
    },
    applyForeignKey: function(e) {
        if (!e) {
            var t = this.getInverseAssociation();
            if (t) {
                e = t.getForeignKey();
            } else {
                e = this.getAssociatedName().toLowerCase() + "_id";
            }
        }
        return e;
    },
    updateForeignKey: function(e, t) {
        var i = this.getOwnerModel().getFields(), n = i.get(e);
        if (!n) {
            n = new Ext.data.Field({
                name: e
            });
            i.add(n);
            i.isDirty = true;
        }
        if (t) {
            n = i.get(t);
            if (n) {
                i.remove(n);
                i.isDirty = true;
            }
        }
    },
    applyInstanceName: function(e) {
        if (!e) {
            e = this.getAssociatedName() + "HasOneInstance";
        }
        return e;
    },
    applyAssociationKey: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = t[0].toLowerCase() + t.slice(1);
        }
        return e;
    },
    applyGetterName: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = "get" + t[0].toUpperCase() + t.slice(1);
        }
        return e;
    },
    applySetterName: function(e) {
        if (!e) {
            var t = this.getAssociatedName();
            e = "set" + t[0].toUpperCase() + t.slice(1);
        }
        return e;
    },
    updateGetterName: function(e, t) {
        var i = this.getOwnerModel().prototype;
        if (t) {
            delete i[t];
        }
        if (e) {
            i[e] = this.createGetter();
        }
    },
    updateSetterName: function(e, t) {
        var i = this.getOwnerModel().prototype;
        if (t) {
            delete i[t];
        }
        if (e) {
            i[e] = this.createSetter();
        }
    },
    createSetter: function() {
        var e = this, t = e.getForeignKey(), i = e.getInstanceName(), n = e.getAssociatedModel();
        return function(e, r, s) {
            var a = Ext.data.Model, o;
            if (e && e.isModel) {
                e = e.getId();
            }
            this.set(t, e);
            o = a.cache[a.generateCacheId(n.modelName, e)];
            if (o) {
                this[i] = o;
            }
            if (Ext.isFunction(r)) {
                r = {
                    callback: r,
                    scope: s || this
                };
            }
            if (Ext.isObject(r)) {
                return this.save(r);
            }
            return this;
        };
    },
    createGetter: function() {
        var e = this, t = e.getAssociatedModel(), i = e.getForeignKey(), n = e.getInstanceName();
        return function(e, r) {
            e = e || {};
            var s = this, a = s.get(i), o, l, u;
            if (e.reload === true || s[n] === undefined) {
                if (typeof e == "function") {
                    e = {
                        callback: e,
                        scope: r || s
                    };
                }
                o = e.success;
                e.success = function(e) {
                    s[n] = e;
                    if (o) {
                        o.call(this, arguments);
                    }
                };
                t.load(a, e);
            } else {
                l = s[n];
                u = [ l ];
                r = r || s;
                Ext.callback(e, r, u);
                Ext.callback(e.success, r, u);
                Ext.callback(e.failure, r, u);
                Ext.callback(e.callback, r, u);
                return l;
            }
        };
    },
    read: function(e, t, i) {
        var n = this.getInverseAssociation(), r = t.read([ i ]).getRecords()[0];
        e[this.getInstanceName()] = r;
        if (n) {
            r[n.getInstanceName()] = e;
        }
    },
    getInverseAssociation: function() {
        var e = this.getOwnerModel().modelName;
        return this.getAssociatedModel().associations.findBy(function(t) {
            return t.getType().toLowerCase() === "belongsto" && t.getAssociatedModel().modelName === e;
        });
    }
});

Ext.define("Ext.data.Model", {
    alternateClassName: "Ext.data.Record",
    mixins: {
        observable: "Ext.mixin.Observable"
    },
    isModel: true,
    requires: [ "Ext.util.Collection", "Ext.data.Field", "Ext.data.identifier.Simple", "Ext.data.ModelManager", "Ext.data.proxy.Ajax", "Ext.data.association.HasMany", "Ext.data.association.BelongsTo", "Ext.data.association.HasOne", "Ext.data.Errors" ],
    config: {
        idProperty: "id",
        data: null,
        fields: undefined,
        validations: null,
        associations: null,
        hasMany: null,
        hasOne: null,
        belongsTo: null,
        proxy: null,
        identifier: {
            type: "simple"
        },
        clientIdProperty: "clientId",
        isErased: false,
        useCache: true
    },
    staticConfigs: [ "idProperty", "fields", "validations", "associations", "hasMany", "hasOne", "belongsTo", "clientIdProperty", "identifier", "useCache", "proxy" ],
    statics: {
        EDIT: "edit",
        REJECT: "reject",
        COMMIT: "commit",
        cache: {},
        generateProxyMethod: function(e) {
            return function() {
                var t = this.prototype;
                return t[e].apply(t, arguments);
            };
        },
        generateCacheId: function(e, t) {
            var i;
            if (e && e.isModel) {
                i = e.modelName;
                if (t === undefined) {
                    t = e.getId();
                }
            } else {
                i = e;
            }
            return i.replace(/\./g, "-").toLowerCase() + "-" + t;
        }
    },
    inheritableStatics: {
        load: function(e, t, i) {
            var n = this.getProxy(), r = this.getIdProperty(), s = null, a = {}, o, l;
            i = i || t && t.scope || this;
            if (Ext.isFunction(t)) {
                t = {
                    callback: t,
                    scope: i
                };
            }
            a[r] = e;
            t = Ext.apply({}, t);
            t = Ext.applyIf(t, {
                action: "read",
                params: a,
                model: this
            });
            l = Ext.create("Ext.data.Operation", t);
            if (!n) {
                Ext.Logger.error("You are trying to load a model that doesn't have a Proxy specified");
            }
            o = function(e) {
                if (e.wasSuccessful()) {
                    s = e.getRecords()[0] || null;
                    Ext.callback(t.success, i, [ s, e ]);
                } else {
                    Ext.callback(t.failure, i, [ s, e ]);
                }
                Ext.callback(t.callback, i, [ s, e ]);
            };
            n.read(l, o, this);
        }
    },
    editing: false,
    dirty: false,
    phantom: false,
    constructor: function(e, t, i, n) {
        var r = this, s = null, a = r.getUseCache(), o = r.getIdProperty();
        r.modified = {};
        r.raw = i || e || {};
        r.stores = [];
        e = e || n || {};
        if (t || t === 0) {
            e[o] = r.internalId = t;
        }
        t = e[o];
        if (a && (t || t === 0)) {
            s = Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, t)];
            if (s) {
                return s.mergeData(n || e || {});
            }
        }
        if (n) {
            r.setConvertedData(e);
        } else {
            r.setData(e);
        }
        t = r.data[o];
        if (!t && t !== 0) {
            r.data[o] = r.internalId = r.id = r.getIdentifier().generate(r);
            r.phantom = true;
            if (this.associations.length) {
                this.handleInlineAssociationData(e);
            }
        } else {
            r.id = r.getIdentifier().generate(r);
        }
        if (a) {
            Ext.data.Model.cache[Ext.data.Model.generateCacheId(r)] = r;
        }
        if (this.init && typeof this.init == "function") {
            this.init();
        }
    },
    mergeData: function(e) {
        var t = this, i = t.getFields().items, n = i.length, r = t.modified, s = t.data, a, o, l, u, c;
        for (a = 0; a < n; a++) {
            o = i[a];
            l = o._name;
            u = e[l];
            if (u !== undefined && !r.hasOwnProperty(l)) {
                if (o._convert) {
                    u = o._convert(u, t);
                }
                s[l] = u;
            }
        }
        if (t.associations.length) {
            t.handleInlineAssociationData(e);
        }
        return this;
    },
    setData: function(e) {
        var t = this, i = t.fields.items, n = i.length, r = Ext.isArray(e), s = t._data = t.data = {}, a, o, l, u, c, f;
        if (!e) {
            return t;
        }
        for (a = 0; a < n; a++) {
            o = i[a];
            l = o._name;
            c = o._convert;
            if (r) {
                u = e[a];
            } else {
                u = e[l];
                if (typeof u == "undefined") {
                    u = o._defaultValue;
                }
            }
            if (c) {
                u = o._convert(u, t);
            }
            s[l] = u;
        }
        f = t.getId();
        if (t.associations.length && (f || f === 0)) {
            t.handleInlineAssociationData(e);
        }
        return t;
    },
    handleInlineAssociationData: function(e) {
        var t = this.associations.items, i = t.length, n, r, s, a, o, l;
        for (n = 0; n < i; n++) {
            r = t[n];
            l = r.getAssociationKey();
            s = e[l];
            if (s) {
                a = r.getReader();
                if (!a) {
                    o = r.getAssociatedModel().getProxy();
                    if (o) {
                        a = o.getReader();
                    } else {
                        a = new Ext.data.JsonReader({
                            model: r.getAssociatedModel()
                        });
                    }
                }
                r.read(this, a, s);
            }
        }
    },
    setId: function(e) {
        var t = this.getId();
        this.set(this.getIdProperty(), e);
        this.internalId = e;
        if (this.getUseCache()) {
            delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, t)];
            Ext.data.Model.cache[Ext.data.Model.generateCacheId(this)] = this;
        }
    },
    getId: function() {
        return this.get(this.getIdProperty());
    },
    setConvertedData: function(e) {
        this._data = this.data = e;
        return this;
    },
    get: function(e) {
        return this.data[e];
    },
    set: function(e, t) {
        var i = this, n = i.fields.map, r = i.modified, s = !i.editing, a = 0, o = [], l, u, c, f, d, h;
        if (arguments.length == 1) {
            for (u in e) {
                if (e.hasOwnProperty(u)) {
                    l = n[u];
                    if (l && l.hasCustomConvert()) {
                        o.push(u);
                        continue;
                    }
                    if (!a && s) {
                        i.beginEdit();
                    }
                    ++a;
                    i.set(u, e[u]);
                }
            }
            d = o.length;
            if (d) {
                if (!a && s) {
                    i.beginEdit();
                }
                a += d;
                for (c = 0; c < d; c++) {
                    l = o[c];
                    i.set(l, e[l]);
                }
            }
            if (s && a) {
                i.endEdit(false, o);
            }
        } else {
            l = n[e];
            h = l && l.getConvert();
            if (h) {
                t = h.call(l, t, i);
            }
            f = i.data[e];
            i.data[e] = t;
            if (l && !i.isEqual(f, t)) {
                if (r.hasOwnProperty(e)) {
                    if (i.isEqual(r[e], t)) {
                        delete r[e];
                        i.dirty = false;
                        for (u in r) {
                            if (r.hasOwnProperty(u)) {
                                i.dirty = true;
                                break;
                            }
                        }
                    }
                } else {
                    i.dirty = true;
                    r[e] = f;
                }
            }
            if (s) {
                i.afterEdit([ e ], r);
            }
        }
    },
    isEqual: function(e, t) {
        if (Ext.isDate(e) && Ext.isDate(t)) {
            return e.getTime() === t.getTime();
        }
        return e === t;
    },
    beginEdit: function() {
        var e = this;
        if (!e.editing) {
            e.editing = true;
            e.dirtySave = e.dirty;
            e.dataSave = Ext.apply({}, e.data);
            e.modifiedSave = Ext.apply({}, e.modified);
        }
    },
    cancelEdit: function() {
        var e = this;
        if (e.editing) {
            e.editing = false;
            e.modified = e.modifiedSave;
            e.data = e.dataSave;
            e.dirty = e.dirtySave;
            delete e.modifiedSave;
            delete e.dataSave;
            delete e.dirtySave;
        }
    },
    endEdit: function(e, t) {
        var i = this;
        if (i.editing) {
            i.editing = false;
            if (e !== true && i.changedWhileEditing()) {
                i.afterEdit(t || Ext.Object.getKeys(this.modified), this.modified);
            }
            delete i.modifiedSave;
            delete i.dataSave;
            delete i.dirtySave;
        }
    },
    changedWhileEditing: function() {
        var e = this, t = e.dataSave, i = e.data, n;
        for (n in i) {
            if (i.hasOwnProperty(n)) {
                if (!e.isEqual(i[n], t[n])) {
                    return true;
                }
            }
        }
        return false;
    },
    getChanges: function() {
        var e = this.modified, t = {}, i;
        for (i in e) {
            if (e.hasOwnProperty(i)) {
                t[i] = this.get(i);
            }
        }
        return t;
    },
    isModified: function(e) {
        return this.modified.hasOwnProperty(e);
    },
    save: function(e, t) {
        var i = this, n = i.phantom ? "create" : "update", r = i.getProxy(), s, a;
        if (!r) {
            Ext.Logger.error("You are trying to save a model instance that doesn't have a Proxy specified");
        }
        e = e || {};
        t = t || i;
        if (Ext.isFunction(e)) {
            e = {
                callback: e,
                scope: t
            };
        }
        Ext.applyIf(e, {
            records: [ i ],
            action: n,
            model: i.self
        });
        s = Ext.create("Ext.data.Operation", e);
        a = function(n) {
            if (n.wasSuccessful()) {
                Ext.callback(e.success, t, [ i, n ]);
            } else {
                Ext.callback(e.failure, t, [ i, n ]);
            }
            Ext.callback(e.callback, t, [ i, n ]);
        };
        r[n](s, a, i);
        return i;
    },
    erase: function(e, t) {
        var i = this, n = this.getProxy(), r, s;
        if (!n) {
            Ext.Logger.error("You are trying to erase a model instance that doesn't have a Proxy specified");
        }
        e = e || {};
        t = t || i;
        if (Ext.isFunction(e)) {
            e = {
                callback: e,
                scope: t
            };
        }
        Ext.applyIf(e, {
            records: [ i ],
            action: "destroy",
            model: this.self
        });
        r = Ext.create("Ext.data.Operation", e);
        s = function(n) {
            if (n.wasSuccessful()) {
                Ext.callback(e.success, t, [ i, n ]);
            } else {
                Ext.callback(e.failure, t, [ i, n ]);
            }
            Ext.callback(e.callback, t, [ i, n ]);
        };
        n.destroy(r, s, i);
        return i;
    },
    reject: function(e) {
        var t = this, i = t.modified, n;
        for (n in i) {
            if (i.hasOwnProperty(n)) {
                if (typeof i[n] != "function") {
                    t.data[n] = i[n];
                }
            }
        }
        t.dirty = false;
        t.editing = false;
        t.modified = {};
        if (e !== true) {
            t.afterReject();
        }
    },
    commit: function(e) {
        var t = this, i = this.modified;
        t.phantom = t.dirty = t.editing = false;
        t.modified = {};
        if (e !== true) {
            t.afterCommit(i);
        }
    },
    afterEdit: function(e, t) {
        this.notifyStores("afterEdit", e, t);
    },
    afterReject: function() {
        this.notifyStores("afterReject");
    },
    afterCommit: function(e) {
        this.notifyStores("afterCommit", Ext.Object.getKeys(e || {}), e);
    },
    notifyStores: function(e) {
        var t = Ext.Array.clone(arguments), i = this.stores, n = i.length, r, s;
        t[0] = this;
        for (r = 0; r < n; ++r) {
            s = i[r];
            if (s !== undefined && typeof s[e] == "function") {
                s[e].apply(s, t);
            }
        }
    },
    copy: function(e) {
        var t = this, i = t.getIdProperty(), n = Ext.apply({}, t.raw), r = Ext.apply({}, t.data);
        delete n[i];
        delete r[i];
        return new t.self(null, e, n, r);
    },
    getData: function(e) {
        var t = this.data;
        if (e === true) {
            Ext.apply(t, this.getAssociatedData());
        }
        return t;
    },
    getAssociatedData: function() {
        return this.prepareAssociatedData(this, [], null);
    },
    prepareAssociatedData: function(e, t, i) {
        var n = e.associations.items, r = n.length, s = {}, a, o, l, u, c, f, d, h, g, p, m;
        for (h = 0; h < r; h++) {
            f = n[h];
            o = f.getName();
            p = f.getType();
            m = true;
            if (i) {
                m = p == i;
            }
            if (m && p.toLowerCase() == "hasmany") {
                a = e[f.getStoreName()];
                s[o] = [];
                if (a && a.getCount() > 0) {
                    l = a.data.items;
                    c = l.length;
                    for (g = 0; g < c; g++) {
                        u = l[g];
                        d = u.id;
                        if (Ext.Array.indexOf(t, d) == -1) {
                            t.push(d);
                            s[o][g] = u.getData();
                            Ext.apply(s[o][g], this.prepareAssociatedData(u, t, i));
                        }
                    }
                }
            } else if (m && (p.toLowerCase() == "belongsto" || p.toLowerCase() == "hasone")) {
                u = e[f.getInstanceName()];
                if (u !== undefined) {
                    d = u.id;
                    if (Ext.Array.indexOf(t, d) === -1) {
                        t.push(d);
                        s[o] = u.getData();
                        Ext.apply(s[o], this.prepareAssociatedData(u, t, i));
                    }
                }
            }
        }
        return s;
    },
    join: function(e) {
        Ext.Array.include(this.stores, e);
    },
    unjoin: function(e) {
        Ext.Array.remove(this.stores, e);
    },
    setDirty: function() {
        var e = this, t;
        e.dirty = true;
        e.fields.each(function(i) {
            if (i.getPersist()) {
                t = i.getName();
                e.modified[t] = e.get(t);
            }
        });
    },
    validate: function() {
        var e = Ext.create("Ext.data.Errors"), t = this.getValidations().items, i = Ext.data.Validations, n, r, s, a, o, l;
        if (t) {
            n = t.length;
            for (l = 0; l < n; l++) {
                r = t[l];
                s = r.field || r.name;
                o = r.type;
                a = i[o](r, this.get(s));
                if (!a) {
                    e.add(Ext.create("Ext.data.Error", {
                        field: s,
                        message: r.message || i.getMessage(o)
                    }));
                }
            }
        }
        return e;
    },
    isValid: function() {
        return this.validate().isValid();
    },
    toUrl: function() {
        var e = this.$className.split("."), t = e[e.length - 1].toLowerCase();
        return t + "/" + this.getId();
    },
    destroy: function() {
        var e = this;
        e.notifyStores("afterErase", e);
        if (e.getUseCache()) {
            delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(e)];
        }
        e.raw = e.stores = e.modified = null;
        e.callParent(arguments);
    },
    markDirty: function() {
        if (Ext.isDefined(Ext.Logger)) {
            Ext.Logger.deprecate("Ext.data.Model: markDirty has been deprecated. Use setDirty instead.");
        }
        return this.setDirty.apply(this, arguments);
    },
    applyProxy: function(e, t) {
        return Ext.factory(e, Ext.data.Proxy, t, "proxy");
    },
    updateProxy: function(e) {
        if (e) {
            e.setModel(this.self);
        }
    },
    applyAssociations: function(e) {
        if (e) {
            this.addAssociations(e, "hasMany");
        }
    },
    applyBelongsTo: function(e) {
        if (e) {
            this.addAssociations(e, "belongsTo");
        }
    },
    applyHasMany: function(e) {
        if (e) {
            this.addAssociations(e, "hasMany");
        }
    },
    applyHasOne: function(e) {
        if (e) {
            this.addAssociations(e, "hasOne");
        }
    },
    addAssociations: function(e, t) {
        var i, n, r, s = this.self.modelName, a = this.self.associations, o;
        e = Ext.Array.from(e);
        for (n = 0, i = e.length; n < i; n++) {
            r = e[n];
            if (!Ext.isObject(r)) {
                r = {
                    model: r
                };
            }
            Ext.applyIf(r, {
                type: t,
                ownerModel: s,
                associatedModel: r.model
            });
            delete r.model;
            o = Ext.Function.bind(function(e) {
                a.add(Ext.data.association.Association.create(this));
            }, r);
            Ext.ClassManager.onCreated(o, this, typeof r.associatedModel === "string" ? r.associatedModel : Ext.getClassName(r.associatedModel));
        }
    },
    applyValidations: function(e) {
        if (e) {
            if (!Ext.isArray(e)) {
                e = [ e ];
            }
            this.addValidations(e);
        }
    },
    addValidations: function(e) {
        this.self.validations.addAll(e);
    },
    applyFields: function(e) {
        var t = this.superclass.fields;
        if (t) {
            e = t.items.concat(e || []);
        }
        return e || [];
    },
    updateFields: function(e) {
        var t = e.length, i = this, n = i.self.prototype, r = this.getIdProperty(), s, a, o, l;
        a = i._fields = i.fields = new Ext.util.Collection(n.getFieldName);
        for (l = 0; l < t; l++) {
            o = e[l];
            if (!o.isField) {
                o = new Ext.data.Field(e[l]);
            }
            a.add(o);
        }
        s = a.get(r);
        if (!s) {
            a.add(new Ext.data.Field(r));
        } else {
            s.setType("auto");
        }
        a.addSorter(n.sortConvertFields);
    },
    applyIdentifier: function(e) {
        if (typeof e === "string") {
            e = {
                type: e
            };
        }
        return Ext.factory(e, Ext.data.identifier.Simple, this.getIdentifier(), "data.identifier");
    },
    getFieldName: function(e) {
        return e.getName();
    },
    sortConvertFields: function(e, t) {
        var i = e.hasCustomConvert(), n = t.hasCustomConvert();
        if (i && !n) {
            return 1;
        }
        if (!i && n) {
            return -1;
        }
        return 0;
    },
    onClassExtended: function(e, t, i) {
        var n = i.onBeforeCreated, r = this, s = r.prototype, a = Ext.Class.configNameCache, o = s.staticConfigs.concat(t.staticConfigs || []), l = s.config, u = t.config || {}, c;
        if (t.idgen || u.idgen) {
            u.identifier = t.idgen || u.idgen;
            Ext.Logger.deprecate("idgen is deprecated as a property. Please put it inside the config object" + ' under the new "identifier" configuration');
        }
        for (c in l) {
            if (c in t) {
                u[c] = t[c];
                delete t[c];
                Ext.Logger.deprecate(c + " is deprecated as a property directly on the Model prototype. " + "Please put it inside the config object.");
            }
        }
        t.config = u;
        i.onBeforeCreated = function(e, t) {
            var s = [], l = e.prototype, u = {}, c = l.config, f = o.length, d = [ "set", "get" ], h = d.length, g = c.associations || [], p = Ext.getClassName(e), m, x, E, y, v;
            for (E = 0; E < f; E++) {
                m = o[E];
                for (y = 0; y < h; y++) {
                    x = a[m][d[y]];
                    if (x in l) {
                        u[x] = r.generateProxyMethod(x);
                    }
                }
            }
            e.addStatics(u);
            e.modelName = p;
            l.modelName = p;
            if (c.belongsTo) {
                s.push("association.belongsto");
            }
            if (c.hasMany) {
                s.push("association.hasmany");
            }
            if (c.hasOne) {
                s.push("association.hasone");
            }
            for (E = 0, v = g.length; E < v; ++E) {
                s.push("association." + g[E].type.toLowerCase());
            }
            if (c.identifier) {
                if (typeof c.identifier === "string") {
                    s.push("data.identifier." + c.identifier);
                } else if (typeof c.identifier.type === "string") {
                    s.push("data.identifier." + c.identifier.type);
                }
            }
            if (c.proxy) {
                if (typeof c.proxy === "string") {
                    s.push("proxy." + c.proxy);
                } else if (typeof c.proxy.type === "string") {
                    s.push("proxy." + c.proxy.type);
                }
            }
            if (c.validations) {
                s.push("Ext.data.Validations");
            }
            Ext.require(s, function() {
                Ext.Function.interceptBefore(i, "onCreated", function() {
                    Ext.data.ModelManager.registerType(p, e);
                    var t = e.prototype.superclass;
                    e.prototype.associations = e.associations = e.prototype._associations = t && t.associations ? t.associations.clone() : new Ext.util.Collection(function(e) {
                        return e.getName();
                    });
                    e.prototype.validations = e.validations = e.prototype._validations = t && t.validations ? t.validations.clone() : new Ext.util.Collection(function(e) {
                        return e.field ? e.field + "-" + e.type : e.name + "-" + e.type;
                    });
                    e.prototype = Ext.Object.chain(e.prototype);
                    e.prototype.initConfig.call(e.prototype, c);
                    delete e.prototype.initConfig;
                });
                n.call(r, e, t, i);
            });
        };
    }
});

Ext.define("Twitter.model.Tweet", {
    extend: "Ext.data.Model",
    requires: "Twitter.proxy.Twitter",
    config: {
        fields: [ {
            name: "id",
            type: "int"
        }, {
            name: "text",
            type: "string"
        }, {
            name: "from_user",
            type: "string"
        }, {
            name: "profile_image_url",
            type: "string"
        }, {
            name: "created_at",
            type: "string"
        }, {
            name: "metadata"
        }, {
            name: "search_id"
        } ],
        proxy: {
            type: "twitter"
        }
    }
});

Ext.define("Ext.data.Store", {
    alias: "store.store",
    extend: "Ext.Evented",
    requires: [ "Ext.util.Collection", "Ext.data.Operation", "Ext.data.proxy.Memory", "Ext.data.Model", "Ext.data.StoreManager", "Ext.util.Grouper" ],
    statics: {
        create: function(e) {
            if (!e.isStore) {
                if (!e.type) {
                    e.type = "store";
                }
                e = Ext.createByAlias("store." + e.type, e);
            }
            return e;
        }
    },
    isStore: true,
    config: {
        storeId: undefined,
        data: null,
        autoLoad: null,
        autoSync: false,
        model: undefined,
        proxy: undefined,
        fields: null,
        remoteSort: false,
        remoteFilter: false,
        remoteGroup: false,
        filters: null,
        sorters: null,
        grouper: null,
        groupField: null,
        groupDir: null,
        getGroupString: null,
        pageSize: 25,
        totalCount: null,
        clearOnPageLoad: true,
        modelDefaults: {},
        autoDestroy: false,
        syncRemovedRecords: true,
        destroyRemovedRecords: true
    },
    currentPage: 1,
    constructor: function(e) {
        e = e || {};
        this.data = this._data = this.createDataCollection();
        this.data.setSortRoot("data");
        this.data.setFilterRoot("data");
        this.removed = [];
        if (e.id && !e.storeId) {
            e.storeId = e.id;
            delete e.id;
        }
        if (e.hasOwnProperty("sortOnLoad")) {
            Ext.Logger.deprecate("[Ext.data.Store] sortOnLoad is always activated in Sencha Touch 2 so your Store is always fully " + "sorted after loading. The only exception is if you are using remoteSort and change sorting after " + "the Store as loaded, in which case you need to call store.load() to fetch the sorted data from the server.");
        }
        if (e.hasOwnProperty("filterOnLoad")) {
            Ext.Logger.deprecate("[Ext.data.Store] filterOnLoad is always activated in Sencha Touch 2 so your Store is always fully " + "sorted after loading. The only exception is if you are using remoteFilter and change filtering after " + "the Store as loaded, in which case you need to call store.load() to fetch the filtered data from the server.");
        }
        if (e.hasOwnProperty("sortOnFilter")) {
            Ext.Logger.deprecate("[Ext.data.Store] sortOnFilter is deprecated and is always effectively true when sorting and filtering locally");
        }
        this.initConfig(e);
        this.callParent(arguments);
    },
    createDataCollection: function() {
        return new Ext.util.Collection(function(e) {
            return e.getId();
        });
    },
    applyStoreId: function(e) {
        if (e === undefined || e === null) {
            e = this.getUniqueId();
        }
        return e;
    },
    updateStoreId: function(e, t) {
        if (t) {
            Ext.data.StoreManager.unregister(this);
        }
        if (e) {
            Ext.data.StoreManager.register(this);
        }
    },
    applyModel: function(e) {
        if (typeof e == "string") {
            var t = Ext.data.ModelManager.getModel(e);
            if (!t) {
                Ext.Logger.error('Model with name "' + e + '" does not exist.');
            }
            e = t;
        }
        if (e && !e.prototype.isModel && Ext.isObject(e)) {
            e = Ext.data.ModelManager.registerType(e.storeId || e.id || Ext.id(), e);
        }
        if (!e) {
            var i = this.getFields(), n = this.config.data;
            if (!i && n && n.length) {
                i = Ext.Object.getKeys(n[0]);
            }
            if (i) {
                e = Ext.define("Ext.data.Store.ImplicitModel-" + (this.getStoreId() || Ext.id()), {
                    extend: "Ext.data.Model",
                    config: {
                        fields: i,
                        proxy: this.getProxy()
                    }
                });
                this.implicitModel = true;
            }
        }
        if (!e && this.getProxy()) {
            e = this.getProxy().getModel();
        }
        if (!e) {
            Ext.Logger.warn("Unless you define your model through metadata, a store needs to have a model defined on either itself or on its proxy");
        }
        return e;
    },
    updateModel: function(e) {
        var t = this.getProxy();
        if (t && !t.getModel()) {
            t.setModel(e);
        }
    },
    applyProxy: function(e, t) {
        e = Ext.factory(e, Ext.data.Proxy, t, "proxy");
        if (!e && this.getModel()) {
            e = this.getModel().getProxy();
        }
        if (!e) {
            e = new Ext.data.proxy.Memory({
                model: this.getModel()
            });
        }
        if (e.isMemoryProxy) {
            this.setSyncRemovedRecords(false);
        }
        return e;
    },
    updateProxy: function(e) {
        if (e) {
            if (!e.getModel()) {
                e.setModel(this.getModel());
            }
            e.on("metachange", this.onMetaChange, this);
        }
    },
    applyData: function(e) {
        var t = this, i;
        if (e) {
            i = t.getProxy();
            if (i instanceof Ext.data.proxy.Memory) {
                i.setData(e);
                t.load();
                return;
            } else {
                t.removeAll(true);
                t.fireEvent("clear", t);
                t.suspendEvents();
                t.add(e);
                t.resumeEvents();
                t.dataLoaded = true;
            }
        } else {
            t.removeAll(true);
            t.fireEvent("clear", t);
        }
        t.fireEvent("refresh", t, t.data);
    },
    clearData: function() {
        this.setData(null);
    },
    addData: function(e) {
        var t = this.getProxy().getReader(), i = t.read(e), n = i.getRecords();
        this.add(n);
    },
    updateAutoLoad: function(e) {
        var t = this.getProxy();
        if (e && t && !t.isMemoryProxy) {
            this.load(Ext.isObject(e) ? e : null);
        }
    },
    isAutoLoading: function() {
        var e = this.getProxy();
        return this.getAutoLoad() || e && e.isMemoryProxy || this.dataLoaded;
    },
    updateGroupField: function(e) {
        var t = this.getGrouper();
        if (e) {
            if (!t) {
                this.setGrouper({
                    property: e,
                    direction: this.getGroupDir() || "ASC"
                });
            } else {
                t.setProperty(e);
            }
        } else if (t) {
            this.setGrouper(null);
        }
    },
    updateGroupDir: function(e) {
        var t = this.getGrouper();
        if (t) {
            t.setDirection(e);
        }
    },
    applyGetGroupString: function(e) {
        var t = this.getGrouper();
        if (e) {
            Ext.Logger.warn("Specifying getGroupString on a store has been deprecated. Please use grouper: {groupFn: yourFunction}");
            if (t) {
                t.setGroupFn(e);
            } else {
                this.setGrouper({
                    groupFn: e
                });
            }
        } else if (t) {
            this.setGrouper(null);
        }
    },
    applyGrouper: function(e) {
        if (typeof e == "string") {
            e = {
                property: e
            };
        } else if (typeof e == "function") {
            e = {
                groupFn: e
            };
        }
        e = Ext.factory(e, Ext.util.Grouper, this.getGrouper());
        return e;
    },
    updateGrouper: function(e, t) {
        var i = this.data;
        if (t) {
            i.removeSorter(t);
            if (!e) {
                i.getSorters().removeSorter("isGrouper");
            }
        }
        if (e) {
            i.insertSorter(0, e);
            if (!t) {
                i.getSorters().addSorter({
                    direction: "DESC",
                    property: "isGrouper",
                    transform: function(e) {
                        return e === true ? 1 : -1;
                    }
                });
            }
        }
    },
    isGrouped: function() {
        return !!this.getGrouper();
    },
    updateSorters: function(e) {
        var t = this.getGrouper(), i = this.data, n = i.getAutoSort();
        i.setAutoSort(false);
        i.setSorters(e);
        if (t) {
            i.insertSorter(0, t);
        }
        this.updateSortTypes();
        i.setAutoSort(n);
    },
    updateSortTypes: function() {
        var e = this.getModel(), t = e && e.getFields(), i = this.data;
        if (t) {
            i.getSorters().each(function(e) {
                var i = e.getProperty(), n;
                if (!e.isGrouper && i && !e.getTransform()) {
                    n = t.get(i);
                    if (n) {
                        e.setTransform(n.getSortType());
                    }
                }
            });
        }
    },
    updateFilters: function(e) {
        this.data.setFilters(e);
    },
    add: function(e) {
        if (!Ext.isArray(e)) {
            e = Array.prototype.slice.call(arguments);
        }
        return this.insert(this.data.length, e);
    },
    insert: function(e, t) {
        if (!Ext.isArray(t)) {
            t = Array.prototype.slice.call(arguments, 1);
        }
        var i = this, n = false, r = this.data, s = t.length, a = this.getModel(), o = i.getModelDefaults(), l = false, u, c;
        t = t.slice();
        for (u = 0; u < s; u++) {
            c = t[u];
            if (!c.isModel) {
                c = new a(c);
            } else if (this.removed.indexOf(c) != -1) {
                Ext.Array.remove(this.removed, c);
            }
            c.set(o);
            c.join(i);
            t[u] = c;
            n = n || c.phantom === true;
        }
        if (t.length === 1) {
            l = r.insert(e, t[0]);
            if (l) {
                l = [ l ];
            }
        } else {
            l = r.insertAll(e, t);
        }
        if (l) {
            i.fireEvent("addrecords", i, l);
        }
        if (i.getAutoSync() && n) {
            i.sync();
        }
        return t;
    },
    remove: function(e) {
        if (e.isModel) {
            e = [ e ];
        }
        var t = this, i = false, n = 0, r = this.getAutoSync(), s = t.getSyncRemovedRecords(), a = this.getDestroyRemovedRecords(), o = e.length, l = [], u = [], c, f = t.data.items, d, h, g;
        for (;n < o; n++) {
            d = e[n];
            if (t.data.contains(d)) {
                c = d.phantom === true;
                h = f.indexOf(d);
                if (h !== -1) {
                    u.push(d);
                    l.push(h);
                }
                d.unjoin(t);
                t.data.remove(d);
                if (a && !s && !d.stores.length) {
                    d.destroy();
                } else if (!c && s) {
                    t.removed.push(d);
                }
                i = i || !c;
            }
        }
        t.fireEvent("removerecords", t, u, l);
        if (r && i) {
            t.sync();
        }
    },
    removeAt: function(e) {
        var t = this.getAt(e);
        if (t) {
            this.remove(t);
        }
    },
    removeAll: function(e) {
        if (e !== true && this.eventFiringSuspended !== true) {
            this.fireAction("clear", [ this ], "doRemoveAll");
        } else {
            this.doRemoveAll.call(this, true);
        }
    },
    doRemoveAll: function(e) {
        var t = this, i = this.getDestroyRemovedRecords(), n = this.getSyncRemovedRecords(), r = t.data.all.slice(), s = r.length, a, o;
        for (a = 0; a < s; a++) {
            o = r[a];
            o.unjoin(t);
            if (i && !n && !o.stores.length) {
                o.destroy();
            } else if (o.phantom !== true && n) {
                t.removed.push(o);
            }
        }
        t.data.clear();
        if (e !== true) {
            t.fireEvent("refresh", t, t.data);
        }
        if (t.getAutoSync()) {
            this.sync();
        }
    },
    each: function(e, t) {
        this.data.each(e, t);
    },
    getCount: function() {
        return this.data.items.length || 0;
    },
    getAllCount: function() {
        return this.data.all.length || 0;
    },
    getAt: function(e) {
        return this.data.getAt(e);
    },
    getRange: function(e, t) {
        return this.data.getRange(e, t);
    },
    getById: function(e) {
        return this.data.findBy(function(t) {
            return t.getId() == e;
        });
    },
    indexOf: function(e) {
        return this.data.indexOf(e);
    },
    indexOfId: function(e) {
        return this.data.indexOfKey(e);
    },
    afterEdit: function(e, t, i) {
        var n = this, r = n.data, s = i[e.getIdProperty()] || e.getId(), a = r.keys.indexOf(s), o;
        if (a === -1 && r.map[s] === undefined) {
            return;
        }
        if (n.getAutoSync()) {
            n.sync();
        }
        if (s !== e.getId()) {
            r.replace(s, e);
        } else {
            r.replace(e);
        }
        o = r.indexOf(e);
        if (a === -1 && o !== -1) {
            n.fireEvent("addrecords", n, [ e ]);
        } else if (a !== -1 && o === -1) {
            n.fireEvent("removerecords", n, [ e ], [ a ]);
        } else if (o !== -1) {
            n.fireEvent("updaterecord", n, e, o, a, t, i);
        }
    },
    afterReject: function(e) {
        var t = this.data.indexOf(e);
        this.fireEvent("updaterecord", this, e, t, t, [], {});
    },
    afterCommit: function(e, t, i) {
        var n = this, r = n.data, s = i[e.getIdProperty()] || e.getId(), a = r.keys.indexOf(s), o;
        if (a === -1 && r.map[s] === undefined) {
            return;
        }
        if (s !== e.getId()) {
            r.replace(s, e);
        } else {
            r.replace(e);
        }
        o = r.indexOf(e);
        if (a === -1 && o !== -1) {
            n.fireEvent("addrecords", n, [ e ]);
        } else if (a !== -1 && o === -1) {
            n.fireEvent("removerecords", n, [ e ], [ a ]);
        } else if (o !== -1) {
            n.fireEvent("updaterecord", n, e, o, a, t, i);
        }
    },
    afterErase: function(e) {
        var t = this, i = t.data, n = i.indexOf(e);
        if (n !== -1) {
            i.remove(e);
            t.fireEvent("removerecords", t, [ e ], [ n ]);
        }
    },
    updateRemoteFilter: function(e) {
        this.data.setAutoFilter(!e);
    },
    updateRemoteSort: function(e) {
        this.data.setAutoSort(!e);
    },
    sort: function(e, t, i) {
        var n = this.data, r = this.getGrouper(), s = n.getAutoSort();
        if (e) {
            n.setAutoSort(false);
            if (typeof i === "string") {
                if (i == "prepend") {
                    n.insertSorters(r ? 1 : 0, e, t);
                } else {
                    n.addSorters(e, t);
                }
            } else {
                n.setSorters(null);
                if (r) {
                    n.addSorters(r);
                }
                n.addSorters(e, t);
            }
            this.updateSortTypes();
            n.setAutoSort(s);
        }
        if (!this.getRemoteSort()) {
            if (!e) {
                this.data.sort();
            }
            this.fireEvent("sort", this, this.data, this.data.getSorters());
            if (n.length) {
                this.fireEvent("refresh", this, this.data);
            }
        }
    },
    filter: function(e, t, i, n) {
        var r = this.data, s = null;
        if (e) {
            if (Ext.isFunction(e)) {
                s = {
                    filterFn: e
                };
            } else if (Ext.isArray(e) || e.isFilter) {
                s = e;
            } else {
                s = {
                    property: e,
                    value: t,
                    anyMatch: i,
                    caseSensitive: n,
                    id: e
                };
            }
        }
        if (this.getRemoteFilter()) {
            r.addFilters(s);
        } else {
            r.filter(s);
            this.fireEvent("filter", this, r, r.getFilters());
            this.fireEvent("refresh", this, r);
        }
    },
    filterBy: function(e, t) {
        var i = this, n = i.data, r = n.length;
        n.filter({
            filterFn: function(n) {
                return e.call(t || i, n, n.getId());
            }
        });
        this.fireEvent("filter", this, n, n.getFilters());
        if (n.length !== r) {
            this.fireEvent("refresh", this, n);
        }
    },
    queryBy: function(e, t) {
        return this.data.filterBy(e, t || this);
    },
    clearFilter: function(e) {
        var t = this.data.length;
        if (e) {
            this.suspendEvents();
        }
        this.data.setFilters(null);
        if (e) {
            this.resumeEvents();
        } else if (t !== this.data.length) {
            this.fireEvent("refresh", this, this.data);
        }
    },
    isFiltered: function() {
        return this.data.filtered;
    },
    isSorted: function() {
        return this.data.sorted;
    },
    getSorters: function() {
        var e = this.data.getSorters();
        return e ? e.items : [];
    },
    getFilters: function() {
        var e = this.data.getFilters();
        return e ? e.items : [];
    },
    getGroups: function(e) {
        var t = this.data.items, i = t.length, n = this.getGrouper(), r = [], s = {}, a, o, l, u;
        if (!n) {
            Ext.Logger.error("Trying to get groups for a store that has no grouper");
        }
        for (u = 0; u < i; u++) {
            a = t[u];
            o = n.getGroupString(a);
            l = s[o];
            if (l === undefined) {
                l = {
                    name: o,
                    children: []
                };
                r.push(l);
                s[o] = l;
            }
            l.children.push(a);
        }
        return e ? s[e] : r;
    },
    getGroupString: function(e) {
        var t = this.getGrouper();
        if (t) {
            return t.getGroupString(e);
        }
        return null;
    },
    find: function(e, t, i, n, r, s) {
        var a = Ext.create("Ext.util.Filter", {
            property: e,
            value: t,
            anyMatch: n,
            caseSensitive: r,
            exactMatch: s,
            root: "data"
        });
        return this.data.findIndexBy(a.getFilterFn(), null, i);
    },
    findRecord: function() {
        var e = this, t = e.find.apply(e, arguments);
        return t !== -1 ? e.getAt(t) : null;
    },
    findExact: function(e, t, i) {
        return this.data.findIndexBy(function(i) {
            return i.get(e) === t;
        }, this, i);
    },
    findBy: function(e, t, i) {
        return this.data.findIndexBy(e, t, i);
    },
    load: function(e, t) {
        var i = this, n, r = i.currentPage, s = i.getPageSize();
        e = e || {};
        if (Ext.isFunction(e)) {
            e = {
                callback: e,
                scope: t || this
            };
        }
        if (i.getRemoteSort()) {
            e.sorters = e.sorters || this.getSorters();
        }
        if (i.getRemoteFilter()) {
            e.filters = e.filters || this.getFilters();
        }
        if (i.getRemoteGroup()) {
            e.grouper = e.grouper || this.getGrouper();
        }
        Ext.applyIf(e, {
            page: r,
            start: (r - 1) * s,
            limit: s,
            addRecords: false,
            action: "read",
            model: this.getModel()
        });
        n = Ext.create("Ext.data.Operation", e);
        if (i.fireEvent("beforeload", i, n) !== false) {
            i.loading = true;
            i.getProxy().read(n, i.onProxyLoad, i);
        }
        return i;
    },
    isLoading: function() {
        return Boolean(this.loading);
    },
    isLoaded: function() {
        return Boolean(this.loaded);
    },
    sync: function() {
        var e = this, t = {}, i = e.getNewRecords(), n = e.getUpdatedRecords(), r = e.getRemovedRecords(), s = false;
        if (i.length > 0) {
            t.create = i;
            s = true;
        }
        if (n.length > 0) {
            t.update = n;
            s = true;
        }
        if (r.length > 0) {
            t.destroy = r;
            s = true;
        }
        if (s && e.fireEvent("beforesync", this, t) !== false) {
            e.getProxy().batch({
                operations: t,
                listeners: e.getBatchListeners()
            });
        }
        return {
            added: i,
            updated: n,
            removed: r
        };
    },
    first: function() {
        return this.data.first();
    },
    last: function() {
        return this.data.last();
    },
    sum: function(e) {
        var t = 0, i = 0, n = this.data.items, r = n.length;
        for (;i < r; ++i) {
            t += n[i].get(e);
        }
        return t;
    },
    min: function(e) {
        var t = 1, i = this.data.items, n = i.length, r, s;
        if (n > 0) {
            s = i[0].get(e);
        }
        for (;t < n; ++t) {
            r = i[t].get(e);
            if (r < s) {
                s = r;
            }
        }
        return s;
    },
    max: function(e) {
        var t = 1, i = this.data.items, n = i.length, r, s;
        if (n > 0) {
            s = i[0].get(e);
        }
        for (;t < n; ++t) {
            r = i[t].get(e);
            if (r > s) {
                s = r;
            }
        }
        return s;
    },
    average: function(e) {
        var t = 0, i = this.data.items, n = i.length, r = 0;
        if (i.length > 0) {
            for (;t < n; ++t) {
                r += i[t].get(e);
            }
            return r / n;
        }
        return 0;
    },
    getBatchListeners: function() {
        return {
            scope: this,
            exception: this.onBatchException,
            complete: this.onBatchComplete
        };
    },
    onBatchComplete: function(e) {
        var t = this, i = e.operations, n = i.length, r;
        for (r = 0; r < n; r++) {
            t.onProxyWrite(i[r]);
        }
    },
    onBatchException: function(e, t) {},
    onProxyLoad: function(e) {
        var t = this, i = e.getRecords(), n = e.getResultSet(), r = e.wasSuccessful();
        if (n) {
            t.setTotalCount(n.getTotal());
        }
        if (r) {
            this.fireAction("datarefresh", [ this, this.data, e ], "doDataRefresh");
        }
        t.loaded = true;
        t.loading = false;
        t.fireEvent("load", this, i, r, e);
        Ext.callback(e.getCallback(), e.getScope() || t, [ i, e, r ]);
    },
    doDataRefresh: function(e, t, i) {
        var n = i.getRecords(), r = this, s = r.getDestroyRemovedRecords(), a = t.all.slice(), o = a.length, l = n.length, u = {}, c, f;
        if (i.getAddRecords() !== true) {
            for (c = 0; c < l; c++) {
                u[n[c].id] = true;
            }
            for (c = 0; c < o; c++) {
                f = a[c];
                f.unjoin(r);
                if (u[f.id] !== true && s && !f.stores.length) {
                    f.destroy();
                }
            }
            t.clear();
            r.fireEvent("clear", r);
        }
        if (n && n.length) {
            r.suspendEvents();
            r.add(n);
            r.resumeEvents();
        }
        r.fireEvent("refresh", r, t);
    },
    onProxyWrite: function(e) {
        var t = this, i = e.wasSuccessful(), n = e.getRecords();
        switch (e.getAction()) {
          case "create":
            t.onCreateRecords(n, e, i);
            break;

          case "update":
            t.onUpdateRecords(n, e, i);
            break;

          case "destroy":
            t.onDestroyRecords(n, e, i);
            break;
        }
        if (i) {
            t.fireEvent("write", t, e);
        }
        Ext.callback(e.getCallback(), e.getScope() || t, [ n, e, i ]);
    },
    onCreateRecords: function(e, t, i) {},
    onUpdateRecords: function(e, t, i) {},
    onDestroyRecords: function(e, t, i) {
        this.removed = [];
    },
    onMetaChange: function(e) {
        var t = this.getProxy().getModel();
        if (!this.getModel() && t) {
            this.setModel(t);
        }
        this.fireEvent("metachange", this, e);
    },
    getNewRecords: function() {
        return this.data.filterBy(function(e) {
            return e.phantom === true && e.isValid();
        }).items;
    },
    getUpdatedRecords: function() {
        return this.data.filterBy(function(e) {
            return e.dirty === true && e.phantom !== true && e.isValid();
        }).items;
    },
    getRemovedRecords: function() {
        return this.removed;
    },
    loadPage: function(e, t, i) {
        if (typeof t === "function") {
            t = {
                callback: t,
                scope: i || this
            };
        }
        var n = this, r = n.getPageSize(), s = n.getClearOnPageLoad();
        t = Ext.apply({}, t);
        n.currentPage = e;
        n.load(Ext.applyIf(t, {
            page: e,
            start: (e - 1) * r,
            limit: r,
            addRecords: !s
        }));
    },
    nextPage: function(e) {
        this.loadPage(this.currentPage + 1, e);
    },
    previousPage: function(e) {
        this.loadPage(this.currentPage - 1, e);
    },
    destroy: function() {
        Ext.data.StoreManager.unregister(this);
        this.callParent(arguments);
    },
    onClassExtended: function(e, t) {
        var i = this.prototype, n = i.config, r = t.config || {}, s;
        for (s in n) {
            if (s != "control" && s in t) {
                r[s] = t[s];
                delete t[s];
                Ext.Logger.deprecate(s + " is deprecated as a property directly on the " + this.$className + " prototype. Please put it inside the config object.");
            }
        }
        t.config = r;
    }
}, function() {
    this.override({
        loadData: function(e, t) {
            Ext.Logger.deprecate("loadData is deprecated, please use either add or setData");
            if (t) {
                this.add(e);
            } else {
                this.setData(e);
            }
        },
        doAddListener: function(e, t, i, n, r) {
            switch (e) {
              case "update":
                Ext.Logger.warn("The update event on Store has been removed. Please use the updaterecord event from now on.");
                return this;

              case "add":
                Ext.Logger.warn("The add event on Store has been removed. Please use the addrecords event from now on.");
                return this;

              case "remove":
                Ext.Logger.warn("The remove event on Store has been removed. Please use the removerecords event from now on.");
                return this;

              case "datachanged":
                Ext.Logger.warn("The datachanged event on Store has been removed. Please use the refresh event from now on.");
                return this;
                break;
            }
            return this.callParent(arguments);
        }
    });
    Ext.deprecateMethod(this, "loadRecords", "add", "Ext.data.Store#loadRecords has been deprecated. Please use the add method.");
});

Ext.define("Ext.Toolbar", {
    extend: "Ext.Container",
    xtype: "toolbar",
    requires: [ "Ext.Button", "Ext.Title", "Ext.Spacer", "Ext.layout.HBox" ],
    isToolbar: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "toolbar",
        ui: "dark",
        title: null,
        defaultType: "button",
        minHeight: "2.6em",
        layout: {
            type: "hbox",
            align: "center"
        }
    },
    constructor: function(e) {
        e = e || {};
        if (e.docked == "left" || e.docked == "right") {
            e.layout = {
                type: "vbox",
                align: "stretch"
            };
        }
        this.callParent([ e ]);
    },
    applyTitle: function(e) {
        if (typeof e == "string") {
            e = {
                title: e,
                centered: true
            };
        }
        return Ext.factory(e, Ext.Title, this.getTitle());
    },
    updateTitle: function(e, t) {
        if (e) {
            this.add(e);
        }
        if (t) {
            t.destroy();
        }
    },
    showTitle: function() {
        var e = this.getTitle();
        if (e) {
            e.show();
        }
    },
    hideTitle: function() {
        var e = this.getTitle();
        if (e) {
            e.hide();
        }
    }
}, function() {
    Ext.deprecateProperty(this, "titleCls", null, "Ext.Toolbar.titleCls has been removed. Use #cls config of title instead.");
});

Ext.define("Twitter.view.SearchListItem", {
    extend: "Ext.dataview.component.DataItem",
    xtype: "searchlistitem",
    config: {
        deleteButton: {
            text: "Delete",
            ui: "decline-small",
            hidden: true
        },
        items: [ {
            cls: "search",
            tpl: "{query}",
            flex: 1
        } ],
        layout: {
            type: "hbox",
            align: "middle"
        }
    },
    applyDeleteButton: function(e) {
        return Ext.factory(e, Ext.Button, this.getDeleteButton());
    },
    updateDeleteButton: function(e) {
        if (e) {
            this.add(e);
        }
    }
});

Ext.define("Twitter.view.TweetListItem", {
    extend: "Ext.dataview.component.ListItem",
    xtype: "tweetlistitem",
    requires: [ "Twitter.view.TweetListItemText", "Ext.Img" ],
    config: {
        ui: "tweet",
        dataMap: {
            getText: {
                setHtml: "text"
            },
            getUserName: {
                setHtml: "from_user"
            },
            getAvatar: {
                setSrc: "profile_image_url"
            }
        },
        userName: {
            cls: "username"
        },
        text: {
            cls: "text"
        },
        retweets: {
            cls: "retweets",
            hidden: true
        },
        avatar: {
            docked: "left",
            xtype: "image",
            cls: "avatar",
            width: "48px",
            height: "48px"
        },
        layout: {
            type: "vbox"
        }
    },
    applyUserName: function(e) {
        return Ext.factory(e, Ext.Component, this.getUserName());
    },
    updateUserName: function(e) {
        if (e) {
            this.insert(0, e);
        }
    },
    applyText: function(e) {
        return Ext.factory(e, Twitter.view.TweetListItemText, this.getText());
    },
    updateText: function(e) {
        if (e) {
            this.add(e);
        }
    },
    applyAvatar: function(e) {
        return Ext.factory(e, Ext.Img, this.getAvatar());
    },
    updateAvatar: function(e) {
        if (e) {
            this.add(e);
        }
    },
    applyRetweets: function(e) {
        return Ext.factory(e, Ext.Component, this.getRetweets());
    },
    updateRetweets: function(e) {
        if (e) {
            this.add(e);
        }
    },
    updateTpl: Ext.emptyFn,
    updateRecord: function(e) {
        this.callParent(arguments);
        if (!e) {
            return;
        }
        var t = e.get("metadata"), i = this.getRetweets();
        if (t && t.result_type && t.result_type == "popular") {
            this.element.addCls("popular");
            if (t.recent_retweets) {
                i.show();
                i.setHtml(t.recent_retweets + "+ recent retweets");
            }
        } else {
            this.element.removeCls("popular");
            i.hide();
        }
    }
});

Ext.define("Ext.field.Field", {
    extend: "Ext.Decorator",
    alternateClassName: "Ext.form.Field",
    xtype: "field",
    requires: [ "Ext.field.Input" ],
    isField: true,
    isFormField: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "field",
        label: null,
        labelAlign: "left",
        labelWidth: "30%",
        labelWrap: false,
        clearIcon: null,
        required: false,
        inputType: null,
        name: null,
        value: null,
        tabIndex: null
    },
    cachedConfig: {
        labelCls: null,
        requiredCls: Ext.baseCSSPrefix + "field-required",
        inputCls: null
    },
    getElementConfig: function() {
        var e = Ext.baseCSSPrefix;
        return {
            reference: "element",
            className: "x-container",
            children: [ {
                reference: "label",
                cls: e + "form-label",
                children: [ {
                    reference: "labelspan",
                    tag: "span"
                } ]
            }, {
                reference: "innerElement",
                cls: e + "component-outer"
            } ]
        };
    },
    updateLabel: function(e, t) {
        var i = this.renderElement, n = Ext.baseCSSPrefix;
        if (e) {
            this.labelspan.setHtml(e);
            i.addCls(n + "field-labeled");
        } else {
            i.removeCls(n + "field-labeled");
        }
    },
    updateLabelAlign: function(e, t) {
        var i = this.renderElement, n = Ext.baseCSSPrefix;
        if (e) {
            i.addCls(n + "label-align-" + e);
            if (e == "top" || e == "bottom") {
                this.label.setWidth("100%");
            } else {
                this.updateLabelWidth(this.getLabelWidth());
            }
        }
        if (t) {
            i.removeCls(n + "label-align-" + t);
        }
    },
    updateLabelCls: function(e, t) {
        if (e) {
            this.label.addCls(e);
        }
        if (t) {
            this.label.removeCls(t);
        }
    },
    updateLabelWidth: function(e) {
        var t = this.getLabelAlign();
        if (e) {
            if (t == "top" || t == "bottom") {
                this.label.setWidth("100%");
            } else {
                this.label.setWidth(e);
            }
        }
    },
    updateLabelWrap: function(e, t) {
        var i = Ext.baseCSSPrefix + "form-label-nowrap";
        if (!e) {
            this.addCls(i);
        } else {
            this.removeCls(i);
        }
    },
    updateRequired: function(e) {
        this.renderElement[e ? "addCls" : "removeCls"](this.getRequiredCls());
    },
    updateRequiredCls: function(e, t) {
        if (this.getRequired()) {
            this.renderElement.replaceCls(t, e);
        }
    },
    initialize: function() {
        var e = this;
        e.callParent();
        e.doInitValue();
    },
    doInitValue: function() {
        this.originalValue = this.getInitialConfig().value;
    },
    reset: function() {
        this.setValue(this.originalValue);
        return this;
    },
    isDirty: function() {
        return false;
    }
}, function() {
    var e = this.prototype;
    this.override({
        constructor: function(e) {
            e = e || {};
            var t = function(t, i, n) {
                if (e.hasOwnProperty(t)) {
                    if (i) {
                        e[i] = e[i] || {};
                        e[i][n ? n : t] = e[i][n ? n : t] || e[t];
                    } else {
                        e[n] = e[t];
                    }
                    delete e[t];
                    Ext.Logger.deprecate("'" + t + "' config is deprecated, use the '" + (i ? i + "." : "") + (n ? n : t) + "' config instead", 2);
                }
            };
            t("fieldCls", null, "inputCls");
            t("fieldLabel", null, "label");
            t("useClearIcon", null, "clearIcon");
            if (e.hasOwnProperty("autoCreateField")) {
                Ext.Logger.deprecate("'autoCreateField' config is deprecated. If you are subclassing Ext.field.Field and you do not want a Ext.field.Input, set the 'input' config to false.", this);
            }
            this.callOverridden(arguments);
        }
    });
    Ext.Object.defineProperty(e, "fieldEl", {
        get: function() {
            Ext.Logger.deprecate("'fieldEl' is deprecated, please use getInput() to get an instance of Ext.field.Field instead", this);
            return this.getInput().input;
        }
    });
    Ext.Object.defineProperty(e, "labelEl", {
        get: function() {
            Ext.Logger.deprecate("'labelEl' is deprecated", this);
            return this.getLabel().element;
        }
    });
});

Ext.define("Ext.field.Text", {
    extend: "Ext.field.Field",
    xtype: "textfield",
    alternateClassName: "Ext.form.Text",
    config: {
        ui: "text",
        clearIcon: true,
        placeHolder: null,
        maxLength: null,
        autoComplete: null,
        autoCapitalize: null,
        autoCorrect: null,
        readOnly: null,
        component: {
            xtype: "input",
            type: "text"
        },
        bubbleEvents: [ "action" ]
    },
    initialize: function() {
        var e = this;
        e.callParent();
        e.getComponent().on({
            scope: this,
            keyup: "onKeyUp",
            change: "onChange",
            focus: "onFocus",
            blur: "onBlur",
            paste: "onPaste",
            mousedown: "onMouseDown",
            clearicontap: "onClearIconTap"
        });
        e.originalValue = e.originalValue || "";
        e.getComponent().originalValue = e.originalValue;
        e.syncEmptyCls();
    },
    syncEmptyCls: function() {
        var e = this._value ? this._value.length : false, t = Ext.baseCSSPrefix + "empty";
        if (e) {
            this.removeCls(t);
        } else {
            this.addCls(t);
        }
    },
    updateValue: function(e) {
        var t = this.getComponent(), i = e !== undefined && e !== null && e !== "";
        if (t) {
            t.setValue(e);
        }
        this[i ? "showClearIcon" : "hideClearIcon"]();
        this.syncEmptyCls();
    },
    getValue: function() {
        var e = this;
        e._value = e.getComponent().getValue();
        e.syncEmptyCls();
        return e._value;
    },
    updatePlaceHolder: function(e) {
        this.getComponent().setPlaceHolder(e);
    },
    updateMaxLength: function(e) {
        this.getComponent().setMaxLength(e);
    },
    updateAutoComplete: function(e) {
        this.getComponent().setAutoComplete(e);
    },
    updateAutoCapitalize: function(e) {
        this.getComponent().setAutoCapitalize(e);
    },
    updateAutoCorrect: function(e) {
        this.getComponent().setAutoCorrect(e);
    },
    updateReadOnly: function(e) {
        if (e) {
            this.hideClearIcon();
        } else {
            this.showClearIcon();
        }
        this.getComponent().setReadOnly(e);
    },
    updateInputType: function(e) {
        var t = this.getComponent();
        if (t) {
            t.setType(e);
        }
    },
    updateName: function(e) {
        var t = this.getComponent();
        if (t) {
            t.setName(e);
        }
    },
    updateTabIndex: function(e) {
        var t = this.getComponent();
        if (t) {
            t.setTabIndex(e);
        }
    },
    updateInputCls: function(e, t) {
        var i = this.getComponent();
        if (i) {
            i.replaceCls(t, e);
        }
    },
    doSetDisabled: function(e) {
        var t = this;
        t.callParent(arguments);
        var i = t.getComponent();
        if (i) {
            i.setDisabled(e);
        }
        if (e) {
            t.hideClearIcon();
        } else {
            t.showClearIcon();
        }
    },
    showClearIcon: function() {
        var e = this, t = e.getValue(), i = t !== undefined && t !== null && t !== "";
        if (e.getClearIcon() && !e.getDisabled() && !e.getReadOnly() && i) {
            e.element.addCls(Ext.baseCSSPrefix + "field-clearable");
        }
        return e;
    },
    hideClearIcon: function() {
        if (this.getClearIcon()) {
            this.element.removeCls(Ext.baseCSSPrefix + "field-clearable");
        }
    },
    onKeyUp: function(e) {
        this.fireAction("keyup", [ this, e ], "doKeyUp");
    },
    doKeyUp: function(e, t) {
        var i = e.getValue(), n = i !== undefined && i !== null && i !== "";
        this[n ? "showClearIcon" : "hideClearIcon"]();
        if (t.browserEvent.keyCode === 13) {
            e.fireAction("action", [ e, t ], "doAction");
        }
    },
    doAction: function() {
        this.blur();
    },
    onClearIconTap: function(e) {
        this.fireAction("clearicontap", [ this, e ], "doClearIconTap");
    },
    doClearIconTap: function(e, t) {
        e.setValue("");
        e.getValue();
    },
    onChange: function(e, t, i) {
        e.fireEvent("change", this, t, i);
    },
    onFocus: function(e) {
        this.isFocused = true;
        this.fireEvent("focus", this, e);
    },
    onBlur: function(e) {
        var t = this;
        this.isFocused = false;
        t.fireEvent("blur", t, e);
        setTimeout(function() {
            t.isFocused = false;
        }, 50);
    },
    onPaste: function(e) {
        this.fireEvent("paste", this, e);
    },
    onMouseDown: function(e) {
        this.fireEvent("mousedown", this, e);
    },
    focus: function() {
        this.getComponent().focus();
        return this;
    },
    blur: function() {
        this.getComponent().blur();
        return this;
    },
    select: function() {
        this.getComponent().select();
        return this;
    },
    reset: function() {
        this.getComponent().reset();
        this.getValue();
        this[this._value ? "showClearIcon" : "hideClearIcon"]();
    },
    isDirty: function() {
        var e = this.getComponent();
        if (e) {
            return e.isDirty();
        }
        return false;
    }
});

Ext.define("Ext.field.Search", {
    extend: "Ext.field.Text",
    xtype: "searchfield",
    alternateClassName: "Ext.form.Search",
    config: {
        component: {
            type: "search"
        },
        ui: "search"
    }
});

Ext.define("Twitter.view.SearchBar", {
    extend: "Ext.Toolbar",
    xtype: "searchbar",
    requires: [ "Ext.field.Text", "Ext.field.Search" ],
    config: {
        ui: "searchbar",
        layout: "vbox",
        height: "79px",
        cls: "big",
        height: "4.7em",
        items: [ {
            xtype: "title",
            title: "Twitter Search"
        }, {
            xtype: "searchfield",
            placeHolder: "Search..."
        } ]
    }
});

Ext.define("Ext.dataview.component.Container", {
    extend: "Ext.Container",
    requires: [ "Ext.dataview.component.DataItem" ],
    constructor: function() {
        this.itemCache = [];
        this.callParent(arguments);
    },
    doInitialize: function() {
        this.innerElement.on({
            touchstart: "onItemTouchStart",
            touchend: "onItemTouchEnd",
            tap: "onItemTap",
            taphold: "onItemTapHold",
            touchmove: "onItemTouchMove",
            singletap: "onItemSingleTap",
            doubletap: "onItemDoubleTap",
            swipe: "onItemSwipe",
            delegate: "> ." + Ext.baseCSSPrefix + "data-item",
            scope: this
        });
    },
    initialize: function() {
        this.callParent();
        this.doInitialize();
    },
    onItemTouchStart: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        n.on({
            touchmove: "onItemTouchMove",
            scope: t,
            single: true
        });
        t.fireEvent("itemtouchstart", t, n, t.indexOf(n), e);
    },
    onItemTouchMove: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemtouchmove", t, n, t.indexOf(n), e);
    },
    onItemTouchEnd: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        n.un({
            touchmove: "onItemTouchMove",
            scope: t
        });
        t.fireEvent("itemtouchend", t, n, t.indexOf(n), e);
    },
    onItemTap: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemtap", t, n, t.indexOf(n), e);
    },
    onItemTapHold: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemtaphold", t, n, t.indexOf(n), e);
    },
    onItemSingleTap: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemsingletap", t, n, t.indexOf(n), e);
    },
    onItemDoubleTap: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemdoubletap", t, n, t.indexOf(n), e);
    },
    onItemSwipe: function(e) {
        var t = this, i = e.getTarget(), n = Ext.getCmp(i.id);
        t.fireEvent("itemswipe", t, n, t.indexOf(n), e);
    },
    moveItemsToCache: function(e, t) {
        var i = this, n = i.dataview, r = n.getMaxItemCache(), s = i.getViewItems(), a = i.itemCache, o = a.length, l = n.getPressedCls(), u = n.getSelectedCls(), c = t - e, f;
        for (;c >= 0; c--) {
            f = s[e + c];
            if (o !== r) {
                i.remove(f, false);
                f.removeCls([ l, u ]);
                a.push(f);
                o++;
            } else {
                f.destroy();
            }
        }
        if (i.getViewItems().length == 0) {
            this.dataview.showEmptyText();
        }
    },
    moveItemsFromCache: function(e) {
        var t = this, i = t.dataview, n = i.getStore(), r = e.length, s = i.getDefaultType(), a = i.getItemConfig(), o = t.itemCache, l = o.length, u = [], c, f, d;
        if (r) {
            i.hideEmptyText();
        }
        for (c = 0; c < r; c++) {
            e[c]._tmpIndex = n.indexOf(e[c]);
        }
        Ext.Array.sort(e, function(e, t) {
            return e._tmpIndex > t._tmpIndex ? 1 : -1;
        });
        for (c = 0; c < r; c++) {
            d = e[c];
            if (l) {
                l--;
                f = o.pop();
                this.updateListItem(d, f);
            } else {
                f = t.getDataItemConfig(s, d, a);
            }
            f = this.insert(d._tmpIndex, f);
            delete d._tmpIndex;
        }
        return u;
    },
    getViewItems: function() {
        return this.getInnerItems();
    },
    updateListItem: function(e, t) {
        if (t.updateRecord) {
            if (t.getRecord() === e) {
                t.updateRecord(e);
            } else {
                t.setRecord(e);
            }
        }
    },
    getDataItemConfig: function(e, t, i) {
        var n = this.dataview, r = {
            xtype: e,
            record: t,
            itemCls: n.getItemCls(),
            defaults: i,
            dataview: n
        };
        return Ext.merge(r, i);
    },
    doRemoveItemCls: function(e) {
        var t = this.getViewItems(), i = t.length, n = 0;
        for (;n < i; n++) {
            t[n].removeCls(e);
        }
    },
    doAddItemCls: function(e) {
        var t = this.getViewItems(), i = t.length, n = 0;
        for (;n < i; n++) {
            t[n].addCls(e);
        }
    },
    updateAtNewIndex: function(e, t, i) {
        this.moveItemsToCache(e, e);
        this.moveItemsFromCache([ i ]);
    },
    destroy: function() {
        var e = this, t = e.itemCache, i = t.length, n = 0;
        for (;n < i; n++) {
            t[n].destroy();
        }
        this.callParent();
    }
});

Ext.define("Ext.dataview.DataView", {
    extend: "Ext.Container",
    alternateClassName: "Ext.DataView",
    mixins: [ "Ext.mixin.Selectable" ],
    xtype: "dataview",
    requires: [ "Ext.LoadMask", "Ext.data.StoreManager", "Ext.dataview.component.Container", "Ext.dataview.element.Container" ],
    config: {
        store: null,
        data: null,
        baseCls: Ext.baseCSSPrefix + "dataview",
        emptyText: null,
        deferEmptyText: true,
        itemTpl: "<div>{text}</div>",
        pressedCls: "x-item-pressed",
        itemCls: null,
        selectedCls: "x-item-selected",
        triggerEvent: "itemtap",
        triggerCtEvent: "tap",
        deselectOnContainerClick: true,
        scrollable: true,
        inline: null,
        pressedDelay: 100,
        loadingText: "Loading...",
        useComponents: null,
        itemConfig: {},
        maxItemCache: 20,
        defaultType: "dataitem",
        scrollToTopOnRefresh: true
    },
    constructor: function(e) {
        var t = this, i;
        t.hasLoadedStore = false;
        t.mixins.selectable.constructor.apply(t, arguments);
        t.indexOffset = 0;
        t.callParent(arguments);
        i = this.getLayout();
        if (i && !i.isAuto) {
            Ext.Logger.error("The base layout for a DataView must always be an Auto Layout");
        }
    },
    updateItemCls: function(e, t) {
        var i = this.container;
        if (i) {
            if (t) {
                i.doRemoveItemCls(t);
            }
            if (e) {
                i.doAddItemCls(e);
            }
        }
    },
    storeEventHooks: {
        beforeload: "onBeforeLoad",
        load: "onLoad",
        refresh: "refresh",
        addrecords: "onStoreAdd",
        removerecords: "onStoreRemove",
        updaterecord: "onStoreUpdate"
    },
    initialize: function() {
        this.callParent();
        var e = this, t;
        e.on(e.getTriggerCtEvent(), e.onContainerTrigger, e);
        t = e.container = this.add(new (Ext.dataview[e.getUseComponents() ? "component" : "element"].Container)({
            baseCls: this.getBaseCls()
        }));
        t.dataview = e;
        e.on(e.getTriggerEvent(), e.onItemTrigger, e);
        t.on({
            itemtouchstart: "onItemTouchStart",
            itemtouchend: "onItemTouchEnd",
            itemtap: "onItemTap",
            itemtaphold: "onItemTapHold",
            itemtouchmove: "onItemTouchMove",
            itemsingletap: "onItemSingleTap",
            itemdoubletap: "onItemDoubleTap",
            itemswipe: "onItemSwipe",
            scope: e
        });
        if (e.getStore()) {
            if (e.isPainted()) {
                e.refresh();
            } else {
                e.on({
                    painted: "refresh",
                    single: true
                });
            }
        }
    },
    applyInline: function(e) {
        if (Ext.isObject(e)) {
            e = Ext.apply({}, e);
        }
        return e;
    },
    updateInline: function(e, t) {
        var i = this.getBaseCls();
        if (t) {
            this.removeCls([ i + "-inlineblock", i + "-nowrap" ]);
        }
        if (e) {
            this.addCls(i + "-inlineblock");
            if (Ext.isObject(e) && e.wrap === false) {
                this.addCls(i + "-nowrap");
            } else {
                this.removeCls(i + "-nowrap");
            }
        }
    },
    prepareData: function(e, t, i) {
        return e;
    },
    onContainerTrigger: function(e) {
        var t = this;
        if (e.target != t.element.dom) {
            return;
        }
        if (t.getDeselectOnContainerClick() && t.getStore()) {
            t.deselectAll();
        }
    },
    onItemTrigger: function(e, t) {
        this.selectWithEvent(this.getStore().getAt(t));
    },
    doAddPressedCls: function(e) {
        var t = this, i = t.getItemAt(t.getStore().indexOf(e));
        if (Ext.isElement(i)) {
            i = Ext.get(i);
        }
        if (i) {
            i.addCls(t.getPressedCls());
        }
    },
    onItemTouchStart: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireAction("itemtouchstart", [ r, i, t, a, n ], "doItemTouchStart");
    },
    doItemTouchStart: function(e, t, i, n) {
        var r = e.getPressedDelay();
        if (n) {
            if (r > 0) {
                e.pressedTimeout = Ext.defer(e.doAddPressedCls, r, e, [ n ]);
            } else {
                e.doAddPressedCls(n);
            }
        }
    },
    onItemTouchEnd: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        if (this.hasOwnProperty("pressedTimeout")) {
            clearTimeout(this.pressedTimeout);
            delete this.pressedTimeout;
        }
        if (a && t) {
            t.removeCls(r.getPressedCls());
        }
        r.fireEvent("itemtouchend", r, i, t, a, n);
    },
    onItemTouchMove: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        if (r.hasOwnProperty("pressedTimeout")) {
            clearTimeout(r.pressedTimeout);
            delete r.pressedTimeout;
        }
        if (a && t) {
            t.removeCls(r.getPressedCls());
        }
        r.fireEvent("itemtouchmove", r, i, t, a, n);
    },
    onItemTap: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireEvent("itemtap", r, i, t, a, n);
    },
    onItemTapHold: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireEvent("itemtaphold", r, i, t, a, n);
    },
    onItemSingleTap: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireEvent("itemsingletap", r, i, t, a, n);
    },
    onItemDoubleTap: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireEvent("itemdoubletap", r, i, t, a, n);
    },
    onItemSwipe: function(e, t, i, n) {
        var r = this, s = r.getStore(), a = s && s.getAt(i);
        r.fireEvent("itemswipe", r, i, t, a, n);
    },
    onItemSelect: function(e, t) {
        var i = this;
        if (t) {
            i.doItemSelect(i, e);
        } else {
            i.fireAction("select", [ i, e ], "doItemSelect");
        }
    },
    doItemSelect: function(e, t) {
        if (e.container && !e.isDestroyed) {
            var i = e.getItemAt(e.getStore().indexOf(t));
            if (Ext.isElement(i)) {
                i = Ext.get(i);
            }
            if (i) {
                i.removeCls(e.getPressedCls());
                i.addCls(e.getSelectedCls());
            }
        }
    },
    onItemDeselect: function(e, t) {
        var i = this;
        if (i.container && !i.isDestroyed) {
            if (t) {
                i.doItemDeselect(i, e);
            } else {
                i.fireAction("deselect", [ i, e, t ], "doItemDeselect");
            }
        }
    },
    doItemDeselect: function(e, t) {
        var i = e.getItemAt(e.getStore().indexOf(t));
        if (Ext.isElement(i)) {
            i = Ext.get(i);
        }
        if (i) {
            i.removeCls([ e.getPressedCls(), e.getSelectedCls() ]);
        }
    },
    updateData: function(e) {
        var t = this.getStore();
        if (!t) {
            this.setStore(Ext.create("Ext.data.Store", {
                data: e,
                autoDestroy: true
            }));
        } else {
            t.add(e);
        }
    },
    applyStore: function(e) {
        var t = this, i = Ext.apply({}, t.storeEventHooks, {
            scope: t
        }), n, r;
        if (e) {
            e = Ext.data.StoreManager.lookup(e);
            if (e && Ext.isObject(e) && e.isStore) {
                e.on(i);
                n = e.getProxy();
                if (n) {
                    r = n.getReader();
                    if (r) {
                        r.on("exception", "handleException", this);
                    }
                }
            } else {
                Ext.Logger.warn("The specified Store cannot be found", this);
            }
        }
        return e;
    },
    handleException: function() {
        this.setMasked(false);
    },
    updateStore: function(e, t) {
        var i = this, n = Ext.apply({}, i.storeEventHooks, {
            scope: i
        }), r, s;
        if (t && Ext.isObject(t) && t.isStore) {
            i.onStoreClear();
            if (t.getAutoDestroy()) {
                t.destroy();
            } else {
                t.un(n);
                r = t.getProxy();
                if (r) {
                    s = r.getReader();
                    if (s) {
                        s.un("exception", "handleException", this);
                    }
                }
            }
        }
        if (e) {
            if (e.isLoaded()) {
                this.hasLoadedStore = true;
            }
            if (e.isLoading()) {
                i.onBeforeLoad();
            }
            if (i.container) {
                i.refresh();
            }
        }
    },
    onBeforeLoad: function() {
        var e = this.getLoadingText();
        if (e && this.isPainted()) {
            this.setMasked({
                xtype: "loadmask",
                message: e
            });
        }
        this.hideEmptyText();
    },
    updateEmptyText: function(e, t) {
        var i = this, n;
        if (t && i.emptyTextCmp) {
            i.remove(i.emptyTextCmp, true);
            delete i.emptyTextCmp;
        }
        if (e) {
            i.emptyTextCmp = i.add({
                xtype: "component",
                cls: i.getBaseCls() + "-emptytext",
                html: e,
                hidden: true
            });
            n = i.getStore();
            if (n && i.hasLoadedStore && !n.getCount()) {
                this.showEmptyText();
            }
        }
    },
    onLoad: function(e) {
        this.hasLoadedStore = true;
        this.setMasked(false);
        if (!e.getCount()) {
            this.showEmptyText();
        }
    },
    refresh: function() {
        var e = this, t = e.container;
        if (!e.getStore()) {
            if (!e.hasLoadedStore && !e.getDeferEmptyText()) {
                e.showEmptyText();
            }
            return;
        }
        if (t) {
            e.fireAction("refresh", [ e ], "doRefresh");
        }
    },
    applyItemTpl: function(e) {
        return Ext.isObject(e) && e.isTemplate ? e : new Ext.XTemplate(e);
    },
    onAfterRender: function() {
        var e = this;
        e.callParent(arguments);
        e.updateStore(e.getStore());
    },
    getItemAt: function(e) {
        return this.getViewItems()[e - this.indexOffset];
    },
    getItemIndex: function(e) {
        var t = this.getViewItems().indexOf(e);
        return t === -1 ? t : this.indexOffset + t;
    },
    getViewItems: function() {
        return this.container.getViewItems();
    },
    doRefresh: function(e) {
        var t = e.container, i = e.getStore(), n = i.getRange(), r = e.getViewItems(), s = n.length, a = r.length, o = s - a, l = e.getScrollable(), u, c;
        if (this.getScrollToTopOnRefresh() && l) {
            l.getScroller().scrollToTop();
        }
        if (s < 1) {
            e.onStoreClear();
            return;
        } else {
            e.hideEmptyText();
        }
        if (o < 0) {
            t.moveItemsToCache(a + o, a - 1);
            r = e.getViewItems();
            a = r.length;
        } else if (o > 0) {
            t.moveItemsFromCache(i.getRange(a));
        }
        for (u = 0; u < a; u++) {
            c = r[u];
            t.updateListItem(n[u], c);
        }
        if (this.hasSelection()) {
            var f = this.getSelection(), d = this.getSelectionCount(), h;
            for (u = 0; u < d; u++) {
                h = f[u];
                this.doItemSelect(this, h);
            }
        }
    },
    showEmptyText: function() {
        if (this.getEmptyText() && (this.hasLoadedStore || !this.getDeferEmptyText())) {
            this.emptyTextCmp.show();
        }
    },
    hideEmptyText: function() {
        if (this.getEmptyText()) {
            this.emptyTextCmp.hide();
        }
    },
    destroy: function() {
        var e = this.getStore();
        if (e && e.getAutoDestroy()) {
            e.destroy();
        }
        this.callParent(arguments);
    },
    onStoreClear: function() {
        var e = this, t = e.container, i = e.getViewItems();
        t.moveItemsToCache(0, i.length - 1);
        this.showEmptyText();
    },
    onStoreAdd: function(e, t) {
        if (t) {
            this.hideEmptyText();
            this.container.moveItemsFromCache(t);
        }
    },
    onStoreRemove: function(e, t, i) {
        var n = this.container, r = t.length, s;
        for (s = 0; s < r; s++) {
            n.moveItemsToCache(i[s], i[s]);
        }
    },
    onStoreUpdate: function(e, t, i, n) {
        var r = this, s = r.container;
        n = typeof n === "undefined" ? i : n;
        if (n !== i) {
            s.updateAtNewIndex(n, i, t);
            if (r.isSelected(t)) {
                r.doItemSelect(r, t);
            }
        } else {
            s.updateListItem(t, r.getViewItems()[i]);
        }
    }
}, function() {
    Ext.deprecateMethod(this, "collectData", null, "Ext.dataview.DataView.collectData() has been removed");
    Ext.deprecateMethod(this, "findItemByChild", null, "Ext.dataview.DataView.findItemByChild() has been removed");
    Ext.deprecateMethod(this, "findTargetByEvent", null, "Ext.dataview.DataView.findTargetByEvent() has been removed");
    Ext.deprecateMethod(this, "getNode", null, "Ext.dataview.DataView.getNode() has been removed");
    Ext.deprecateMethod(this, "getNodes", null, "Ext.dataview.DataView.getNodes() has been removed");
    Ext.deprecateMethod(this, "getRecords", null, "Ext.dataview.DataView.getRecords() has been removed");
    Ext.deprecateMethod(this, "getSelectedNodes", null, "Ext.dataview.DataView.getSelectedNodes() has been removed");
    Ext.deprecateMethod(this, "getSelectedRecords", null, "Ext.dataview.DataView.getSelectedRecords() has been removed");
    Ext.deprecateMethod(this, "indexOf", null, "Ext.dataview.DataView.indexOf() has been removed");
    Ext.deprecateMethod(this, "refreshNode", null, "Ext.dataview.DataView.refreshNode() has been removed");
    Ext.deprecateClassMethod(this, "bindStore", "setStore");
    Ext.deprecateProperty(this, "blockRefresh", null, "Ext.dataview.DataView.blockRefresh has been removed");
    Ext.deprecateProperty(this, "itemSelector", null, "Ext.dataview.DataView.itemSelector has been removed");
    Ext.deprecateProperty(this, "multiSelect", null, "Ext.dataview.DataView.multiSelect has been removed");
    Ext.deprecateProperty(this, "overItemCls", null, "Ext.dataview.DataView.overItemCls has been removed");
    Ext.deprecateProperty(this, "selectedItemCls", null, "Ext.dataview.DataView.selectedItemCls has been removed");
    Ext.deprecateProperty(this, "simpleSelect", null, "Ext.dataview.DataView.simpleSelect has been removed");
    Ext.deprecateProperty(this, "singleSelect", null, "Ext.dataview.DataView.singleSelect has been removed");
    Ext.deprecateProperty(this, "trackOver", null, "Ext.dataview.DataView.trackOver has been removed");
});

Ext.define("Twitter.view.SearchList", {
    extend: "Ext.DataView",
    xtype: "searchlist",
    requires: [ "Twitter.view.SearchListItem" ],
    config: {
        ui: "searchlist",
        baseCls: "x-list",
        store: "Searches",
        defaultType: "searchlistitem",
        scrollable: "vertical",
        allowDeselect: false,
        useComponents: true,
        deselectOnContainerClick: false
    }
});

Ext.define("Ext.dataview.List", {
    alternateClassName: "Ext.List",
    extend: "Ext.dataview.DataView",
    xtype: "list",
    mixins: [ "Ext.mixin.Bindable" ],
    requires: [ "Ext.dataview.IndexBar", "Ext.dataview.ListItemHeader", "Ext.dataview.component.ListItem", "Ext.util.TranslatableList", "Ext.util.PositionMap" ],
    config: {
        layout: "fit",
        indexBar: false,
        icon: null,
        preventSelectionOnDisclose: true,
        baseCls: Ext.baseCSSPrefix + "list",
        pinHeaders: true,
        grouped: false,
        onItemDisclosure: null,
        disclosureProperty: "disclosure",
        ui: "normal",
        defaultType: "listitem",
        itemMap: {
            minimumHeight: 47
        },
        variableHeights: true,
        itemHeight: 47,
        refreshHeightOnUpdate: true
    },
    constructor: function(e) {
        var t = this, i;
        t.callParent(arguments);
        if (Ext.os.is.Android4 && !Ext.browser.is.ChromeMobile) {
            t.headerTranslateFn = Ext.Function.createThrottled(t.headerTranslateFn, 50, t);
        }
        i = this.getLayout();
        if (i && !i.isFit) {
            Ext.Logger.error("The base layout for a DataView must always be a Fit Layout");
        }
    },
    topItemIndex: 0,
    topItemPosition: 0,
    updateItemHeight: function(e) {
        this.getItemMap().setMinimumHeight(e);
    },
    applyItemMap: function(e) {
        return Ext.factory(e, Ext.util.PositionMap, this.getItemMap());
    },
    beforeInitialize: function() {
        var e = this, t;
        e.listItems = [];
        e.scrollDockItems = {
            top: [],
            bottom: []
        };
        t = e.container = e.add(new Ext.Container({
            scrollable: {
                scroller: {
                    autoRefresh: false,
                    direction: "vertical",
                    translatable: {
                        xclass: "Ext.util.TranslatableList"
                    }
                }
            }
        }));
        t.getScrollable().getScroller().getTranslatable().setItems(e.listItems);
        e.setScrollable(t.getScrollable());
        e.scrollableBehavior = t.getScrollableBehavior();
    },
    initialize: function() {
        var e = this, t = e.container, i, n;
        e.updatedItems = [];
        e.headerMap = [];
        e.on(e.getTriggerCtEvent(), e.onContainerTrigger, e);
        e.on(e.getTriggerEvent(), e.onItemTrigger, e);
        e.header = Ext.factory({
            xclass: "Ext.dataview.ListItemHeader",
            html: "&nbsp;",
            translatable: true,
            role: "globallistheader",
            cls: [ "x-list-header", "x-list-header-swap" ]
        });
        e.container.innerElement.insertFirst(e.header.element);
        e.headerTranslate = e.header.getTranslatable();
        e.headerTranslate.translate(0, -1e4);
        if (!e.getGrouped()) {
            e.updatePinHeaders(null);
        }
        t.element.on({
            delegate: "." + e.getBaseCls() + "-disclosure",
            tap: "handleItemDisclosure",
            scope: e
        });
        t.element.on({
            resize: "onResize",
            scope: e
        });
        t.innerElement.on({
            touchstart: "onItemTouchStart",
            touchend: "onItemTouchEnd",
            tap: "onItemTap",
            taphold: "onItemTapHold",
            singletap: "onItemSingleTap",
            doubletap: "onItemDoubleTap",
            swipe: "onItemSwipe",
            delegate: "." + Ext.baseCSSPrefix + "list-item-body",
            scope: e
        });
        for (i = 0, n = e.scrollDockItems.top.length; i < n; i++) {
            t.add(e.scrollDockItems.top[i]);
        }
        for (i = 0, n = e.scrollDockItems.bottom.length; i < n; i++) {
            t.add(e.scrollDockItems.bottom[i]);
        }
        if (e.getStore()) {
            e.refresh();
        }
    },
    updateInline: function(e) {
        var t = this;
        t.callParent(arguments);
        if (e) {
            t.setOnItemDisclosure(false);
            t.setIndexBar(false);
            t.setGrouped(false);
        }
    },
    applyIndexBar: function(e) {
        return Ext.factory(e, Ext.dataview.IndexBar, this.getIndexBar());
    },
    updateIndexBar: function(e) {
        var t = this;
        if (e && t.getScrollable()) {
            t.indexBarElement = t.getScrollableBehavior().getScrollView().getElement().appendChild(e.renderElement);
            e.on({
                index: "onIndex",
                scope: t
            });
            t.element.addCls(t.getBaseCls() + "-indexed");
        }
    },
    updateGrouped: function(e) {
        var t = this, i = this.getBaseCls(), n = i + "-grouped", r = i + "-ungrouped";
        if (e) {
            t.addCls(n);
            t.removeCls(r);
            t.updatePinHeaders(t.getPinHeaders());
        } else {
            t.addCls(r);
            t.removeCls(n);
            t.updatePinHeaders(null);
        }
        if (t.isPainted() && t.listItems.length) {
            t.setItemsCount(t.listItems.length);
        }
    },
    updatePinHeaders: function(e) {
        if (this.headerTranslate) {
            this.headerTranslate.translate(0, -1e4);
        }
    },
    updateItemTpl: function(e, t) {
        var i = this.listItems, n = i.length || 0, r = this.getStore(), s, a;
        for (s = 0; s < n; s++) {
            a = i[s];
            a.setTpl(e);
        }
        if (r && r.getCount()) {
            this.doRefresh();
        }
    },
    updateScrollerSize: function() {
        var e = this, t = e.getItemMap().getTotalHeight(), i = e.container.getScrollable().getScroller();
        if (t > 0) {
            i.givenSize = t;
            i.refresh();
        }
    },
    onResize: function() {
        var e = this, t = e.container, i = t.element, n = e.getItemMap().getMinimumHeight(), r;
        if (!e.listItems.length) {
            e.bind(t.getScrollable().getScroller().getTranslatable(), "doTranslate", "onTranslate");
        }
        e.containerSize = r = i.getHeight();
        e.setItemsCount(Math.ceil(r / n) + 1);
    },
    scrollDockHeightRefresh: function() {
        var e = this.listItems, t = this.scrollDockItems, i = e.length, n, r;
        for (n = 0; n < i; n++) {
            r = e[n];
            if (r.isFirst && t.top.length || r.isLast && t.bottom.length) {
                this.updatedItems.push(r);
            }
        }
        this.refreshScroller();
    },
    headerTranslateFn: function(e, t, i) {
        var n = this.getStore().getGroupString(e);
        if (this.currentHeader !== n) {
            this.currentHeader = n;
            this.header.setHtml(n);
        }
        i.translate(0, t);
    },
    onTranslate: function(e, t, i) {
        var n = this, r = n.listItems, s = r.length, a = n.topItemIndex, o = n.getItemMap(), l = n.getStore(), u = l && l.getCount(), c = n.getListItemInfo(), f = n.getGrouped(), d = n.groups, h = n.headerMap, g = n.headerTranslate, p = n.getPinHeaders(), m = u - s + 1, x, E, y, v, b, S, C, w, T, I;
        if (n.updatedItems.length) {
            n.updateItemHeights();
        }
        n.topItemPosition = o.findIndex(-t) || 0;
        n.indexOffset = n.topItemIndex = x = Math.max(0, Math.min(n.topItemPosition, m));
        if (f && g && d.length && p) {
            S = o.binarySearch(h, -t);
            C = d[S].children[0];
            if (C) {
                w = t + h[S + 1] - n.headerHeight;
                if (t >= 0) {
                    T = -1e4;
                } else if (w < 0) {
                    T = w;
                } else {
                    T = Math.max(0, t);
                }
                this.headerTranslateFn(C, T, g);
            }
        }
        i[1] = (o.map[x] || 0) + t;
        if (a !== x && x <= m) {
            if (a > x) {
                E = Math.min(s, a - x);
                for (y = E - 1; y >= 0; y--) {
                    b = r.pop();
                    r.unshift(b);
                    n.updateListItem(b, y + x, c);
                }
            } else {
                E = Math.min(s, x - a);
                for (y = 0; y < E; y++) {
                    b = r.shift();
                    r.push(b);
                    v = y + x + s - E;
                    n.updateListItem(b, v, c);
                }
            }
        }
        if (r.length && f && p) {
            if (n.headerIndices[x]) {
                I = r[0].getHeader().element;
                if (t < o.map[x]) {
                    I.setVisibility(false);
                } else {
                    I.setVisibility(true);
                }
            }
            for (y = 1; y <= E; y++) {
                if (r[y]) {
                    r[y].getHeader().element.setVisibility(true);
                }
            }
        }
    },
    setItemsCount: function(e) {
        var t = this, i = t.listItems, n = t.getItemMap().getMinimumHeight(), r = {
            xtype: t.getDefaultType(),
            itemConfig: t.getItemConfig(),
            tpl: t.getItemTpl(),
            minHeight: n,
            cls: t.getItemCls()
        }, s = t.getListItemInfo(), a, o;
        for (a = 0; a < e; a++) {
            o = i[a];
            if (!o) {
                o = Ext.factory(r);
                o.dataview = t;
                o.$height = n;
                t.container.doAdd(o);
                i.push(o);
            }
            o.dataIndex = null;
            if (s.store) {
                t.updateListItem(o, a + t.topItemIndex, s);
            } else {
                o.setRecord(null);
                o.translate(0, -1e4);
                o._list_hidden = true;
            }
        }
        t.updateScrollerSize();
    },
    getListItemInfo: function() {
        var e = this, t = e.getBaseCls();
        return {
            store: e.getStore(),
            grouped: e.getGrouped(),
            baseCls: t,
            selectedCls: e.getSelectedCls(),
            headerCls: t + "-header-wrap",
            footerCls: t + "-footer-wrap",
            firstCls: t + "-item-first",
            lastCls: t + "-item-last",
            itemMap: e.getItemMap(),
            variableHeights: e.getVariableHeights(),
            defaultItemHeight: e.getItemHeight()
        };
    },
    updateListItem: function(e, t, i) {
        var n = i.store.getAt(t);
        if (this.isSelected(n)) {
            e.addCls(i.selectedCls);
        } else {
            e.removeCls(i.selectedCls);
        }
        e.removeCls([ i.headerCls, i.footerCls, i.firstCls, i.lastCls ]);
        this.replaceItemContent(e, t, i);
    },
    taskRunner: function() {
        delete this.intervalId;
        if (this.scheduledTasks && this.scheduledTasks.length > 0) {
            var e = this.scheduledTasks.shift();
            this.doUpdateListItem(e.item, e.index, e.info);
            if (this.scheduledTasks.length === 0 && this.getVariableHeights() && !this.container.getScrollable().getScroller().getTranslatable().isAnimating) {
                this.refreshScroller();
            } else if (this.scheduledTasks.length > 0) {
                this.intervalId = requestAnimationFrame(Ext.Function.bind(this.taskRunner, this));
            }
        }
    },
    scheduledTasks: null,
    replaceItemContent: function(e, t, i) {
        var n = this.container.getScrollable().getScroller().getTranslatable();
        if (Ext.os.is.Android4 && !Ext.browser.is.Chrome && !i.variableHeights && !i.grouped && n.isAnimating && n.activeEasingY && Math.abs(n.activeEasingY._startVelocity) > .75) {
            if (!this.scheduledTasks) {
                this.scheduledTasks = [];
            }
            for (var r = 0; r < this.scheduledTasks.length; r++) {
                if (this.scheduledTasks[r].item === e) {
                    Ext.Array.remove(this.scheduledTasks, this.scheduledTasks[r]);
                    break;
                }
            }
            this.scheduledTasks.push({
                item: e,
                index: t,
                info: i
            });
            if (!this.intervalId) {
                this.intervalId = requestAnimationFrame(Ext.Function.bind(this.taskRunner, this));
            }
        } else {
            this.doUpdateListItem(e, t, i);
        }
    },
    doUpdateListItem: function(e, t, i) {
        var n = i.store.getAt(t), r = this.headerIndices, s = this.footerIndices, a = e.getHeader(), o = this.scrollDockItems, l = this.updatedItems, u = i.itemMap.getItemHeight(t), c, f, d;
        if (!n) {
            e.setRecord(null);
            e.translate(0, -1e4);
            e._list_hidden = true;
            return;
        }
        e._list_hidden = false;
        if (e.isFirst && o.top.length) {
            for (f = 0, c = o.top.length; f < c; f++) {
                d = o.top[f];
                d.addCls(Ext.baseCSSPrefix + "list-scrolldock-hidden");
                e.remove(d, false);
            }
            e.isFirst = false;
        }
        if (e.isLast && o.bottom.length) {
            for (f = 0, c = o.bottom.length; f < c; f++) {
                d = o.bottom[f];
                d.addCls(Ext.baseCSSPrefix + "list-scrolldock-hidden");
                e.remove(d, false);
            }
            e.isLast = false;
        }
        if (e.getRecord) {
            if (e.dataIndex !== t) {
                e.dataIndex = t;
                this.fireEvent("itemindexchange", this, n, t, e);
            }
            if (e.getRecord() === n) {
                e.updateRecord(n);
            } else {
                e.setRecord(n);
            }
        }
        if (this.isSelected(n)) {
            e.addCls(i.selectedCls);
        } else {
            e.removeCls(i.selectedCls);
        }
        e.removeCls([ i.headerCls, i.footerCls, i.firstCls, i.lastCls ]);
        if (i.grouped) {
            if (r[t]) {
                e.addCls(i.headerCls);
                a.setHtml(i.store.getGroupString(n));
                a.show();
                a.element.setVisibility(true);
                if (!i.variableHeights && u === i.defaultItemHeight) {
                    Ext.Array.include(l, e);
                }
            } else {
                a.hide();
                if (!i.variableHeights && !s[t] && u !== i.defaultItemHeight) {
                    i.itemMap.setItemHeight(t, i.defaultItemHeight);
                    i.itemMap.update();
                }
            }
            if (s[t]) {
                e.addCls(i.footerCls);
                if (!i.variableHeights && u === i.defaultItemHeight) {
                    Ext.Array.include(l, e);
                }
            }
        } else if (!i.variableHeights && u !== i.defaultItemHeight) {
            i.itemMap.setItemHeight(t, i.defaultItemHeight);
            i.itemMap.update();
        }
        if (t === 0) {
            e.isFirst = true;
            e.addCls(i.firstCls);
            if (!i.grouped) {
                e.addCls(i.headerCls);
            }
            for (f = 0, c = o.top.length; f < c; f++) {
                d = o.top[f];
                e.insert(0, d);
                d.removeCls(Ext.baseCSSPrefix + "list-scrolldock-hidden");
            }
            if (c && !i.variableHeights) {
                Ext.Array.include(l, e);
            }
        }
        if (t === i.store.getCount() - 1) {
            e.isLast = true;
            e.addCls(i.lastCls);
            if (!i.grouped) {
                e.addCls(i.footerCls);
            }
            for (f = 0, c = o.bottom.length; f < c; f++) {
                d = o.bottom[f];
                e.insert(0, d);
                d.removeCls(Ext.baseCSSPrefix + "list-scrolldock-hidden");
            }
            if (c && !i.variableHeights) {
                Ext.Array.include(l, e);
            }
        }
        e.$height = i.itemMap.getItemHeight(t);
        if (i.variableHeights) {
            l.push(e);
        }
    },
    updateItemHeights: function() {
        if (!this.isPainted() && !this.pendingHeightUpdate) {
            this.pendingHeightUpdate = true;
            this.on("painted", this.updateItemHeights, this, {
                single: true
            });
            return;
        }
        var e = this.updatedItems, t = e.length, i = this.getItemMap(), n = this.container.getScrollable().getScroller(), r = i.getMinimumHeight(), s = this.headerIndices, a = this.headerMap, o = n.getTranslatable(), l, u, c, f;
        this.pendingHeightUpdate = false;
        for (u = 0; u < t; u++) {
            c = e[u];
            l = c.dataIndex;
            if (l !== null) {
                f = c.element.getFirstChild().getHeight();
                f = Math.max(f, r);
                if (s && !this.headerHeight && s[l]) {
                    this.headerHeight = parseInt(c.getHeader().element.getHeight(), 10);
                }
                i.setItemHeight(l, f);
            }
        }
        i.update();
        f = i.getTotalHeight();
        a.length = 0;
        for (u in s) {
            a.push(i.map[u]);
        }
        for (u = 0; u < t; u++) {
            c = e[u];
            l = c.dataIndex;
            c.$height = i.getItemHeight(l);
        }
        if (f != n.givenSize) {
            n.setSize(f);
            n.refreshMaxPosition();
            if (o.isAnimating) {
                o.activeEasingY.setMinMomentumValue(-n.getMaxPosition().y);
            }
        }
        this.updatedItems.length = 0;
    },
    getItemAt: function(e) {
        var t = this.listItems, i = t.length, n, r;
        for (n = 0; n < i; n++) {
            r = t[n];
            if (r.dataIndex === e) {
                return r;
            }
        }
    },
    getItemIndex: function(e) {
        return e.dataIndex;
    },
    getViewItems: function() {
        return this.listItems;
    },
    doRefresh: function(e) {
        if (this.intervalId) {
            cancelAnimationFrame(this.intervalId);
            delete this.intervalId;
        }
        if (this.scheduledTasks) {
            this.scheduledTasks.length = 0;
        }
        var t = this, i = t.getStore(), n = t.container.getScrollable(), r = n && n.getScroller(), s = t.isPainted(), a = i.getCount();
        t.getItemMap().populate(a, this.topItemPosition);
        if (t.getGrouped()) {
            t.findGroupHeaderIndices();
        }
        if (t.listItems.length) {
            if (t.getScrollToTopOnRefresh()) {
                t.topItemIndex = 0;
                t.topItemPosition = 0;
                r.position.y = 0;
            }
            t.setItemsCount(t.listItems.length);
            if (s) {
                t.refreshScroller(r);
            } else if (!t.pendingRefreshScroller) {
                t.pendingRefreshScroller = true;
                t.on("painted", function() {
                    t.pendingRefreshScroller = false;
                    t.refreshScroller(r);
                }, this, {
                    single: true
                });
            }
        }
        if (a < 1) {
            t.onStoreClear();
            return;
        } else {
            t.hideEmptyText();
        }
    },
    findGroupHeaderIndices: function() {
        var e = this, t = e.getStore(), i = t.getCount(), n = t.getGroups(), r = n.length, s = e.headerIndices = {}, a = e.footerIndices = {}, o, l, u, c;
        e.groups = n;
        for (o = 0; o < r; o++) {
            u = n[o].children[0];
            c = t.indexOf(u);
            s[c] = true;
            l = c - 1;
            if (l) {
                a[l] = true;
            }
        }
        a[i - 1] = true;
        return s;
    },
    onStoreAdd: function() {
        this.doRefresh();
    },
    onStoreRemove: function() {
        this.doRefresh();
    },
    onStoreUpdate: function(e, t, i, n) {
        var r = this, s = r.container.getScrollable().getScroller(), a;
        n = typeof n === "undefined" ? i : n;
        if (n !== i) {
            r.doRefresh();
        } else {
            if (i >= r.topItemIndex && i < r.topItemIndex + r.listItems.length) {
                a = r.getItemAt(i);
                if (a) {
                    r.doUpdateListItem(a, i, r.getListItemInfo());
                    if (r.getVariableHeights() && r.getRefreshHeightOnUpdate()) {
                        r.updatedItems.push(a);
                        r.updateItemHeights();
                        r.refreshScroller(s);
                    }
                }
            }
        }
    },
    refreshScroller: function(e) {
        if (!e) {
            e = this.container.getScrollable().getScroller();
        }
        e.scrollTo(0, e.position.y + 1);
        e.scrollTo(0, e.position.y - 1);
    },
    onStoreClear: function() {
        if (this.headerTranslate) {
            this.headerTranslate.translate(0, -1e4);
        }
        this.showEmptyText();
    },
    onIndex: function(e, t) {
        var i = this, n = t.toLowerCase(), r = i.getStore(), s = r.getGroups(), a = s.length, o = i.container.getScrollable(), l, u, c, f, d;
        if (o) {
            l = o.getScroller();
        } else {
            return;
        }
        for (c = 0; c < a; c++) {
            u = s[c];
            d = u.name.toLowerCase();
            if (d == n || d > n) {
                f = u;
                break;
            } else {
                f = u;
            }
        }
        if (o && f) {
            t = r.indexOf(f.children[0]);
            l.stopAnimation();
            var h = l.getContainerSize().y, g = l.getSize().y, p = g - h, m = i.getItemMap().map[t], x = m > p ? p : m;
            l.scrollTo(0, x);
            if (this.updatedItems.length > 0 && (!this.scheduledTasks || this.scheduledTasks.length === 0)) {
                this.refreshScroller();
            }
        }
    },
    applyOnItemDisclosure: function(e) {
        if (Ext.isFunction(e)) {
            return {
                scope: this,
                handler: e
            };
        }
        return e;
    },
    handleItemDisclosure: function(e) {
        var t = this, i = Ext.getCmp(Ext.get(e.getTarget()).up(".x-list-item").id), n = i.dataIndex, r = t.getStore().getAt(n);
        t.fireAction("disclose", [ t, r, i, n, e ], "doDisclose");
    },
    doDisclose: function(e, t, i, n, r) {
        var s = e.getOnItemDisclosure();
        if (s && s.handler) {
            s.handler.call(s.scope || e, t, i, n, r);
        }
    },
    updateItemCls: function(e, t) {
        var i = this.listItems, n = i.length, r, s;
        for (r = 0; r < n; r++) {
            s = i[r];
            s.removeCls(t);
            s.addCls(e);
        }
    },
    onItemTouchStart: function(e) {
        this.container.innerElement.on({
            touchmove: "onItemTouchMove",
            delegate: "." + Ext.baseCSSPrefix + "list-item-body",
            single: true,
            scope: this
        });
        this.callParent(this.parseEvent(e));
    },
    onItemTouchMove: function(e) {
        this.callParent(this.parseEvent(e));
    },
    onItemTouchEnd: function(e) {
        this.container.innerElement.un({
            touchmove: "onItemTouchMove",
            delegate: "." + Ext.baseCSSPrefix + "list-item-body",
            scope: this
        });
        this.callParent(this.parseEvent(e));
    },
    onItemTap: function(e) {
        this.callParent(this.parseEvent(e));
    },
    onItemTapHold: function(e) {
        this.callParent(this.parseEvent(e));
    },
    onItemSingleTap: function(e) {
        this.callParent(this.parseEvent(e));
    },
    onItemDoubleTap: function(e) {
        this.callParent(this.parseEvent(e));
    },
    onItemSwipe: function(e) {
        this.callParent(this.parseEvent(e));
    },
    parseEvent: function(e) {
        var t = this, i = Ext.fly(e.getTarget()).findParent("." + Ext.baseCSSPrefix + "list-item", 8), n = Ext.getCmp(i.id);
        return [ t, n, n.dataIndex, e ];
    },
    onItemAdd: function(e) {
        var t = this, i = e.config;
        if (i.scrollDock) {
            if (i.scrollDock == "bottom") {
                t.scrollDockItems.bottom.push(e);
            } else {
                t.scrollDockItems.top.push(e);
            }
            e.addCls(Ext.baseCSSPrefix + "list-scrolldock-hidden");
            if (t.container) {
                t.container.add(e);
            }
        } else {
            t.callParent(arguments);
        }
    },
    destroy: function() {
        Ext.destroy(this.getIndexBar(), this.indexBarElement, this.header, this.scrollDockItems.top, this.scrollDockItems.bottom);
        if (this.intervalId) {
            cancelAnimationFrame(this.intervalId);
            delete this.intervalId;
        }
        this.callParent();
    }
});

Ext.define("Twitter.view.TweetList", {
    extend: "Ext.dataview.List",
    xtype: "tweetlist",
    requires: [ "Twitter.view.TweetListItem", "Ext.plugin.PullRefresh", "Ext.plugin.ListPaging" ],
    config: {
        ui: "timeline",
        defaultType: "tweetlistitem",
        allowDeselect: false,
        useComponents: true,
        emptyText: "No tweets found.",
        plugins: [ "pullrefresh", {
            type: "listpaging",
            autoPaging: true
        } ],
        items: [ {
            docked: "top",
            xtype: "toolbar",
            hidden: true,
            ui: "searchbar",
            items: [ {
                xtype: "button",
                ui: "back",
                text: "Searches"
            } ]
        } ]
    }
});

Ext.define("Twitter.view.Main", {
    extend: "Ext.Container",
    requires: [ "Twitter.view.SearchBar", "Twitter.view.SearchList", "Twitter.view.TweetList" ],
    config: {
        fullscreen: true
    }
});

Ext.define("Twitter.view.phone.Main", {
    extend: "Twitter.view.Main",
    xtype: "mainview",
    config: {
        fullscreen: true,
        layout: "card",
        items: [ {
            layout: "fit",
            cls: "searchcontainer",
            itemId: "searchcontainer",
            items: [ {
                docked: "top",
                xtype: "searchbar"
            }, {
                xtype: "searchlist"
            } ]
        }, {
            xtype: "tweetlist"
        } ]
    }
});

Ext.define("Twitter.view.tablet.Main", {
    extend: "Twitter.view.Main",
    xtype: "mainview",
    config: {
        fullscreen: true,
        layout: "fit",
        items: [ {
            layout: "fit",
            docked: "left",
            width: 250,
            cls: "searchcontainer",
            itemId: "searchcontainer",
            items: [ {
                docked: "top",
                xtype: "searchbar"
            }, {
                xtype: "searchlist"
            } ]
        }, {
            xtype: "tweetlist"
        } ]
    }
});

Ext.define("Ext.data.proxy.WebStorage", {
    extend: "Ext.data.proxy.Client",
    alternateClassName: "Ext.data.WebStorageProxy",
    requires: "Ext.Date",
    config: {
        id: undefined,
        reader: null,
        writer: null,
        enablePagingParams: false
    },
    constructor: function(e) {
        this.callParent(arguments);
        this.cache = {};
        if (this.getStorageObject() === undefined) {
            Ext.Logger.error("Local Storage is not supported in this browser, please use another type of data proxy");
        }
    },
    updateModel: function(e) {
        if (!this.getId()) {
            this.setId(e.modelName);
        }
    },
    create: function(e, t, i) {
        var n = e.getRecords(), r = n.length, s = this.getIds(), a, o, l;
        e.setStarted();
        for (l = 0; l < r; l++) {
            o = n[l];
            if (!this.getModel().getIdentifier().isUnique) {
                Ext.Logger.warn("Your identifier generation strategy for the model does not ensure unique id's. Please use the UUID strategy, or implement your own identifier strategy with the flag isUnique.");
            }
            a = o.getId();
            this.setRecord(o);
            s.push(a);
        }
        this.setIds(s);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(i || this, e);
        }
    },
    read: function(e, t, i) {
        var n = [], r = this.getIds(), s = this.getModel(), a = s.getIdProperty(), o = e.getParams() || {}, l = e.getSorters(), u = e.getFilters(), c = e.getStart(), f = e.getLimit(), d = r.length, h, g, p;
        if (o[a] !== undefined) {
            g = this.getRecord(o[a]);
            if (g) {
                n.push(g);
                e.setSuccessful();
            }
        } else {
            for (h = 0; h < d; h++) {
                n.push(this.getRecord(r[h]));
            }
            p = Ext.create("Ext.util.Collection");
            if (u && u.length) {
                p.setFilters(u);
            }
            if (l && l.length) {
                p.setSorters(l);
            }
            p.addAll(n);
            if (this.getEnablePagingParams() && c !== undefined && f !== undefined) {
                n = p.items.slice(c, c + f);
            } else {
                n = p.items.slice();
            }
            e.setSuccessful();
        }
        e.setCompleted();
        e.setResultSet(Ext.create("Ext.data.ResultSet", {
            records: n,
            total: n.length,
            loaded: true
        }));
        e.setRecords(n);
        if (typeof t == "function") {
            t.call(i || this, e);
        }
    },
    update: function(e, t, i) {
        var n = e.getRecords(), r = n.length, s = this.getIds(), a, o, l;
        e.setStarted();
        for (l = 0; l < r; l++) {
            a = n[l];
            this.setRecord(a);
            o = a.getId();
            if (o !== undefined && Ext.Array.indexOf(s, o) == -1) {
                s.push(o);
            }
        }
        this.setIds(s);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(i || this, e);
        }
    },
    destroy: function(e, t, i) {
        var n = e.getRecords(), r = n.length, s = this.getIds(), a = [].concat(s), o;
        e.setStarted();
        for (o = 0; o < r; o++) {
            Ext.Array.remove(a, n[o].getId());
            this.removeRecord(n[o], false);
        }
        this.setIds(a);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(i || this, e);
        }
    },
    getRecord: function(e) {
        if (this.cache[e] === undefined) {
            var t = this.getRecordKey(e), i = this.getStorageObject().getItem(t), n = {}, r = this.getModel(), s = r.getFields().items, a = s.length, o, l, u, c, f, d;
            if (!i) {
                return undefined;
            }
            f = Ext.decode(i);
            for (o = 0; o < a; o++) {
                l = s[o];
                u = l.getName();
                if (typeof l.getDecode() == "function") {
                    n[u] = l.getDecode()(f[u]);
                } else {
                    if (l.getType().type == "date") {
                        d = l.getDateFormat();
                        if (d) {
                            n[u] = Ext.Date.parse(f[u], d);
                        } else {
                            n[u] = new Date(f[u]);
                        }
                    } else {
                        n[u] = f[u];
                    }
                }
            }
            c = new r(n, e);
            this.cache[e] = c;
        }
        return this.cache[e];
    },
    setRecord: function(e, t) {
        if (t) {
            e.setId(t);
        } else {
            t = e.getId();
        }
        var i = this, n = e.getData(), r = {}, s = i.getModel(), a = s.getFields().items, o = a.length, l = 0, u, c, f, d, h;
        for (;l < o; l++) {
            u = a[l];
            c = u.getName();
            if (u.getPersist() === false) {
                continue;
            }
            if (typeof u.getEncode() == "function") {
                r[c] = u.getEncode()(n[c], e);
            } else {
                if (u.getType().type == "date" && Ext.isDate(n[c])) {
                    h = u.getDateFormat();
                    if (h) {
                        r[c] = Ext.Date.format(n[c], h);
                    } else {
                        r[c] = n[c].getTime();
                    }
                } else {
                    r[c] = n[c];
                }
            }
        }
        f = i.getStorageObject();
        d = i.getRecordKey(t);
        i.cache[t] = e;
        f.removeItem(d);
        try {
            f.setItem(d, Ext.encode(r));
        } catch (g) {
            this.fireEvent("exception", this, g);
        }
        e.commit();
    },
    removeRecord: function(e, t) {
        var i = this, n;
        if (e.isModel) {
            e = e.getId();
        }
        if (t !== false) {
            n = i.getIds();
            Ext.Array.remove(n, e);
            i.setIds(n);
        }
        i.getStorageObject().removeItem(i.getRecordKey(e));
    },
    getRecordKey: function(e) {
        if (e.isModel) {
            e = e.getId();
        }
        return Ext.String.format("{0}-{1}", this.getId(), e);
    },
    getIds: function() {
        var e = (this.getStorageObject().getItem(this.getId()) || "").split(","), t = e.length, i;
        if (t == 1 && e[0] === "") {
            e = [];
        }
        return e;
    },
    setIds: function(e) {
        var t = this.getStorageObject(), i = e.join(","), n = this.getId();
        t.removeItem(n);
        if (!Ext.isEmpty(i)) {
            try {
                t.setItem(n, i);
            } catch (r) {
                this.fireEvent("exception", this, r);
            }
        }
    },
    initialize: function() {
        this.callParent(arguments);
        var e = this.getStorageObject();
        try {
            e.setItem(this.getId(), e.getItem(this.getId()) || "");
        } catch (t) {
            this.fireEvent("exception", this, t);
        }
    },
    clear: function() {
        var e = this.getStorageObject(), t = this.getIds(), i = t.length, n;
        for (n = 0; n < i; n++) {
            this.removeRecord(t[n], false);
        }
        e.removeItem(this.getId());
    },
    getStorageObject: function() {
        Ext.Logger.error("The getStorageObject function has not been defined in your Ext.data.proxy.WebStorage subclass");
    }
});

Ext.define("Ext.data.proxy.LocalStorage", {
    extend: "Ext.data.proxy.WebStorage",
    alias: "proxy.localstorage",
    alternateClassName: "Ext.data.LocalStorageProxy",
    getStorageObject: function() {
        return window.localStorage;
    }
});

Ext.define("Twitter.model.Search", {
    extend: "Ext.data.Model",
    requires: [ "Twitter.model.Tweet", "Ext.data.identifier.Uuid" ],
    config: {
        identifier: "uuid",
        fields: [ {
            name: "id"
        }, {
            name: "query",
            type: "string"
        } ],
        hasMany: {
            model: "Twitter.model.Tweet",
            name: "tweets",
            filterProperty: "query",
            store: {
                pageSize: 50,
                remoteFilter: true,
                clearOnPageLoad: false
            }
        },
        proxy: {
            type: "localstorage",
            id: "twitter-searches"
        }
    }
});

Ext.define("Twitter.store.Searches", {
    extend: "Ext.data.Store",
    requires: [ "Twitter.model.Search" ],
    config: {
        model: "Twitter.model.Search"
    }
});

Ext.define("Ext.data.ArrayStore", {
    extend: "Ext.data.Store",
    alias: "store.array",
    uses: [ "Ext.data.reader.Array" ],
    config: {
        proxy: {
            type: "memory",
            reader: "array"
        }
    },
    loadData: function(e, t) {
        this.callParent([ e, t ]);
    }
}, function() {
    Ext.data.SimpleStore = Ext.data.ArrayStore;
});

Ext.define("Ext.data.reader.Array", {
    extend: "Ext.data.reader.Json",
    alternateClassName: "Ext.data.ArrayReader",
    alias: "reader.array",
    config: {
        totalProperty: undefined,
        successProperty: undefined
    },
    createFieldAccessExpression: function(e, t, i) {
        var n = this, r = e.getMapping(), s = r == null ? n.getModel().getFields().indexOf(e) : r, a;
        if (typeof s === "function") {
            a = t + ".getMapping()(" + i + ", this)";
        } else {
            if (isNaN(s)) {
                s = '"' + s + '"';
            }
            a = i + "[" + s + "]";
        }
        return a;
    }
});

Ext.Loader.setPath({
    Ext: "../libs/touch-2.1.1/src"
});

Ext.application({
    name: "Twitter",
    requires: [ "Twitter.proxy.Twitter" ],
    profiles: [ "Phone", "Tablet" ],
    models: [ "Search", "Tweet" ],
    stores: [ "Searches" ],
    startupImage: {
        "320x460": "resources/startup/Default.jpg",
        "640x920": "resources/startup/640x920.png",
        "640x1096": "resources/startup/640x1096.png",
        "768x1004": "resources/startup/768x1004.png",
        "748x1024": "resources/startup/748x1024.png",
        "1536x2008": "resources/startup/1536x2008.png",
        "1496x2048": "resources/startup/1496x2048.png"
    },
    isIconPrecomposed: false,
    icon: {
        57: "resources/icons/icon.png",
        72: "resources/icons/icon@72.png",
        114: "resources/icons/icon@2x.png",
        144: "resources/icons/icon@144.png"
    },
    launch: function() {
        Ext.getBody().removeCls("loading");
    }
});
//@ sourceMappingURL=dest/source-map.js